# How to: бесплатные (для пользователя) децентрализованные приложени

Среди разработчиков децентрализованных приложений есть несколько тем, обсуждение которых приводит к явно выраженной боли на лицах. Такими темами являются:

1. **Работа с ключами.** Просить у пользователя ключи нельзя, но он должен как-то подписывать транзакции.
2. **Необходимость платить комиссию в токенах за каждую транзакцию**. Как объяснить пользователям, что каждая транзакция требует комиссии в токене платформы, и что не менее важно - откуда они возьмут комиссии для своих первых транзакций?

Обозначенные проблемы приводят к очень высокой стоимости привлечения одного пользователя. Например, один из популярных dApp в экосистеме Waves имел стоимость привлечения клиента около $80 (!), при LTV меньше $10. Конверсию портили именно барьеры с расширением и комиссиями.

Первая проблема часто решается с помощью браузерных расширений вроде Metamask и Waves Keeper, но это решение не дружественное для пользователей и требует большого количества усилий, поэтому в экосистеме Waves появился Signer. Он не требует предоставлять ключи dApp, и в то же время не заставляет устанавливать браузерные расширения. В статье @Vladimir Zhuravlev рассказывается об этом и как интегрировать Waves Signer в свое приложение.

А что же по поводу второй проблемы? Многие создатели dApp просто не заботятся этим вопросом, пользователи должны откуда-то взять токены для комиссий. Другие требуют привязывать банковские карты во время регистрации, что очень сильно снижает мотивацию.

**Сейчас я расскажу как решить проблему с комиссиями**. Как сделать такой dApp, который не требует наличия нативного токена у пользователя. Это позволяет делать триальные периоды. В Waves существует 2 способа сделать это. Разберем оба варианта.

## Спонсирование транзакций

Если у вас есть свой токен, который нужен пользователям вашего dApp, то вы можете использовать [механизм спонсирования транзакций](https://docs.wavesplatform.com/en/blockchain/waves-protocol/sponsored-fee). Пользователи будут платить комиссию в вашем токене, но так как майнеры всегда получают комиссию только в Waves, то фактически Waves будут списываться с аккаунта, выпустившего токен. Давайте еще раз по шагам, так как это важно понимать:

- Пользователь платит комиссию за транзакцию в вашем токене
- Вы получаете эти токены
- С вашего аккаунта списываются WAVES в необходимом количестве и уходят майнерам

*Вопрос, который должен был сразу возникнуть - сколько токенов заплатит пользователь и сколько токенов спишется с аккаунта спонсора?*

Ответ: владелец может сам установить соотношение. В момент начала спонсирования создатель токена задает сколько его токенов соответствуют минимальной комиссии (0.001 Waves или 100 000 в минимальной фракции). Давайте перейдем к примерам и коду, чтобы было понятнее.

Для включения спонсирования, необходимо отправить транзакцию типа `Sponsorship`. С помощью пользовательского интерфейса можно сделать в Waves.Exchange, а с помощью [waves-transactions](https://github.com/wavesplatform/waves-transactions) можно выполнить следующий код:

```js
const { sponsorship } = require('@waves/waves-transactions')

const seed = 'example seed phrase'

const params = {
  assetId: '4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC',
  minSponsoredAssetFee: 100
}

const signedSponsorshipTx = sponsorship(params, seed)
```

Код выше сформирует (но не отправит в блокчейн) транзакцию:

```json
{
  "id": "A",
  "type": 14,
  "version": 1,
  "senderPublicKey": "3SU7zKraQF8tQAF8Ho75MSVCBfirgaQviFXnseEw4PYg",
  "minSponsoredAssetFee": 100,
  "assetId": "4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC",
  "fee": 100000000,
  "timestamp": 1575034734209,
  "proofs": [
    "42vz3SxqxzSzNC7AdVY34fM7QvQLyJfYFv8EJmCgooAZ9Y69YDNDptMZcupYFdN7h3C1dz2z6keKT9znbVBrikyG"
  ]
}
```

Самым главным параметром в транзакции является `minSponsoredAssetFee`, который задает соответствие 100 токенов `A` равны 0.001 Waves. Таким образом, чтобы отправить `Transfer` пользователь должен будет в качестве комиссии приложить 100 токенов `A`.

Спонсируемые токены можно использовать как комиссию для транзакций типов `Transfer`, `Invoke`.

### Безопасность

Прежде чем включать спонсирование, надо понимать несколько важных моментов.

1. Пользователь может использовать спонсируемые токены для операций не только с этим токеном. Например, аккаунт с токенами `A` на балансе может отправлять токены `B`, а как комиссию приложить токены `A`.
2. Пользователь может платить не минимальную комиссию за транзакцию. Например, если у пользователя есть 100 000 ваших токенов, а вы поставили параметр `minSponsoredAssetFee` равным 100, то пользователь сможет все свои 100 000 токенов указать в качестве комиссии. Вы получите 100 000 токенов `A`, а майнер получит 1000 Waves с вашего аккаунта (100 000 / 100 = 1000), если они есть на вашем аккаунте.

Функция спонсирования есть в Waves долгое время и отлично работает, но есть [WEP-2](https://forum.wavesplatform.com/t/wep-2-customizable-sponsorship/15880), в котором высказывались идеи по его улучшению. Если вам есть что добавить - присоединяйтесь к обсуждению.

## Оплата комиссии за счет dApp

**Дисклеймер: данная возможность является НЕ документированной и может перестать работать в будущем.**

Второй вариант спонсирования подходит только для одного типа транзакций - `InvokeScript` и представляет собой достаточно простой механизм. Преимуществом по сравнению со спонсированием является отсутствие необходимости использовать свой токен.

Любой пользователь может вызвать dApp имея 0 Waves на своем аккаунте, но указав в качестве комиссии именно Waves. Скрипт начнет выполняться и, если в результата выполнения скрипта на аккаунт пользователя перечисляются Waves, то он получит их и уже оттуда спишется комиссия. Давайте не примере, так всегда ведь проще.

Например, есть dApp, который на основе адреса вызывающего отправляет или нет ему 1 Waves. **Данный пример совершенно не безопасен и приводится только для объяснения принципа работа. Ни в коем случае не используйте такую логику в своих децентрализованных приложениях.**

```scala
@Callable(invoke)
func callMeBaby() = {

    let callerAddress = invoke.caller.bytes.toBase58String()

    if (takeRight(invoke.caller.bytes, 4) == base16'ABCD') then
        TransferSet([
            ScriptTransfer(invoke.caller, 100000000, unit)
        ])
    else
    throw("You didn't win")
}
```

Если вызывать эту функцию с аккаунта, на котором 0 Waves баланса, указав `fee` в 0.005 Waves, скрипт все равно начнет выполняться. Если пользователь имеет право на получение 1 Waves, то транзакция будет считаться валидной и попадет в блокчейн. Пользователь СНАЧАЛА получит 1 Waves в резульате вызова, затем с него будет списано 0.005 комиссии.
По итогу пользователь получит на своем аккаунте 0.995 Waves. 

Некоторые уже догадались, что скрипт выше является не безопасным, потому что можно вызывать его бесконечное количество раз - если аккаунт не выиграл, то транзакция не попадет в блокчейн, если аккаунт выиграл, то получит 0.995 Waves. Беспроигрышная лотерея получилась.

Правильный рецепт заключается в том, чтобы всегда проверять дополнительные условия имеет ли пользователь права вызывать скрипт, например, иметь свой белый список.

```scala
@Callable(invoke)
func callMeBaby(uuid: String) = {

    if (isInWhiteList(invoke.caller) && invoke.fee == 500000) then {

        let id = extract(invoke.transactionId)
        let callerAddress = toBase58String(invoke.caller.bytes)

        ScriptResult(
            WriteSet([
                DataEntry(toBase58String(id), callerAddress + uuid)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(callerAddress), invoke.fee, unit)
            ])
        )
    }
    else
        throw()
}
```

Хочется дополнительно отметить, что если в будущем модель исполнения контрактов в Waves изменится и транзакции с ошибками (`throw()`) тоже будут записываться в блокчейн и снимать транзакцию, то использование этого функционала станет невозможным.

Обсуждение того, как работает описанный выше функционал и о возможных путях развития вы можете найти в этом [issue на гитхаб](https://github.com/wavesplatform/Waves/issues/2725).

## Лучшие практики

Оба решения рекомендуется использовать только для триальных режимов продуктов и проверять все граничные условия, потому что неправильное использовать может привести к потере средств.
