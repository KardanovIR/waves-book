# Глава 3. Аккаунты и ключи

Первое, с чем сталкивается человек, когда начинает пользоваться блокчейном - работа с ключами. В отличие от классических веб приложений, где у нас есть логин и пароль, в блокчейнах есть только ключи, которые позволяют идентифицировать пользователя и валидность его действий.

У каждого аккаунта есть публичный ключ и соответствующий ему приватный. Публичный ключ является фактически идентификатором аккаунта (ID), в то время как приватный позволяет сформировать подпись. В Waves используется подписи с [кривой Curve25519-Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) с ключами X25519 (что иногда является проблемой, потому что поддержка ключей X25519 есть далеко не во всех библиотеках для языков программирования).

Публичный и приватный ключи представляют из себя 32 байтовые значения, которые соответствуют друг другу по определенным правилам (подробнее можете найти в описании [EdDSA](https://blog.filippo.io/using-ed25519-keys-for-encryption/)). Важно понимать несколько вещей, которые отличаю Waves от других блокченов:

- не любые 32 байта могут быть приватным ключом
- приватный ключ не содержит в себе публичный ключ (например, в Ethereum приватный ключ содержит публичный, поэтому имеет размер в 64 байта, в Waves публичный ключ вычисляется каждый раз для приватного ключа)
- подпись с помощью EdDSA является недетерменированной, то есть одни и те же данные можно подписать одним и тем же ключом и получать разные подписи, так как используются и случайные значения

## Путешествия ключа

Большинство пользователей все-таки сталкивается с ключами не в виде массива байт, а в виде сид-фразы, часто так же называемой мнемонической фразой. Любая комбинация байт может быть сидом, но в клиентах Waves обычно используется 15 английских слов. На основе сид фразы вычисляется приватный ключ следующим образом:

1. строка переводится в массив байт
2. вычисляется хэш `blake2b256` для данного массива байт
3. вычисляется хэш `keccak256` для результата предыдущего шага
4. вычисляется приватный ключ на основе предыдущего шага, пример функции для этого шага представлен ниже

```go
func GenerateSecretKey(hash []byte) SecretKey {
    var sk SecretKey
    copy(sk[:], hash[:SecretKeySize])
    sk[0] &= 248
    sk[31] &= 127
    sk[31] |= 64
    return sk
}

```

Иными словами, а точнее кодом:
`privateKey = GenerateSecretKey(keccak256(blake2b256(accountSeedBytes)))`

Публичный и приватный ключи обычно представляют в виде `base58` строк вроде `3kMEhU5z3v8bmer1ERFUUhW58Dtuhyo9hE5vrhjqAWYT`.

При отправке транзакций (например, отправке токенов) пользователь имеет дело с адресом, а не публичным ключом получателя. Адрес генерируется из публичного ключа получателя с некоторыми дополнительными параметрами: версия спецификации адреса, байт сети и чек-сумма. В данный момент в сети Waves есть только одна версия адресов, поэтому первым байтом в этой последоствальности является `1`, второй байт - уникальный идентификатор сети, который позволяет отличать адреса в разных сетях (mainnet, testnet, stagenet и т.д.). Байты сети для перечисленных выше сетей `W`, `T`, `S` соответственно. Благодаря байту сети невозможно ошибиться и отправить токены на адрес, которого не может существовать в сети, в которой отправляется транзакция (нельзя отправить токены в mainnet на адрес в сети testnet). После первых двух служебных байт идут 20 байт, полученных в результате функций хэширования blake2b256 и keccak256 над публичным ключом. Эта операция `keccak256(blake2b256(publicKey))` возвращает 32 байта, но последние 12 байт отбрасываются. Последние 4 байта в адресе являются чек-суммой, которая считается как `keccak256(blake2b256(data))`, где `data` это первые 3 параметра (версия, байт сети и 20 байт хэша публичного ключа). Полученная последовательность байт переводится в base58 представление, чтобы получилось похожее на это: `3PPbMwqLtwBGcJrTA5whqJfY95GqnNnFMDX`.

> Опытные разработчики на Waves пользуются особенностями формирования адресов, чтобы по одному только виду определять к какой сети относится адрес. Благодаря тому, что первые 2 байта в адресе похожи для всех адресов в одной сети, можно примерно понимать к какой сети относится адрес. Если адрес выглядит как `3P...`, то адрес с большой долей вероятности относится к mainnet, а если адрес начинается с `3M...` или `3N`, то перед вами скорее всего адрес из testnet или stagenet.

## Работа с ключами

Если по какой-то причине, приложение необходимо генерировать ключи для пользователя, то можно воспользоваться библиотеками для разных языков программирования. Например, в библиотеке `waves-transactions` для JavaScript/TypeScript сгенерировать seed фразу можно с помощью следующего кода:

```js
import {seedUtils} from '@waves/waves-transactions'

const seedPhrase = seedUtils.generateNewSeed(24);

console.log(seedPhrase);

// infant history cram push sight outer off light desert slow tape correct chuckle chat mechanic jacket camp guide need scale twelve else hard cement
```

В консоль выведется строка из 24 слов, которые являются seed фразой нового аккаунта. Эти слова являются случайным подмножеством из словаря, который есть в [коде библиотеки @waves/ts-lib-crypto](https://github.com/wavesplatform/ts-lib-crypto/blob/master/src/crypto/seed-words-list.ts) и в котором содержится 2048 слов.

В данном примере я сгенерировал 24 слова, но по умолчанию во многих приложениях Waves генерируется набор из 15 слов. Почему именно 15 и увеличивается ли безопасность, если сгенерировать больше слов?

15 слов из 2048 в любом порядке достаточно, для того, чтобы вероятность генерации двух одинаковых seed фраз была пренебрежительно мала. В то же время, 24 слова еще уменьшают такую вероятность, почему бы не использовать большие значения? Ответ прост - чем больше слов мы используем, тем больше надо записывать и/или запоминать пользователю и тем сложнее ему будет. Смысл использования seed фразы (а не приватного ключа) именно в упрощении опыта пользователя, а с 24 словами мы заметно ухудшаем пользовательский опыт (user experience).

> Какова вероятность, что кто-то сможет подобрать 15 слов какого-либо кошелька? Этим вопросом задаются многие пользователи, поэтому пользователь `deemru` на одном из форумов про Waves даже провел [рассчеты](https://wavestalk.ru/t/bezopasnost-koshelka-waves/123/2). Приведу их ниже.

- Имеем 20 байт хэша публичного ключа в адресе, которые должны совпасть, это 2^160 вариантов.
- (Здесь же отметим, что 15 слов по 2048 (2^11) вариантов каждый, что даёт 2^(11*15) = 2^165, то есть перекрывают 160 бит с запасом в 5 бит, то есть 15 слов взяты не с потолка, это минимально достаточное количество, больше будет излишним, меньше не покроет всех бит публичного ключа в адресе).
- Предположим скорость перебора у нас 2 миллиона проб в секунду (такие результаты даёт например F72s_v2 (72 виртуальные цп, память 144 ГБ) на Azure, стоит сие 171 тысяча рублей в месяц).
- Начинаем считать: 2 миллиона это ~2^21 проб в секунду, за год будет 60\*60\*24*365 = 31536000 секунд, это ~2^25, получаем 2^(21+25) = 2^46 проб за год.
- Вероятность найти конкретный кошелёк 1/2^(160-46) = 1/2^114
- Миллион это ~2^20, тогда вероятность найти кошелёк из миллиона кошельков: 1/2^(114-20) = 1/2^94
- Пока тяжело… давайте предположим у нас не 1 машина, а миллион: 1/2^(94-20) = 1/2^74
- И не один год, а миллион лет: 1/2^(74-20) = 1/2^54
- Умножим миллион имеющихся мощностей на миллион дата-центров: 1/2^(54-20) = 1/2^34
- Ну вот, получилась нормальная такая вероятность (которую хотя бы в голове можно представить): 1 шанс из 17 миллиардов найти за миллион лет, в миллионах дата-центров с миллионом машин в каждом 1 кошелёк из миллиона.
- Удачи.

Теперь вернемся к тому, как работать с сид фразой. Имея seed фразу можно получить приватный ключ, публичный ключ и адрес. Я снова покажу как это сделать на JS, но вы же помните, что есть библиотеки и для других языков?

```js

import {seedUtils} from '@waves/waves-transactions';
import {
  address,
  privateKey,
  publicKey
} from '@waves/ts-lib-crypto'


const seedPhrase = seedUtils.generateNewSeed(24);

console.log(privateKey(seedPhrase));   // 3kMEhU5z3v8bmer1ERFUUhW58Dtuhyo9hE5vrhjqAWYT
console.log(publicKey(seedPhrase));    // HBqhfdFASRQ5eBBpu2y6c6KKi1az6bMx8v1JxX4iW1Q8
console.log(address(seedPhrase, 'W')); // 3PPbMwqLtwBGcJrTA5whqJfY95GqnNnFMDX
```

Обратите внимание, что в функции `privateKey` и `publicKey` мы передаем только сид фразу, в то время как в `address` передаем еще один параметр `chainId` (он же байт сети). Как вы помните из объяснения выше, адрес в себе содержит такой дополнительный параметр.

## Как аккаунт появляется в блокчейне

Мы разобрали как работают ключи, как связаны сид фраза, приватный и публичный ключ, а также как к ним относится адрес, но я не упомянул один очень важный момент, о котором забывают некоторые начинающие разработчики. До момента совершения какого-либо действия с аккаунтом (отправка с него или на него транзакции), блокчейн ничего не знает об этом аккаунте. Если вы сгенерировали аккаунт (у себя локально или в любом клиенте), но в блокчейне не было транзакций, связанных с этим аккаунтом (входящих или исходящих), вы не сможете найти никакую информацию о вашем аккаунте в эксплорере или с помощью API. Это отличается от поведения в централизованных системах и API, поэтому может быть не так интуитивно понятным и простым, но об этом важно помнить.
