# Стандартная библиотека Ride

Стандартная библиотека Ride включает в себя относительно небольшой набор функций, многие из которых связаны с криптографией (хэш функции, функции проверки подписей и т.д.). Давайте рассмотрим самые часто используемые и какие особенности есть у этих функций.

Первые версии Ride были предназначены для таких простых смарт-аккаунтов как мультиподпись, замораживания средств и работа с эскроу, поэтому стандартная библиотека была минимальной. Давайте разберем базовый пример смарт-контракта - мультиподпись.

## Мультиподпись 2 из 3

Основная идея мультиподписи 2 из 3 в том, что на каком-то аккаунте мы аккумулируем средства, которыми управляют 3 других аккаунта. Решение о переводе средств с аккаунта со средствами может быть принято при условии согласия хотя бы 2 управляющих аккаунтов. Согласие в терминах блокчейна и криптографии обозначает наличие подписи от заданных публичных ключей. Допустим, Alice, Bob и Cooper управляют аккаунтом с мультиподписью и только при наличии подписи хотя бы 2 из них, средства с аккаунта могут быть переведены.

Первое, что нам необходимо сделать - заранее определить 3 публичных ключа, которые могут подписывать транзакции с аккаунта со средствами. Публичные ключи представляю из себя массивы байт, которые могут быть представлены в Ride тремя видами примитивов `base16''`, `base58''` и `base64''`. Cтандартным представлением для ключей является `base58''`.

```scala
{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

@Verifier(tx)
func verify() = {
    #define public keys
    let alicePubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'
    let bobPubKey    = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'
    let cooperPubKey = base58'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD'
    true
}
```

Обратите внимание, что в результате функции будет возвращено значение `true`, которое будет разрешать все транзакции с этого аккаунта, без каких бы то ни было проверок подписей. Но не пугайтесь, это промежуточное состояние нашего скрипта, а `true` (или `false`) в виде возвращаемого значения необходимо, чтобы онлайн IDE не показывало нам ошибку компиляции скрипта. Продолжим реализацию нашего скрипта мультиподписи.

В стандартной библиотеке Ride есть функция `sigVerify`, которая позволяет проверить подпись сообщения. Она принимает 3 аргумента:

- сообщение
- подпись
- публичный ключ

И возвращает булевое значение (`true` - если подпись соответствует публичному ключу и сообщению, `false` в ином случае).

Публичные ключи в нашем примере уже объявлены, осталось найти еще 2 аргумента - сообщение и подписи транзакций. У объекта текущей исходящей транзакции `tx` есть поле `bodyBytes`, которое содержит подписываемое сообщение. Также у объекта `tx` есть поле `proofs`, которое содержит подписи транзакций в виде списка. Простейшая проверка подписи сообщения будет выглядет следующим образом:

```scala
    sigVerify(tx.bodyBytes, tx.proofs[0], base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM')
```

Проверка подписей для Alice, Bob и Cooper может выглядеть так:

```scala
    (sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey) && sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey)) # alice & bob
    ||
    (sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey) && sigVerify(tx.bodyBytes, tx.proofs[2], cooperPubKey)) # alice & cooper
    ||
    (sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey) && sigVerify(tx.bodyBytes, tx.proofs[2], cooperPubKey)) # bob & cooper
```

Однако более изящным способом является проверка подписи и запись в переменную 1 или 0 в зависимости от результата. Сложив эти 3 переменные и убедившись, что сумма больше 2, мы можем быть уверены, что как минимум 2 подписи были корректными.

```scala
{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

@Verifier(tx)
func verify() = {
    #define public keys
    let alicePubKey  = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'
    let bobPubKey    = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'
    let cooperPubKey = base58'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD'

    #check whoever provided the valid proof
    let aliceSigned  = if(sigVerify(tx.bodyBytes, tx.proofs[0], alicePubKey  )) then 1 else 0
    let bobSigned    = if(sigVerify(tx.bodyBytes, tx.proofs[1], bobPubKey    )) then 1 else 0
    let cooperSigned = if(sigVerify(tx.bodyBytes, tx.proofs[2], cooperPubKey )) then 1 else 0

    #sum up every valid proof to get at least 2
    aliceSigned + bobSigned + cooperSigned >= 2

}
```

Массив `proofs` всегда длиной 8, однако, в этом массиве значения могут отсуствовать в любом месте. То есть, при отправке транзакции, подписи могут лежать как в первых 3 полях массива, так и в последних трех или под индексами 1, 4 и 5. В следующем разделе мы рассмотрим как использовать `FOLD<N>`, чтобы не подразумевать наличие ключей в каких-то полях, а проверять все варианты.

> Важно: список `proofs` в полях транзакции всегда имеет размерность 8, вне зависимости от того, сколько на самом деле элементов он содержит.

Кроме функции проверки подписи `sigVerify` существует функция проверки `RSA` - `rsaVerify`. `sigVerify` которая работает с подписью для кривой Curve25519 (ED25519 c X25519 ключами, в дальнейшем для простоты будем называть "подпись Waves") не является детерменированной, то есть для одной и той же пары ключ-сообщение может быть неограниченное количество подписей. Подпись `RSA` же отличается детерменированностью, другими словами, для одного и того же сообщения и приватного ключа может быть только одна корректная подпись `RSA`.

## zk-SNARKs

В Ride еще одна функция верификации данных - `groth16Verify`. Эта функция предназначаена для верификации [доказательств с нулевым разграшелением](https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof). 

> Цель доказательств с нулевым разглашением заключается в том, чтобы проверяющий мог удостовериться в том, что проверяемый обладает знанием секретного параметра, называемого свидетельством, удовлетворяющим некоторым отношениям, не раскрывая свидетельство проверяющему или кому-либо еще.

Функция `groth16Verify` схожа с теми криптопримитивами, которые используются в блокчейне Zcash. Пример использования `groth16Verify` для прототипа децентрализованного приложения, анонимизирующего отправителя средств, можно найти в репозитории [Anonymous transactions prototype](https://github.com/wavesplatform/anonymous-transactions-prototype).

## Работа с примитивами

В Ride существует 4 основных примитивных типа данных:

- числа (только integer)
- булевые значения (boolean)
- строки (string)
- массивы байт (byte vector)

Для 2 последних типов (string и byte vector) существуют функции, облегчающие работу с ними. Например, функция `drop(data: ByteVector|String, n: Integer)` может удалять первые N байт или символов из массива байт или строки. Функция `take(data: ByteVector|String, n: Integer)` может наоборот оставить только первые N байт. Если необходимо взять байты или символы не с начала, а с конца, то существуют функции `dropRight` и `takeRight`. А для еще большего удобства есть функция `size()`.

Работа со строками в Ride стала удобнее с выходом стандартной библиотеки версии 3, которая привнесла следующие функции:

- `contains(substring: String)` - проверка входит ли подстрока в строку
- `indexOf(substring: String)` - возвращает индекс первого вхождения подстроки
- `lastIndexOf(substring: String)` - возвращает индекс последнего вхождения подстроки
- `split(delimiter: String)` - разбивает строку по разделителю и возвращает массив строк
- `size()` - возвращает количество символов в строке

## Преобразования типов

Частая необходимость в программировании на строго типизированных языках - преобразования типов. Для этого в Ride существует огромное количество функций, которые позволяют сделать `toBytes`, `toInt`, `toString`, `toUtf8String` (для произвольного массива байт). Существует и более специфические функции вроде `toBase16String`, `toBase58String`, `toBase64String`, которые преобразуют массив байт в строку в одном из представлений - `HEX`, `base58` или `base64`.

Одним из наиболее часто используемых типов в коде на Ride является `Address`, и для удобства работы с ним существует функция `addressFromString`.

## Получение данных из блокчейна

В скриптах на Ride достаточно часто приходится работать не только с параметрами вызываемой функции или отправляемой транзакции, но и с данными из блокчейна, которые можно разделить на 2 категории:

1. Данные о сущностях в блокчейне (балансы аккаунтов, информация о токенах или блоках)
2. Данные из хранилища аккаунта

Наиболее часто используемые функции из первой категории это `assetInfo(assetId: ByteVector)` и `blockInfoByHeight(N: Integer)`. Первая возвращает информацию о токене с указанным `assetId`. В том числе такие параметры как публичный ключ создателя ассета или название и описание. Вторая функция возвращает информацию о блоке с указанным номером. Для получения информации о текущем (последнем) блоке, можно использовать глобальную переменную `lastBlock`, которая так же содержит в себе структуру с информацией о блоке. Самым полезным параметром блока можно точно назвать `timestamp`, который содержит время генерации блока и является самым лучшим полем, чтобы ориентироваться на время в коде своего децентрализованного приложения (никак не `timestamp` транзакции).

Вторая категория функций позволяет читать данные из хранилища любого аккаунта (не только текущего, на котором выполняется скрипт). Как вы могли догадаться, существует 4 функции для чтения разных типов данных - `getInteger`, `getBinary`, `getBoolean`, `getString`. Каждая функция в качестве аргумента принимает адрес и ключ - `address: Address, key: String`. Для чтения с аккаунта, на котором выполняется скрипт, достаточно в качестве первого аргумента передать `this`. Все функции возвращают `Union(T|Unit)`, так как указанного ключа может не существовать. Если вы уверены, что функция будет существовать, то вы можете использовать функции `getIntegerValue`, `getBinaryValue`, `getBooleanValue` и `getStringValue`. Отличие последних заключается в том, что в случае отсутствия ключа они вернут исключение и выполнение функции прекратится.

Если вы все-таки используете `getInteger`, `getBinary`, `getBoolean` или `getString`, то в Ride есть функции, которые позволяют извечь данные из `Union` или вернуть значение по умолчанию или ошибку:

- `value()` и `extract()` - получают данные из переменной или возвращают ошибку без описания
- `valueOrElse(a: T|Unit, b: T)` - возвращают данные из переменной, если там не `Unit`, иначе возвращают второй аргумент
- `valueOrErrorMessage(a: T|Unit, b: String)` - возвращают данные из переменной, если там не `Unit`, иначе выкидывают ошибку с сообщением `b`

Полезной может быть и функция `isDefined()`, которая проверяет, что ее аргумент не является `Unit` (напомню, что `Unit` можно считать аналогом `null`).

## Работа со списками

Списки в Ride могут быть объявлены с помощью квадратных скобок `[]` и содержать любые типы данных. Некоторые функции стандартной библиотеки (например, `split` для строк) возвращают списки как результат выполнения. Для удобства работы с ними в стандартной библиотеке есть функции:

- `containsElement(list: List[T], element: T): Boolean` - проверяет есть ли элемент в списке
- `indexOf(list: List[T], element: T): Int|Unit` - возвращает первый индекс элемента или `Unit` если элемент не найден
- `lastIndexOf(list: List[T], element: T): Int|Unit` -  - возвращает последний индекс элемента или `Unit` если элемент не найден
- `min` - возвращает минимальное значение в списке
- `max(List[Int]): Int` - возвращает максимальное значение в списке
- `median(List[Int]): Int` - возвращает медианное значение в списке
- `makeString(List[String], separator: String): String` - возвращают строку со всеми элементами списка с разделителем
- `cons(T, List[T]): List[T]` - добавляет новый элемент в начало массива
- `size(List[T]): Int` - возвращает количество элементов в массиве
- `getElement(List[T], Int): T` - возвращает элемент массива под заданным индексом

Кроме функций стандартной библиотеки, в Ride есть так же операторы для работы со списками:

- `:+` - оператор для добавления элемента в конец списка
- `++` - оператор для конкатенации списков

## Другие функции

В этой книге мы не будем рассматривать все доступные функции, однако упомянуть о еще 2 категориях функций считаю нужным. Многое в блокчейне cвязано с функциями хэширования, и такие функции есть и в Ride - `keccak256`, `blake2b256` и `sha256`.

Вторая категория функций, которые очень часто бывают полезны  - математические функции `pow` для возведения степени, `log` для вычисления логарифма и `fraction(value: Int, numerator: Int, denominator: Int)`, которая перемножает первые 2 аргумента и делит на третий, позволяя избежать переполнения целочисленной переменной.

## Семейства функций

Как вы помните, у каждой функции в Ride есть `complexity`, которая определяет ее сложность. Для некоторых функций в Ride существуют аналоги, которые имеют меньшую `complexity` за счет того, что имеют лимит на размер аргумента. Например, функция `sigVerify` имеет сложность 200 и максимальный размер первого аргумента составляет 150 kb, однако в стандартной библиотеке есть функции `sigVerify_16kb`, `sigVerify_32kb`, `sigVerify_32kb`, `sigVerify_128kb`, со значениями `complexity` 100, 110, 125 и 150 соотественно. Если вы уверены, что ваш аргумент не может быть больше, чем указанные в названии функции значения, то вы можете использовать их и ваш скрипт будет иметь меньшую сложность.

Не только `sigVeriry` является семейством функций, но еще и, например функции хэширования, `rsaVerify` и `groth16Verify`. Полный список семейств функций вы можете всегда найти в документации.
