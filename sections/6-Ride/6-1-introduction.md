# Введение

RIDE - это компилируемый статически типизированный язык программирования на основе ленивых функциональных выражений, предназначенный для построения децентрализованных приложений без ошибок для разработчиков.

RIDE не является полным Тьюрингом. В нем нет никаких циклов, рекурсий и есть много ограничений по дизайну - это помогает сохранить его простым и понятным.

Несмотря на то, что он прост, он дает много возможностей разработчику. 

Он похож на Scala, а также F#.
Ride - это очень простой язык. Ознакомление с этой документацией займет у вас около часа, и к концу статьи, вы изучите почти весь язык.

## Hello world

```scala
func say() = {
  "Hello world!"
}
```

Функции объявляются с помощью `func`. Функции возвращают типы, но их не нужно объявлять, за вас это сделает компилятор. В примере выше, функция `say` вернет строку `"Hello World!"`. В языке нет `return`, потому что RIDE основан на выражениях (все является выражением), а последний оператор является результатом функции.

## Блокчейн

RIDE предназначен для использования внутри блокчейна, и нет никакого способа получить доступ к файловой системе или написать что-либо в консоли.

Функции RIDE могут считывать данные из блокчейна и возвращать транзакции в результате, которые будут записаны в блокчейн.

## Комментарии

```scala
# Это комментарий

# В языке нельзя создавать многострочные комментарии

"Hello world!" # Можно писать комментарии и в таких местах
```

## Директивы

Каждый скрипт на Ride должен начинаться с директив для компилятора. Существует 3 возможных типа директив с различными возможными значениями.

```scala
{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
```

`STDLIB_VERSION` задает версию стандартной библиотеки. Последняя версия. выпущенная в продакшн - 3.

`CONTENT_TYPE` задает тип файла, над которым вы работаете. На данный момент существуют типы `DAPP` и `EXPRESSION`. Тип `DAPP` позволяет объявлять функции и завершать выполнение скрипта некоторыми транзакциями (изменениями в блокчейне) и использовать аннотации, тогда как `EXPRESSION` позволяет завершать выполнение скрипта логическим выражением (true/false).

`SCRIPT_TYPE` задает тип сущности, к которой мы хотим добавить скрипт и изменить поведение по умолчанию. Скрипты на Ride можно прикрепить к `ACCOUNT` или `ASSET`.

```scala
{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ASSET #-} # тип dApp нельзя использовать для ASSET
```

В примере выше не все комбинации директив являются правильными. Пример выше не будет работать, ибо тип контента `DAPP` допустим только для аккаунтов, в то время как тип `EXPRESSION` доступен для активов (ассетов) и аккаунтов.

## Функции

```scala
func greet(name: String) = {
  "Hello, " + name
}

func add(a: Int, b: Int) = {
  a + b
}
```

Тип должен следовать за именем аргумента.

Как и во многих других языках функции не могут быть перегружены. Это помогает сохранить код простым, читаемым и ремонтопригодным.

Функции можно использовать только после их объявления.

## Переменные

```scala
let a = "Bob"
let b = 1
```

Переменные объявляются и инициализируются с помощью ключевого слова `let`.  Это единственный способ объявить переменные в RIDE. Все переменные в RIDE являются неизменными. Это означает, что вы не можете изменить значение переменной после объявления.

Тип переменной определеляется исходя из значения в правой части.

RIDE позволяет определять переменные внутри любой функции или в глобальной области видимости.

```scala
a = "Alice"
```

Приведенный выше код не будет компилироваться, потому что переменная `a` не определена. Все переменные в Ride нужно объявлять

```scala
func lazyIsGood() = {
  let a = "Bob"
  true
}
```

Функция выше будет скомпилирована и вернет `true` в качестве результата, но переменная `a` не будет инициализирована, потомучто RIDE ленивый, это означает, что все неиспользуемые переменные не вычисляются.

```scala
func callable() = {
  42
}

func caller() = { 
  let a = callable()
  true
}
```

Функция `callable` также не будет вызвана, поскольку переменная `a` не используется.

В отличие от большинства языков, переиспользование переменных не допускается. Объявление переменной с именем, которое уже используется в родительской области приведет к ошибке компиляции.

## Базовые типы

Основные базовые типы показаны ниже:

```scala
Boolean    #   true
String     #   "Hey"
Int        #   1610
ByteVector #   base58'...', base64'...', base16'...', fromBase58String("...") etc.
```

### Строки

```scala
let name = "Bob"
name + " is cool!" # строки будут соеденены, ибо используется знак +

name.indexOf("o")  # 1
```

В RIDE строка - это массив байтов, доступный только для чтения. Строковые данные кодируются с помощью UTF-8.

Для обозначения строк можно использовать только двойные кавычки. Строки неизменяемы, как и все другие типы. Это означает, что функция поиска подстроки в строке очень эффективна: копирование не выполняется, дополнительные выделения не требуются.

Все операторы в RIDE должны иметь значения одного и того же типа с обеих сторон. Этот код не будет компилироваться, потому что `age` - `int`:

```scala
let age = 21
"Bob is " + age # won't compile
```

Чтобы заставить код работать, мы должны преобразовать `age` в `string`:

```scala
let age = 21
"Alice is " + age.toString() # вот так работает!
```

## Специальные типы

```scala
List    # [16, 10, "hello"]
Nothing # 
Unit    # unit
```

RIDE имеет несколько типов, которые "**выглядят** как ~~утки~~ в Scala, плавают как ~~утки~~ в Scala и крякают как ~~утки~~ в Scala". 

В RIDE нет типа `null`, как во многих других языкаъ. Обычно, встроенные функции возвращают тип `Unit` вместо `null`.

```scala
"String".indexOf("substring") == unit # true
```

### Списки

```scala
let list = [16, 10, 1997, "birthday"]       # коллекция может содержать различные типы данных
let second = list[1]                        # 10 - второе значение из списка

```

Для правильной работы со списками в RIDE, у них всегда должен быть известен размер, потому что нет циклов и рекурсий.

`List` не имеет полей, но в стандартной библиотеке есть функции, которые позволяют работать с ними проще.

```scala
let list = [16, 10, 1997, "birthday"]

let last = list.getElement(list.size() - 1) # "birthday", postfix call of size() function

let lastAgain = getElement(collection, size(collection) - 1) # то же, что и выше
```

Функция `.size()` возвращает длину списка. Обратите внимание, что это значение только для чтения, и оно не может быть изменено пользователем.

```scala
let initList = [16, 10]            # init value
let newList = cons(1997, initList) # добляет новый элемент в список - [1997, 16, 10]
```

Вы можете добавить новый элемент к существующему списку с помощью функции `cons`. Нет никакого способа объединить два списка или добавить несколько значений в список.

### Union-типы

```scala
let valueFromBlockchain = getString("3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf", "someKey") # Union(String | Unit)
```

Типы Union - это очень удобный способ работы с абстракциями, `Union(String | Unit)` показывает, что значение является пересечением этих типов.

Пример ниже:
```scala
type Human : { firstName: String, lastName: String, age: Int}	
type Cat : {name: String, age: Int } 
```

`Unioin(Human | Cat)` является объектом с одним полем `age`, но мы можем использовать сопоставление шаблонов:
```scala
Human | Cat => { age: Int }
```
Сопоставление шаблонов предназначено для получения определенного поля объекта:
```scala
let t = ... # Cat | Human
  t.age                    # OK
  t.name                    # Compiler error
  let name = match t {            # OK
    case h: Human => h.firstName
    case c: Cat   => c.name
  }
```

`getString` возвращает `Union(String | Unit)` потому что при чтении данных из блокчейна (состояние ключа-значения) некоторые пары ключ-значение могут не существовать.

```scala
let valueFromBlockchain = getString("3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf", "someKey")
let realStringValue = valueFromBlockchain.extract()

# or
let realStringValue2 = getStringValue(this, "someKey")
```

Чтобы получить реальный тип и значение от использования Union, используйте функцию `extract`, которая прервет сценарий в случае значения `Unit`. Другой вариант заключается в использовании специализированных функций, таких как `getStringValue`, `getIntegerValue` и др.

## If

```scala
let amount = 1610
if (amount > 42) then "I claim that amount is bigger than 42"
else if (amount > 100500) then "Too big!"
else "I claim something else"
```

`if` операторы довольно просты и похожи на большинство других языков, за исключением двух отличий: `if` может использоваться как выражение (результат присваивается переменной) и ветвь `else` всегда требуется.

```scala
let a = 16
let result = if (a > 0) then a / 10 else 0 # 
```

## Сопоставление с образцом

```scala
let readOrInit = match getInteger(this, "someKey") {
    case a:Int => a
    case _ => 0
}
```

Сопоставление с образцом - это механизм проверки значения по образцу. RIDE позволяет использовать сопоставление с образцом только для предопределенных типов.

// : fix the definition below

Сопоставление с образцом в RIDE выглядит так же, как в Scala, но единственным вариантом использования сейчас является получение реального типа `Union` типизированной переменной. Сопоставление с образцом может быть полезно в случаях очень сложных типов, таких как `Union(Order | ReissueTransaction | BurnTransaction | MassTransferTransaction | ExchangeTransaction | TransferTransaction | SetAssetScriptTransaction | InvokeScriptTransaction | IssueTransaction | LeaseTransaction | LeaseCancelTransaction | CreateAliasTransaction | SetScriptTransaction | SponsorFeeTransaction | DataTransaction)`.

```scala
let amount = match tx { # tx - текущий объект исходящей транзакции в глобальной области видимости
  case t: TransferTransaction => t.amount
  case m: MassTransferTransaction => m.totalAmount
  case _ => 0
}
```

Приведенный выше код показывает пример использования сопоставления с образцом.В блокчейне Waves существуют различные типы транзакций, и в зависимости от типа реальное количество передаваемых токенов может храниться в разных полях. Если транзакция типа `TransferTransaction` или ` MassTransferTransaction` мы возьмем правильное поле, во всех остальных случаях мы получим 0.

## Чистые функции

\#**LET THE HOLY WAR BEGIN**

Функции RIDE являются чистыми по умолчанию, что означает, что их возвращаемые значения определяются только их аргументами, и их оценка не имеет побочных эффектов.

Это достигается отсутствием глобальных переменных и тем, что все аргументы функции по умолчанию остаются неизменными.

Однако RIDE не является чистым функциональным языком, поскольку существует функция `throw ()`, которая завершает выполнение скрипта в любой момент.

```scala
let a = getInteger(this, "key").extract()
throw("I will terminate it!")
if a < 0 then 
	"a is negative" 
else 
	"a is positive or 0"
```

В приведенном выше примере скрипт завершится на строке 2 с сообщением `I will terminate it!` и никогда не достигнет выражения `if`.

## Аннотации / модификаторы доступа

Функции могут быть определены только в скрипте с помощью `{-# CONTENT_TYPE DAPP #-}`. Функции могут быть без аннотаций, либо с аннотациями `@Callable` или `@Verifier`.

```scala
func getPayment(i: Invocation) = {
  let pmt = extract(i.payment)
  if (isDefined(pmt.assetId)) then 
    throw("This function accetps waves tokens only")
  else
  	pmt.amount
}

@Callable(i)
func pay() = {
  let amount = getPayment(i)
  WriteSet([DataEntry(i.caller.bytes, amount)])
}
```

Функции с аннотацией `@Callable` могут быть вызваны извне блокчейна. Для вызова вызываемых функций необходимо отправить `InvokeScriptTransaction`

Аннотации могут привязывать некоторые значения к функции. В приведенном выше примере переменная `i` была привязана к функции `pay` и хранила всю информацию о факте вызова (открытый ключ, адрес, платеж, прикрепленный к транзакции, комиссию, transactionId и т.д.).

Functions without annotations are not available from the outside. You can call them only inside other functions.

```scala
@Verifier(tx)
func verifier() = {
  match tx {
    case m: TransferTransaction => tx.amount <= 100 # можно отправить не больше 100 токенов
    case _ => false
  }
}
```

Функции с аннотацией `@Verifier` устанавливают правила для исходящих транзакций децентрализованного приложения (dApp). Функции верификатора нельзя вызывать извне, но они выполняются каждый раз, когда предпринимается попытка отправить транзакцию из dApp.

Функции верификатора должны всегда возвращать значение `Boolean` в качестве результата, в зависимости от этого транзакция попадет в блокчейн или нет.

Функция верификатора использует переменную  `tx`, которая является объектом со всеми полями текущей исходящей транзакции.

В одном скрипте может быть определена только одна функция верификатора.

```scala
@Callable(i)
func callMeMaybe() = {
  let randomValue = getRandomValue()
  WriteSet([DataEntry("key", randomValue)])
}

func getRandomValue() = {
  16101997 # достаточно рандомное число
}
```

Это не будет компилироваться, потому что функции **без** аннотаций должны быть определены **перед** функциями с аннотациями.

### Предопределенные структуры данных

RIDE имеет много предопределенных специфических структур данных для Waves Blockchain, таких как: `Address`, `Alias`, `DataEntry`, `ScriptResult`, `Invocation`, `ScriptTransfer`, `TransferSet`, `WriteSet`, `AssetInfo`, `BlockInfo`.

```scala
let keyValuePair = DataEntry("someKey", "someStringValue")
```

`DataEntry` это структура данных, которая описывает пару ключ-значение, как в хранилище учетных записей.

```scala
let transferSet = TransferSet([ScriptTransfer("3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs", amount, unit)])
```



Все структуры данных могут быть использованы для проверки типов, сопоставления с образцами и их конструкторов.

## Hезультат выполнения

```scala
@Verifier(tx)
func verifier() = {
  "Returning some string"
}
```

Expression-скрипты (с директивой `{-# CONTENT_TYPE EXPRESSION #-}`) наряду с функциями `@Verifier` должны всегда возвращать логическое выражение. В зависимости от этого значения транзакция будет принята (в случае `true`) или отклонена (в случае `false`) блокчейном.

```scala
@Callable(i)
func giveAway(age: Int) = {
  ScriptResult(
    WriteSet([DataEntry("age", age)]),
    TransferSet([ScriptTransfer(i.caller, age, unit)])
  )
}
```

Каждый, кто вызовет функцию `giveAway` получит столько waves, сколько ему лет, и dApp будет хранить информацию о факте передачи в своем "состоянии".

`@Callable` функции могут заканчиваться двумя типами изменений блокчейна - изменениями состояния и передачей токенов.

Список `DataEntry` в `WriteSet` устанавливает или обновляет пары ключ-значение в хранилище учетной записи, а список `ScriptTransfer` в `TransferSet` перемещает токены из учетной записи dApp в другие учетные записи.

```scala
@Callable(i)
func callMePlease(age: Int) = {
  TransferSet([ScriptTransfer(i.caller, age, unit)])
}
```

`@Callable` функции могут возвращать одну из следующих структур: `ScriptResult`, `WriteSet`, `TransferSet`. 

`WriteSet` может содержать до 100 `DataEntry`, `TransferSet` может содержать до 10 `ScriptTransfer`. 

## Исключения

```scala
throw("Here is exception text")
```

`throw` функция немедленно завершит выполнение скрипта с предоставленным текстом. Нет никаких способов поймать брошенные исключения.

Основная идея `throw` заключается в том, чтобы остановить выполнение и отправить пользователю информативную обратную связь.

```scala
let a = 12
if (a != 100) then throw ("a is not 100, actual value is " + a.toString())
else throw("A is 100")
```

`throw` функция может быть использована для отладки кода при разработке dApps, потому что нет отладчиков для RIDE пока что.

## Контекст выполнения

```scala
{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let a = this # Адрес текущего аккаунта
a == Address(base58'3P9DEDP5VbyXQyKtXDUt2crRPn5B7gs6ujc') # true если скрипт запущен на аккаунте с определенным адресом
```

RIDE скрипты в блокчейне waves могут быть привязаны к счетам и активам (`{-# SCRIPT_TYPE ACCOUNT #-}`) и в зависимости от `SCRIPT_TYPE` ключевое слово `this` может ссылаться на различные сущности. Для типа скрипта `ACCOUNT`, `this` это тип `Address`

Для типа скрипта `ASSET`, `this` это тип `AssetInfo`

```scala
{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let a = this # Адрес текущего аккантуа
a == Address(base58'3P9DEDP5VbyXQyKtXDUt2crRPn5B7gs6ujc') # true если скрипт запущен на аккаунте с определенным адресом
```