# Введение

RIDE - это компилируемый статически типизированный функциональный язык программирования с ленивым исполнением, предназначенный для построения децентрализованных приложений. Язык создавался с целью помочь разработчикам писать код без ошибок.

RIDE не является Тьюринг-полным языком. В нем нет циклов (в классическом понимании), рекурсий и предусмотрено много ограничений, которые позволяют делать приложения простыми для понимания и отладки.

## История создания

Основным идейным вдохновителем создания Ride является Илья Смагин. Язык изначально был нацелен на реализацию простых кейсов вроде мульти-подписи и впервые появился в Mainnet летом 2018, позволяя писать скрипты для создания смарт-аккаунтов. В январе 2019 года на Ride стало возможным писать скрипты для смарт-ассетов, а в июле 2019 уже появилась возможность писать полноценные децентрализованные приложения благодаря релизу под названием Ride4dapps.

Философия языка и его создателей сводится к нескольким простым правилам:

1. Язык программирования - это инструмент для реализации конкретных кейсов. Усложнение языка и добавление новых конструкций делаются только если есть кейсы и бизнесы, которым этого не хватает.
2. Тьюринг-полнота вместе с масштабируемостью мало достижимы в рамках публичной блокчейн системы, поэтому язык должен быть удобен и без этой характеристики.
3. Ride - специфичный язык для написания децентрализованных приложений, а не язык общего назначения, поэтому в языке есть специфичные конструкции.

Язык испытал большое влияение Scala и F#. Нельзя сказать, что Ride очень сильно похож на какой-то из этих языков, но людям, которые знают эти языки, будет проще начать писать на Ride. В то же время, язык прост и для разработчиков на всех других языках, первичное ознакомление с языком и инструментами занимает обычное около часа. К концу этой главы вы изучите почти весь язык и все основные конструкции.

Несмотря на то, что Ride прост, он дает много возможностей разработчику. Давайте перейдем к синтаксису языка.

## Hello world

```scala
func say() = {
  "Hello world!"
}
```

Функции объявляются с помощью `func`. Функции возвращают типы, но их не нужно объявлять, за вас это сделает компилятор. В примере выше, функция `say` вернет строку `"Hello World!"`. В языке нет `return`, потому что RIDE основан на выражениях (все является выражением), а последний оператор является результатом функции.

## Блокчейн

RIDE предназначен для использования внутри блокчейна, и нет никакого способа получить доступ к файловой системе.

Функции RIDE могут считывать данные из блокчейна и возвращать транзакции в результате, которые будут записаны в блокчейн.

## Комментарии

```scala
# Это комментарий

# В языке нельзя создавать многострочные комментарии

"Hello world!" # Можно писать комментарии и в таких местах
```

## Директивы

Каждый скрипт на Ride должен начинаться с директив для компилятора. Существует 3 возможных типа директив с различными возможными значениями.

```scala
{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
```

`STDLIB_VERSION` задает версию стандартной библиотеки. Последняя версия в mainnet - 3, в stagenet - 4.

`CONTENT_TYPE` задает тип файла, над которым вы работаете. На данный момент существуют типы `DAPP` и `EXPRESSION`. Тип `DAPP` позволяет объявлять функции, завершать выполнение скрипта некоторыми транзакциями (изменениями в блокчейне) и использовать аннотации, тогда как `EXPRESSION` позволяет завершать выполнение скрипта логическим выражением (`true` или `false`).

`SCRIPT_TYPE` задает тип сущности, к которой мы хотим добавить скрипт и изменить поведение по умолчанию. Скрипты на Ride можно прикрепить к `ACCOUNT` или `ASSET`.

```scala
{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ASSET #-} # тип dApp нельзя использовать для ASSET
```

Не все комбинации директив являются правильными. Пример выше не будет работать, ибо тип контента `DAPP` допустим только для аккаунтов, в то время как тип `EXPRESSION` доступен для токенов (ассетов) и аккаунтов.

## Функции

```scala
func greet(name: String) = {
  "Hello, " + name
}

func add(a: Int, b: Int) = {
  a + b
}
```

Тип должен следовать за именем аргумента.

Как и во многих других языках, функции не могут быть перегружены. Это помогает сохранить код читаемым и простым для изменений.

Функции можно использовать только после их объявления.

## Переменные

```scala
let a = "Bob"
let b = 1
```

Переменные объявляются и инициализируются с помощью ключевого слова `let`.  Это единственный способ объявить переменные в RIDE. Все переменные в RIDE являются иммутабельными. Это означает, что вы не можете изменить значение переменной после объявления.

Тип переменной определеляется, а если быть точнее, то выводится (type inference) исходя из значения в правой части.

RIDE позволяет определять переменные внутри любой функции или в глобальной области видимости.

```scala
a = "Alice"
```

Приведенный выше код не будет компилироваться, потому что переменная `a` не определена. Все переменные в Ride нужно объявлять c помощью ключевого слова `let`.

```scala
func lazyIsGood() = {
  let a = "Bob"
  true
}
```

Функция выше будет скомпилирована и вернет `true` в качестве результата, но переменная `a` не будет инициализирована, потому что RIDE ленивый, это означает, что все неиспользуемые переменные не вычисляются.

```scala
func callable() = {
  42
}

func caller() = {
  let a = callable()
  true
}
```

Функция `callable` также не будет вызвана, поскольку переменная `a` не используется.

В отличие от большинства языков, переиспользование переменных не допускается. Объявление переменной с именем, которое уже используется в родительской области видимости, приведет к ошибке компиляции.

## Базовые типы

Основные базовые типы показаны ниже:

```scala
Boolean    #   true
String     #   "Hey"
Int        #   1610
ByteVector #   base58'...', base64'...', base16'...', fromBase58String("...") etc.
```

### Строки

```scala
let name = "Bob"
name + " is cool!" # строки будут соеденены, ибо используется знак +

name.indexOf("o")  # 1
```

В RIDE строка - это массив байт, доступный только для чтения. Строковые данные кодируются с помощью UTF-8.

Для обозначения строк можно использовать только двойные кавычки. Строки неизменяемы, как и все другие типы. Это означает, что функция поиска подстроки в строке очень эффективна: копирование не выполняется, дополнительные выделения не требуются.

Все операторы в RIDE должны иметь значения одного и того же типа с обеих сторон. Код ниже не будет компилироваться, потому что `age` имеет тип `Int`, а `"Bob is "` является строкой:

```scala
let age = 21
"Bob is " + age # не будет компилироваться
```

Чтобы заставить код работать, мы должны преобразовать `age` в `String`:

```scala
let age = 21
"Alice is " + age.toString() # вот так работает!
```

## Специальные типы

```scala
List    # [16, 10, "hello"]
Nothing #
Unit    # unit
```

RIDE имеет несколько типов, которые "**выглядят** как ~~утки~~ в Scala, плавают как ~~утки~~ в Scala и крякают как ~~утки~~ в Scala". Например, типы `Nothing` и `Unit`.

В RIDE нет типа `null`, как во многих других языках. Обычно, встроенные функции возвращают тип `Unit` вместо `null`.

```scala
"String".indexOf("substring") == unit # true
```

### Списки

```scala
let list = [16, 10, 1997, "birthday"]       # коллекция может содержать различные типы данных
let second = list[1]                        # 10 - второе значение из списка

```

Для правильной работы со списками в RIDE, у них всегда должен быть известен размер, потому что нет циклов и рекурсий.

`List` не имеет полей, но в стандартной библиотеке есть функции, которые позволяют работать с ними проще.

```scala
let list = [16, 10, 1997, "birthday"]

let last = list.getElement(list.size() - 1) # "birthday", постфиксный вызов функции size()

let lastAgain = getElement(collection, size(collection) - 1) # то же, что и выше
```

Функция `.size()` возвращает длину списка. Обратите внимание, что это значение только для чтения, и оно не может быть изменено.

```scala
let initList = [16, 10]            # init value
let newList = cons(1997, initList) # создает новый список с элементами initLinit и новым значением - [1997, 16, 10]
```

Вы можете добавить новый элемент к существующему списку с помощью функции `cons`. Изначальный список не будет изменен, `cons` вернет новый список. Нет никакого способа объединить два списка или добавить несколько значений в список.

<!-- TODO: поправить про списки -->

### Union-типы

```scala
let valueFromBlockchain = getString("3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf", "someKey") # Union(String | Unit)
```

Типы Union - это очень удобный способ работы с абстракциями, `Union(String | Unit)` показывает, что значение является пересечением этих типов.

Если бы в Ride были пользовательские типы, то можно было бы разобрать следующий пример:

```scala
type Human : { firstName: String, lastName: String, age: Int}
type Cat : {name: String, age: Int }
```

`Unioin(Human | Cat)` является объектом с одним полем `age`. Обычно `Union` возвращается в результате вызовов функций, когда в зависимости от параметров рантайм языка мог получить различные типы.

```scala
Human | Cat => { age: Int }
```

Мы можем использовать pattern matching, чтобы выяснить настоящий тип:

```scala
let t = ... # Union(Cat | Human)
let age = t.age                    # OK
let name = t.name                    # Compiler error
let name = match t {            # OK
  case h: Human => h.firstName
  case c: Cat   => c.name
}
```

Например, функция `getString` для чтения строк из хранища аккаунта возвращает `Union(String | Unit)` потому что некоторые ключи (и их значения соответсвенно) могут не существовать.

```scala
let valueFromBlockchain = getString("3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf", "someKey")
let realStringValue = valueFromBlockchain.extract()

# or
let realStringValue2 = getStringValue(this, "someKey")
```

Чтобы получить реальный тип и значение от Union, можно использовать не только pattern matching, но и функцию `extract`, которая прервет скрипт в случае значения `Unit`. Другой вариант заключается в использовании специализированных функций, таких как `getStringValue`, `getIntegerValue` и др., чье поведение будет идентичным (ошибка если значения нет в хранилище или по заданному ключу хранится другой тип данных).

## If

```scala
let amount = 1610
if (amount > 42) then "I claim that amount is bigger than 42"
  else if (amount > 100500) then "Too big!"
  else "I claim something else"
```

`if` операторы довольно просты и похожи на большинство других языков, за исключением двух отличий: `if` может использоваться как выражение (результат присваивается переменной) и ветвь `else` всегда обязательна.

```scala
let a = 16
let result = if (a > 0) then a / 10 else 0 #
```

## Pattern matching

```scala
let readOrInit = match getInteger(this, "someKey") {
    case a:Int => a
    case _ => 0
}
```

Pattern matching - это механизм проверки значения по образцу. RIDE позволяет использовать pattern matching только для предопределенных типов.

Pattern matching в RIDE выглядит так же, как в Scala, но единственным вариантом использования сейчас является получение реального типа от переменной с типом `Union`. Pattern matching может быть полезен, когда в результате вызова переменной мы можем получить значение с типом `Union(Int | Unit)` или даже бывает такое `Union(Order | ReissueTransaction | BurnTransaction | MassTransferTransaction | ExchangeTransaction | TransferTransaction | SetAssetScriptTransaction | InvokeScriptTransaction | IssueTransaction | LeaseTransaction | LeaseCancelTransaction | CreateAliasTransaction | SetScriptTransaction | SponsorFeeTransaction | DataTransaction)`.

```scala
let amount = match tx { # tx - текущий объект исходящей транзакции в глобальной области видимости для смарт аккаунта
  case t: TransferTransaction => t.amount
  case m: MassTransferTransaction => m.totalAmount
  case i: InvokeScriptTransaction => if (i.payment) i.payment.extract().amount else 0
  case _ => 0
}
```

Приведенный выше код показывает пример использования pattern matching, когда мы хотим получить количество передаваемых токенов в текущей транзакции от заданного аккаунта. В зависимости от типа транзакции, реальное количество передаваемых токенов может храниться в разных полях. Если транзакция типа `TransferTransaction`, `MassTransferTransaction` или `InvokeScriptTransaction`, мы возьмем правильное поле, во всех остальных случаях мы получим 0.

## Чистые функции (pure functions)

Функции RIDE являются чистыми (pure) по умолчанию, что означает, что их возвращаемые значения определяются только их аргументами, и их оценка не имеет побочных эффектов. Честно говоря, относительно "чистоты" функций в Ride было огромное количество споров среди самих разработчиков Ride. Дело в том, что в Ride есть одна переменная в глобальной области видимости - `height`, которая хранит текущую высоту блокчейна (номер текущего блока, в который попадает данная транзакция). В теории, результат функции зависит не только ее параметров, но и от окружения (этой переменной `height`), поэтому некоторые скажут, что функции "не полностью чистые" или даже "не чистые совсем".

В любом случае, RIDE не является чистым функциональным языком, поскольку также существует функция `throw ()`, которая завершает выполнение скрипта в любой момент. То есть функция может не завершиться вовсе, а не просто завершиться с ошибкой, поэтому все-таки полностью функциональным язык назвать не получится.

```scala
let a = getInteger(this, "key").extract()
throw("I will terminate it!")
let result = if a < 0 then
  "a is negative"
else
  "a is positive or 0"
```

В приведенном выше примере скрипт завершится на строке 2 с сообщением `I will terminate it!` и никогда не достигнет выражения `if`.

## Аннотации / модификаторы доступа

Функции могут быть определены только в скрипте с помощью `{-# CONTENT_TYPE DAPP #-}`. Они могут быть без аннотаций, либо с аннотациями `@Callable` или `@Verifier`.

```scala
func getPayment(i: Invocation) = {
  let pmt = extract(i.payment)
  if (isDefined(pmt.assetId)) then
    throw("This function accetps waves tokens only")
  else
    pmt.amount
}

@Callable(i)
func pay() = {
  let amount = getPayment(i)
  WriteSet([DataEntry(i.caller.bytes, amount)])
}
```

Функции с аннотацией `@Callable` могут быть вызваны извне блокчейна. Для вызова вызываемых функций необходимо отправить `InvokeScript` транзакцию.

Аннотации могут "привязывать" некоторые значения к функции. В приведенном выше примере переменная `i` была привязана к функции `pay` и хранила всю информацию о факте вызова (публичный ключ, адрес, платеж, прикрепленный к транзакции, комиссию, id транзакции и т.д.).

Функции без аннотаций **не** могут быть вызваны "извне", только сам скрипт может их вызывать. То есть `Callable` или `Verifier` функция начитают выполнение, в ходе которого могут вызвать функцию без аннотации.

```scala
@Verifier(tx)
func verifier() = {
  match tx {
    case m: TransferTransaction => tx.amount <= 100 # можно отправить не больше 100 токенов
    case _ => false
  }
}
```

Функции с аннотацией `@Verifier` устанавливают правила для исходящих транзакций децентрализованного приложения (dApp) или смарт-аккаунта. Функции верификатора нельзя вызывать извне, но они выполняются каждый раз, когда предпринимается попытка отправить транзакцию с этого аккаунта.

Функции верификатора должны всегда возвращать значение `Boolean` в качестве результата, в зависимости от этого транзакция попадет в блокчейн или нет.

Функция верификатора использует переменную `tx`, которая является объектом со всеми полями текущей исходящей (и проверяемой) транзакции.

В одном скрипте может быть определена только одна функция-верификатор с аннотацией `@Verifier`.

```scala
@Callable(i)
func callMeMaybe() = {
  let randomValue = getRandomValue()
  [IntegerEntry("key", randomValue)]
}

func getRandomValue() = {
  16101997 # достаточно рандомное число
}
```

Этот код не будет компилироваться, потому что функции **без** аннотаций должны быть определены **перед** функциями с аннотациями.

### Предопределенные структуры данных

RIDE имеет много предопределенных специфических структур данных для Waves Blockchain, таких как: `Address`, `Alias`, `IntegerEngry`, `StringEntry`, `Invocation`, `ScriptTransfer`, `AssetInfo`, `BlockInfo` и тд.

```scala
let keyValuePair = StringEntry("someKey", "someStringValue")
```

`StringEntry` это структура данных, которая описывает пару ключ-значение, как в хранилище аккаунта, где значением является строка.

```scala
let ScriptTransfer = ScriptTransfer("3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs", amount, unit)
```

Все встроенные структуры данных могут быть использованы для проверки типов и pattern matching.

## Результат выполнения

```scala
@Verifier(tx)
func verifier() = {
  "Returning some string"
}
```

Expression-скрипты (с директивой `{-# CONTENT_TYPE EXPRESSION #-}`) наряду с функциями `@Verifier` должны всегда возвращать логическое выражение. В зависимости от этого значения транзакция будет принята (в случае `true`) или отклонена (в случае `false`) блокчейном.

```scala
@Callable(i)
func giveAway(age: Int) = {

  let callerAddress = i.caller
  let reissuable = false
  let assetScript = Unit
  let decimals = 0
  let amount = 100
  let nonce = 0
  let newAsset = Issue(assetScript, decimals, "Description here", reissuable, "MyCoolToken", amount, nonce)


  [
    ScriptTransfer(callerAddress, age, unit),
    IntegerEntry("ageof_" + callerAddress.toBase58String(), age),
    BooleanEntry("booleanKey", true),
    StringEntry("stringKey", "somevalue"),
    BinaryEntry("binaryKey", base58'3P'),
    DeleteEntry("ScriptTransfer(i.caller, 100, newAsset.calculateAssetId()),"),
    newAsset,
    ScriptTransfer(i.caller, 100, newAsset.calculateAssetId()),
    Reissue(base58'81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9W', reissuable, amount),
    Burn(base58'81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9W', amount)
  ]
}
```

Каждый, кто вызовет функцию `giveAway` получит столько Waves, сколько ему лет (количество лет сам пользователь передает в виде аргумента), и dApp будет хранить информацию о факте передачи в своем стейте, кроме этого скрипт запишет в хранилище данного децентрализованного приложения несколько пар ключ-значений (буловое значение, массив байт, строку) и удалит целиком пару с ключом `deleteKey`. Скрипт так же выпустит новый токен с названием `MyCoolToken`, отправит 100 таких токенов вызывающему аккаунту, довыпустит 100 токенов с `assetId` равным `81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9W` и сожжет 100 токенов с таким же `assetId`.

`@Callable` функции могут заканчиваться 5 типами изменений блокчейна:

1. Изменение состояния key-value хранилища, в том числе добавление и удаление пар
2. Выпуск токенов
3. Перевыпуск токенов
4. Передача токенов
5. Сжигание токенов

Каждый результирующий Issue увеличивает комиссию за вызов такой функции на 1 Waves (если выпускается не NFT токен).

Результирующий массив может содержать до 100 изменений данных в хранилище и 10 операций с токенами (выпуск, сожжение, отправка, перевыпуск).

## Исключения

```scala
throw("Here is exception text")
```

`throw` функция немедленно завершит выполнение скрипта с предоставленным текстом. Нет никаких способов поймать брошенные исключения.

Основная идея `throw` заключается в том, чтобы остановить выполнение и отправить пользователю информативную обратную связь.

```scala
let a = 12
if (a != 100) then throw ("a is not 100, actual value is " + a.toString())
else throw("A is 100")
```

`throw` функция может быть использована для отладки кода при разработке dApps, так как дебаггера для Ride пока не существует.

## Контекст выполнения

```scala
{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let a = this # Адрес текущего аккаунта
a == Address(base58'3P9DEDP5VbyXQyKtXDUt2crRPn5B7gs6ujc') # true если скрипт выполняется на аккаунте с определенным адресом
```

RIDE скрипты в блокчейне waves могут быть привязаны к аккаунтам и токенам (директивой `{-# SCRIPT_TYPE ACCOUNT | ASSET #-}`), и в зависимости от `SCRIPT_TYPE` ключевое слово `this` может ссылаться на различные сущности. Для типа скрипта `ACCOUNT`, `this` это `Address`

Для типа `ASSET`, `this` это тип `AssetInfo`

```scala
{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ASSET #-}

let a = this # AssetInfo для текущего токена, с которым совершается операция
a == assetInfo(base58'5fmWxmtrqiMp7pQjkCZG96KhctFHm9rJkMbq2QbveAHR') # true если скрипт выполняется для ассета с указанным ID
```

## Макрос FOLD<N>

Отсутствие Тьюринг полноты (об этом мы поговорим подробнее чуть позже) не позволяет в Ride иметь полноценные циклы, однако в языке есть макрос `FOLD`, который позволяет выполнять указанную функцию несколько раз и "собрать" результат в одну переменную.

```scala
func sum(acc:Int, el:Int) = acc + el
let arr = [1, 2, 3, 4, 5]
let sum = FOLD<5>(arr, 0, sum) # result: 15
```

Параметр в угловых скобках (5 в примере выше) задает сколько максимум раз будет вызвана функция `sum`. Каждый новый вызов будет передавать в качестве аргумента следующий элемент массива `arr`. Второй параметр макроса `FOLD` задает начальное значение. Функция `sum` принимает 2 аргумента:

- `acc` - cумма с предыдущего шага
- `el` - следующий элемент массива

`sum` будет вызываться со следующими параметрами:

```scla
sum(0, 1)  # 1
sum(1, 2)  # 3
sum(3, 3)  # 6
sum(6, 4)  # 10
sum(10, 5) # 15
```

`FOLD<N>` является макросом, то есть синтаксическим сахаром. Интерпретатор Ride ничего не знает про `FOLD`, потому что в момент компиляции `FOLD` превращается в подобный код:

```scala
let result = {
   let size = arr.size()
   if(size == 0) then acc0 else {
      let acc1 = function(acc0, arr[0])
      if(size == 1) then acc1 else {
         let acc2 = function(acc1, arr[1])
         if(size == 2) then acc2 else {
            let acc3 = function(acc2, arr[2])
            if(size == 3) then acc3 else {
               let acc4 = function(acc3, arr[3])
               if(size == 4) then acc4 else {
                  let acc5 = function(acc4, arr[4])
                  if(size == 5)
                     then acc5
                     else
                       throw("Too big array, max 5 elements")
}}}}}}
```

Выглядит намного хуже, чем `FOLD<N>`. Параметр `N` всегда должен являться целым числом выше 0 и является обязательным. То есть, разработчик должен знать максимальный размер списка, который будет обрабатываться с помощью `FOLD`.

Если в `FOLD<N>` передать массив размерностью больше, чем `N`, то будет выброшено исключение.

Не все операции, возможные с другими циклами, можно реализовать с помощью `FOLD`.

## Процесс разработки

Разработка любого приложения начинается с идеи, и децентрализованные приложения тут не исключения, однако, когда дело доходит до кода, хорошо бы иметь четкую последовательность шагов, как реализованную в коде идею запустить и дать на суд ощественности. В случае с децентрализованными приложениями на Ride, полный жизненный цикл выглядит следующим образом:

1. Написанный код на Ride компилируется в base64 представление. Существует 2 компилятора для Ride - на JavaScript и на Scala. Скомпилировать код можно с помощью разных инструментов - онлайн IDE, REST API ноды, библиотеки `surfboard` или `ride-js`, расширение для Visual Studio Code. Об этих инструментах мы поговорим чуть позже в этом разделе.
2. Скомпилированный скрипт отправляется в блокчейн в составе транзакции - `SetAssetScript` или `Issue` для смарт-ассетов, `SetScript` для смарт-аккаунтов и децентрализованных приложений или. Все эти транзакции имеют поле `script`, который принимает скомпилированный код в `base64` представлении.
3. После попадания транзакции со скриптом в блок, поведение аккаунта или ассета меняется в соответствии с тем, что написано в коде.
4. В случае со смарт-ассетами, смарт-аккаунтами и функциями `@Verifier`, код контракта будет исполняться каждый раз, когда аккаунт со скриптом отправляет транзакцию или совершается транзакция с токеном со скриптом.
5. В случае с `@Callable` функциями, их выполнение начинается в тот момент, когда любой пользователь вызывает функцию с помощью `InvokeScript` транзакции.
6. Обновление скрипта на новый возможно и для токенов и для аккаунтов в том случае, когда это не запрещено кодом установленного скрипта.
