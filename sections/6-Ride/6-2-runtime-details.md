# Рантайм языка Ride

Смарт-контракты и децентрализованные приложения в Waves отличаются от таковых в Ethereum и многих других блокчейнах. Давайте рассмотрим основные отличия и их причины.

## Подсчет сложности

Все функции и операции в Ride, в том числе операции сложения, вычитания, деления, ветвления, а так же функции стандартной библиотеки имеют сложность. Сложность каждой операции выражается в условных единицах (назовем `complexity`, иначе придется называть `попугаи`). Например, операция сложения имеет complexity равную 1, а функция проверки подписи `sigVerify()` имеет complexity 200.

Так как в каждом скрипте есть много вариантов исполнения из-за ветвлений, то `complexity` скрипта считается как сложность самой сложной ветки. Если вы используете, например, online IDE, то он будет показывать сложность скрипта в режиме реального времени.

В Ride есть ограничение на максимальную сложность скрипта, и она разная для разных типов функций. Для функций `@Verifier`, смарт-аккаунтов и смарт-ассетов максимальная сложность скрипта составляет 3000 единиц, а для функций `@Callable` наиболее сложная ветка может иметь 4000 единиц. В отличие от других языков смарт-контрактов, например Solidity в Ethereum, сложность скрипта в Ride всегда известна заранее, так как отсутствует Тьюринг-полнота. В случае Ethereum, довольно часто бывает, что мы используем цикл в коде, но не знаем сколько итераций будет в этом цикле в момент исполнения (код может читать коллекцию произвольной длины и итерировать по ней). Другой возможный в Ethereum сценарий - использование рекурсии. В Ride и Waves такое невозможно, так как отсутсвуют полноценные циклы - макрос `FOLD` заранее ограничивает максимальное количество исполнений, а рекурсий как таковых просто нет.

Заранее известная сложность избавляет от такой проблемы в Ethereum как `Out of gas`. Все, кто писал смарт-контракты и делал децентрализованные приложения на Solidity сталкивались с такой ситуацией, когда транзакция стала невалидной из-за того, что "закончился газ". В Waves такая ситуация попросту невозможна.

Кроме ограничения по максимальной сложности контракта, так же есть ограничение на максимальный размер контракта, на момент написания оно составляет 32 кб. То есть код децентрализованного приложения не может быть больше 32 кб.

## Отсутствие Тьюринг полноты

Ride является *не* Тьюринг полным языком, но не потому, что сделать Тьюринг полноту сложно или долго, а потому что у такого подхода есть свои плюсы. Блокчейн является не самой высокопроизводительной системой, ведь все транзакции выполняется на каждой ноде, а на сетевые коммуникации уходит большое количество ресурсов. Есть различные подходы к масштабированию, например, шардинг, создание сайдчейнов и т.д., но все они являются копромиссами - при увеличении пропускной способности всегда страдает уровень децентрализации или безопасность. Именно это утверждает блокчейн трилемма. Из 3 характеристик блокчейна - децентрализации, скорости и безопасности, полностью обеспечить можно только 2. Или другими словами, необходимо выбирать одну грань у треугольника:

![The blockchain trilemma](../../assets/6-2-1-the-blockchain-trilemma.jpeg "The blockchain trilemma")

Как вы возможно помните, в ценностях Waves всегда быть максимально дружелюбной платформой для разработчиков и пользователей, поэтому скорость работы не должна быть узким местом, но в то же время блокчейн Waves не позволит делать десятки тысяч транзакций в секунду, так как блокчейн должен оставаться безопасным и децентрализованным. 

Отсутствие Тьюринг-полноты позволяет Waves предлагать оптимальное сочетание этих 3 характеристик:

1. Из-за отсутствия сложных скриптов, нода Waves может быть запущена на виртуальной машине за $40 в любом публичном облаке, что способствует децентрализации
2. Простота скриптов так же позволяет блокчейну иметь достаточную пропускную способность, чтобы даже при среднесуточном количестве транзакций в [100 000](http://dev.pywaves.org/txs/), не было конкуренции за попадание в блок и, соответственно, высоких комиссий.
3. Отсутствие Тьюринг-полноты делает смарт-контракты безопаснее. Ride является в какой-то мере DSL (domain specific language) или предметно-ориентированным языком, а не языком общего назначения, и именно DSL применяются в сферах, где требуется максимальная безопасность. Подробнее про это я рассказывал на одной из конференций в Сан-Франциско, с записью выступления вы можете ознакомиться [здесь](https://www.youtube.com/watch?v=gMcif_ADWak).

Таким образом, отсутствие Тьюринг-полноты несет в себе массу преимуществ, однако, это влияет на опыт разработки, давайте рассмотрим каким именно образом.

## Последствия отсутствия Тьюринг полноты

Отсуствие Тьюринг полноты иногда не позволяет реализовать весь необходимый функционал в рамках одной функции, поэтому часто в Waves приходится разбивать логику децентрализованного приложения на несколько функций и последовательно вызывать их с помощью нескольких `InvokeScript` транзакций. Например, одно из самых сложных приложений в сети Waves - стейблкоин [Neutrino](https://neutrino.at) состоит из 5 контрактов.

Контракты не могут напрямую вызывать друг друга (как в Ethereum), но они могут общаться друг с другом благодаря сохранению данных и промежуточных состояний в key-value хранилища. Любой контракт может читать хранилище любого другого контракта или аккаунта, поэтому логика обработки сложных вычислений часто представляет из себя следующее:

1. Функция 1 децентрализованного приложения A вызывается с помощью `InvokeScript` транзакции, результат выполнения записывается в хранилище аккаунта A.
2. Функция 1 децентрализованного приложения B, вызванная с помощью `InvokeScript` транзакции, читает данные, записыванные в хранилище приложения А и использует для вычисления своего результата.

Возможность чтения состояния хранилища другого аккаунта в Waves является мощнейшим инструментом, позволяющим композировать логику, строить приложения, которые опираются на другие, уже существующие.

## Особенности обработки UTX

В разделе 5 мы разбирали как именно происходит сортировка транзакций в UTX пуле, однако в тот момент мы опустили некоторые детали. Сейчас, когда вы знакомы с концепцией сложности скрипта, давайте разберемся во всех деталях.

Как мы уже говорили, сортировка транзакций в очереди на попадание в блок происходит по размеру комисси на 1 байт транзакции, однако есть и второй параметр, который необходимо учитывать - сложность исполнения скрипта. Задача майнера в том, чтобы максимизировать прибыль, получаемую с комиссий, поэтому майнеру может быть не выгодно валидировать транзакции со скриптом и тратить на них драгоценное время, когда можно положить в блок много транзакций без скрипта, просто проверив подпись. В данный момент `complexity` никак не учитывается при сортировке транзакций в UTX, однако, в дальнейшем такой параметр обязательно должен появиться.

В блокчейне Waves есть несколько параметров, которые ограничивают размеры блока, то есть, косвенно ограничивают максимальную пропускную способность:

- до 1 мегабайта транзакций в блоке (около 6000 транзакций)
- ограничение на максимальную суммарную сложность скриптов в блоке равна 1 000 000 (не более 250 транзакций вызова скрипта с максимальной сложностью). При достижении этого лимита в блок будут укладываться только транзакции, не связанные с исполнением скриптов, и ровно до тех пор, пока не будет достигнут лимит по размеру в 1 мегабайт.

Важно понимать, что эти параметры могут быть пересмотрены в будущем, если это будет необходимо для обслуживания всех пользователей. Однако это приведет к возрастанию системных требований к нодам.

## Транзакции с ошибками

Выполнение скриптов при отправке транзакций (смарт-ассета, смарт-аккаунта или децентрализованного приложения), может быть как успешным, так и завершаться ошибкой. В случае завершения скрипта ошибкой или результатом `false` для смарт-аккаунтов и смарт-ассетов возможны сценарии, когда транзакция попадает в блокчейн и комиссия списывается с отправителя, но возможны и обратные ситуации. Давайте разберемся в особенностях транзакций с ошибками.

Скрипты децентрализованных приложений и смарт-ассетов не исполняются в момент добавления в UTX, а выполняются только в момент добавления в блок. Поэтому такие скрипты, завершающиеся исключением, попадут в блокчейн, если они успешно попали в UTX. Другими словами, транзакция не будет успешно завершена, но отправитель все равно заплатит комиссию. В API ноды Waves есть специальный метод POST `/debug/validate`, который помогает предварительно помогает проверить транзакции, чтобы минимизировать потенциальные финансовые потери.

Таким образом, добавление транзакции в блокчейн не гарантирует, что она исполнилась до конца и выполнила какие-либо действия. Проверить статус вызова скрипта можно с помощью REST API ноды, который при запросе транзакции по ID возвращает поле `applicationStatus`.

Скрипты, исполняемые для смарт-аккаунтов и функции `@Verifier` работают по-другому - они валидируются в момент добавления в UTX, и даже если в момент добавления в блок они вернули ошибку, транзакция не попадет в блок и комиссия не будет уплачена отправителем.

## Количество исполняемых скриптов

Многие разработчики приложения на Waves не до конца понимают какую нагрузку на блокчейн могут создавать их приложения. Давайте посчитаем, сколько может выполняться скриптов при отправке одной `InvokeScript` транзакции (в том порядке, как это на самом деле происходит):

- Скрипты ассетов, которые прикреплены как `payment` к вызову - до 2
- Скрипт самого децентрализованного приложения - 1
- Скрипт на аккаунте, который вызывает функцию приложения - 1
- Скрипты ассетов, которые переводятся как результат вызова функции приложения - до 10

> Получается, один вызов функции приложения может приводить к исполнению 14 скриптов, у каждой из которых может быть сложность 4000 единиц.

Похожая ситуация и при отправке `Exchange` транзакции, где может исполняться 2 скрипта аккаунтов отправителей ордеров, 2 скрипта ассетов, 2 скрипта ассетов в комиссии, 1 скрипт на аккаунте матчера, итого до 7 скриптов.
