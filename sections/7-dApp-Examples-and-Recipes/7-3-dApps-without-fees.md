# How to: бесплатные (для пользователя) децентрализованные приложения

**Дисклеймер: данная возможность является НЕ документированной и будет заменена на [WEP 2: Customizable Sponsorship](https://forum.wavesplatform.com/t/wep-2-customizable-sponsorship/15880). Но знать данный метод может не помешать.**

## Оплата комиссии за счет dApp

Этот вариант спонсирования подходит только для одного типа транзакций - `InvokeScript` и представляет собой достаточно простой механизм. Преимуществом по сравнению со спонсированием является отсутствие необходимости использовать свой токен.

Любой пользователь может вызвать dApp имея 0 Waves на своем аккаунте, но указав в качестве комиссии именно Waves. Скрипт начнет выполняться и, если в результата выполнения скрипта на аккаунт пользователя перечисляются Waves, то он получит их и уже оттуда спишется комиссия. Давайте на примере, так всегда ведь проще.

Например, есть dApp, который на основе адреса вызывающего отправляет или нет ему 1 Waves. **Данный пример совершенно не безопасен и приводится только для объяснения принципа работа. Ни в коем случае не используйте такую логику в своих децентрализованных приложениях.**

```scala
@Callable(invoke)
func callMeBaby() = {

    let callerAddress = invoke.caller.bytes.toBase58String()

    if (takeRight(invoke.caller.bytes, 4) == base16'ABCD') then
        TransferSet([
            ScriptTransfer(invoke.caller, 100000000, unit)
        ])
    else
    throw("You didn't win")
}
```

Если вызывать эту функцию с аккаунта, на котором 0 Waves баланса, указав `fee` в 0.005 Waves, скрипт все равно начнет выполняться. Если пользователь имеет право на получение 1 Waves, то транзакция будет считаться валидной и попадет в блокчейн. Пользователь СНАЧАЛА получит 1 Waves в результате вызова, затем с него будет списано 0.005 комиссии.
По итогу пользователь получит на своем аккаунте 0.995 Waves.

Внимательные читатели уже догадались, что скрипт выше является небезопасным, потому что можно вызывать его бесконечное количество раз - если аккаунт не выиграл, то транзакция не попадет в блокчейн, если аккаунт выиграл, то получит 0.995 Waves. Беспроигрышная лотерея получилась.

Правильный рецепт заключается в том, чтобы всегда проверять дополнительные условия имеет ли пользователь права вызывать скрипт, например, иметь свой белый список.

```scala
@Callable(invoke)
func callMeBaby(uuid: String) = {

    if (isInWhiteList(invoke.caller) && invoke.fee == 500000) then {

        let id = extract(invoke.transactionId)
        let callerAddress = toBase58String(invoke.caller.bytes)

        ScriptResult(
            WriteSet([
                DataEntry(toBase58String(id), callerAddress + uuid)
            ]),
            TransferSet([
                ScriptTransfer(addressFromStringValue(callerAddress), invoke.fee, unit)
            ])
        )
    }
    else
        throw()
}
```

Хочется дополнительно отметить, что если в будущем модель исполнения контрактов в Waves изменится и транзакции с ошибками (`throw()`) тоже будут записываться в блокчейн и снимать комиссию, то использование этого функционала станет невозможным.

Обсуждение того, как работает описанный выше функционал и о возможных путях развития вы можете найти в этом [issue на гитхаб](https://github.com/wavesplatform/Waves/issues/2725).

## Лучшие практики

Оба решения рекомендуется использовать только для триальных режимов продуктов и проверять все граничные условия, потому что неправильное использовать может привести к потере средств.
