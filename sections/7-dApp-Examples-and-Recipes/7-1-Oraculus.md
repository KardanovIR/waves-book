# Oraculus

Лучший способ выучить язык - начать на нем писать. Заставить вас писать я не могу, поэтому предложу вам второй по крутизне вариант - читать как пишется код! Мы разберем несколько примеров контрактов, начнем с относительно простых, и закончим на достаточно сложных и разухабистых. Первым контрактом, который будем писать является контракт Oraculus, его идея очень проста - сделать децентрализованных оракулов.

## Блокчейн и данные из реального мира

Блокчейн отлично работает с данными внутри себя, но не имеет никакого представления о том, что проиходжит за границами его консенсуса, а ведь там вся жизнь. Блокчейн не может сходить во внешний API и получить данные оттуда, потому что должна быть детерменированность операций. Если каждая нода будет ходить во внешний API в разное время, то какая-то может получить один результат, вторая - другой, третья - вообще получить ошибку, в итоге ноды блокчейна никогда не придут к консенсусу, ведь нельзя понять, какой ноде надо довериться. Чтобы решить эту проблему, вместо модели pull (когда ноды ходят за данными в реальный мир) принято применять модель push, когда есть какие-то поставщики данных, которые сохраняют данные в блокчейне, а дальше любые децентрализованные приложения в блокчейне используют эти данные. Сущности, которые сохраняют данные в блокчейне называются оракулами. Но с оракулами есть одна проблема - они централизованные, то есть мы доверяем одной сущности, которая поставляет нам какие-то данные. В общем случае, система является настолько централизованной, насколько централизованна самая "плохая" часть. То есть, децентрализованное приложение, которое использует для принятие критичных решений одного оракула на самом деле является централизованным приложением. Почему? Логика простая - повлияв на поведение одной сущности (оракула) можно добиться нужного поведения от такого приложения.

> Если децентрализованное приложение опирается на одного оракула, то такое приложение не является децентрализованным.

Идея сделать децентрализованных оракулов лежит на поверхности, но простого решения у этой проблемы нет, поэтому ее часто называют "проблемой оракулов". Давайте рассмотрим, что можно с этим сделать.

Самым простым решением является мультиподпись, когда нескольько разных пользователей должны придти к консенсусу и подписать одни и те же данные. Например, мы хотим получать данные о курсе USD/EUR и у нас есть 5 оракулов, которые должны договориться о цене (каким-то образом за пределами блокчейна), подписать транзакцию и отправить ее в сеть на специальный аккаунт, который примет эту транзакцию только при наличии не менее 3 подписей из 5. Простейший контракт для такого случая выглядел бы так:

```scala
{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# array of 5 public keys
let pks = [base58'', base58'', base58'', base58'', base58'']

# inner fold step for each signature
func signedBy(pk:ByteVector) = {
   # is signed by the public key or not
   func f(acc: Boolean, sig: ByteVector)
      = acc || sigVerify(tx.bodyBytes, sig, pk)
   FOLD<5>(tx.proofs, false, f)
}

# outer fold step for each public key
func signedFoldStep(acc:Int, pk:ByteVector)
   = acc + (if(signedBy(pk)) then 1 else 0)

# comparing total number of correct signatures
# to required number of correct signatures
FOLD<5>(pks, 0, signedFoldStep) >= 3
```

У такого решения вопроса есть несколько проблем:

- В случае отсутствия консенсуса у оракулов, данные просто не будут поставлены в блокчейн
- Отсутствует экономическая мотивация у поставщиков данных
- Заранее ограниченный список оракулов

