# Смарт ассеты и причем тут горячая картошка

Смарт-ассеты являются крайне мощным инструментом, которые при правильном использовании могут позволить быстро и просто реализовать ограничения по работе с токеном. Давайте разработаем токен-игру, которая называется "горячая картошка".

## Что за картошка и почему горячая?

Возможно, вы слышали про игру [горячая картошка](https://en.wikipedia.org/wiki/Hot_potato), которая возникла аж в 1888 году, но если вдруг не слышали, коротко объясню правила. Участники игры собираются в небольшой круг и бросают друг другу маленький предмет, параллельно с этим играет какая-либо музыка. В какой-то момент музыка прекращает играть и игрок, держащий предмет в этот момент, выбывает из игры. В следующем раунде все начинается заново, пока не останется только 1 игрок.

## HotPotatoToken

Давайте реализуем токен с похожей механикой:

- Когда пользователь получает токен, у него есть 5000 минут, чтобы передать его кому-то еще. По истечении этого периода, токен все еще может быть отправлен кому-то, но только если комиссия за транзакцию будет больше 1 Waves. Или токен может быть сожжен, но в виде комиссии придется заплатить уже 5 Waves.
- Так как генерация нового аккаунта не стоит ничего, то давайте добавим условие, что отправить "горячую картошку" можно только на аккаунт, у которого больше 10 Waves на балансе
- У пользователя одновременно может быть только одна горячая картошка
- Все перечисленные выше ограничения не касаются аккаунта, который выпустил токен

Давайте объявим основные переменные нашего скрипта. В отличие от смарт-аккаунта, который можно реализовать с помощью функции `@Verifier`, у смарт-ассета код должен быть в виде `EXPRESSION`:

```scala

{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ASSET #-}

# на аккаунте, получающем горячую картошку, не может быть меньше этой суммы
let minimumWavesBalance = 10_00_000_000

# Количество миллисекунд, в течение которых минимальная комиссия будет стандартной (0.005 Waves с обычного аккаунта)
let moveTimeInMs = 5000 * 60 * 1000

# Комиссия для отправки по истечению moveTimeInMs
let minimalFeeToMove = 1_00_000_000

# Комиссия для сожжения токена
let minimalFeeToBurn = 5_00_000_000
```

Возможно, вы обратили внимание на знак нижнего подчеркивания в числах `_`, который поддерживается в Ride для упрощения чтения. Восемь нолей отделены от остальных цифр, так как Waves имеет 8 знаков после запятой и так легче сразу увидеть количество целых токенов Waves.

В глобальной области видимости доступна переменная `tx`, которая хранит информацию о текущей обрабатываемой транзакции. Так как `tx` является `Union` от всех возможных типов транзакций, то нам в коде необходимо использовать pattern matching. У нас будут разные условия для `Tranfer`, `Burn` и всех остальных типов транзакций.

```scala
match (tx) {
    # временно оставим проверку Tranfer транзакций в таком виде
    case t:TransferTransaction => {
        false
    }
    # Мы позволяем сжигать только если комиссия больше 5 Waves
    # или отправителем является аккаунт, выпустивший токен
    case b: BurnTransaction => {
        if (b.fee >= minimalFeeToBurn || tx.senderPublicKey == this.issuerPublicKey) then true
        else {
            throw("You have to pay 5 WAVES to burn this token")
        }
    }
    # все другие типы транзаций разрешены для создателя токены и запрещены для всех остальных
    case _ => if tx.senderPublicKey == this.issuerPublicKey then true else throw("You only can transfer this token")
  }
```

В коде выше мы реализовали проверку, что если транзакцией, выполняемой с токеном, явлется `Burn`, то должно выполняться одно из условий - отправителем является аккаунт, выпустиший этот токен или комиссия больше минимального значения для сжигания (в нашем случае 5 Waves). Мы использовали ключевое слово `this`, которое в контексте смарт-ассета обозначает тип `Asset` и содержит информацию о текущем токене.

> Обратите внимание, при проверке отправителя транзакции мы проверяем только совпадение публичных ключей и не проверяем, что предоставлена правильная подпись от заданного публичного ключа, так как **массив `proofs` недоступен в скрипте смарт-ассета**. Проверка подписей является прерогативой аккаунта, а не ассета.

В скрипте выше мы запретили все `Transfer` транзации, но логика "горячей картошки" подразумевает, что мы должны их разрешать, если токен был получен менее 5000 минут назад или комиссия выше 1 Waves.

Прежде чем мы начнем писать код, необходимо понять как мы будем проверять факт получения токена менее 5000 минут назад. К сожалению, в Ride нет функции, которая позволила бы нам найти момент получения токена. Более того, в Ride практически нет никаких функций, которые позволяют смотреть в историю транзакций. Мы могли бы требовать предоставлять в массиве `proofs` id транзакции получения картошки, ведь как вы помните, в `proofs` можно передавать до 8 аргументов, но `proofs` недоступен в коде смарт-ассета.

Решением будет требовать предоставлять id транзакции получения картошки в качестве `attachment` к `Tranfer` транзакции.

```scala
match (tx) {
    case t:TransferTransaction => {

        # Если отправителем токена является аккаунт, выпустивший его, то проверки не нужны
        if (this.issuerPublicKey == t.senderPublicKey) then true
        else {
            # для вычисления сколько времени прошло с момента получения токена
            # в attachment должен быть указан id транзакции получения
            let txId = t.attachment

            # получаем баланс по токену HotPotato, чтобы проверить, что у получателя уже нет "горячей картошки"
            let currentRecipientHasPotato = assetBalance(t.recipient, t.assetId) > 0

            # получаем баланс токенов Waves, чтобы убедиться, что на аккаунте получателя не меньше 10 Waves
            let currentRecipientWavesBalance = wavesBalance(t.recipient)

            # Если у получателя уже есть горячая картошка, то выкидываем исключение
            if (currentRecipientHasPotato) then throw("The recipient already has a hot potator")
            # Если у пользователя меньше 10 Waves, то выкидываем исключение
            else if (currentRecipientWavesBalance < minimumWavesBalance) then throw("Recipient is too poor") else {

                # Получаем информацию о транзакции, с которой текущий отправитель получил свою картошку
                let transaction = transferTransactionById(t.assetId.value()).valueOrErrorMessage("Can't find incoming transaction")

                # Получаем номер блока, в котором текущий отправитель получил свою картошку
                let receivedBlockNumber = transactionHeightById(transaction.id).valueOrErrorMessage("Can't find incoming tx block number")

                # Получаем всю информацию о блоке, в которой текущий отправитель получил свою картошку
                let receivedBlockTimestamp = blockInfoByHeight(receivedBlockNumber).value().timestamp

                # Проверяем, что пользователь получил свою горячую картошку меньше, чем 5000 минут назад
                let receivedAssetInLastNMs = (lastBlock.timestamp - receivedBlockTimestamp) <= moveTimeInMs && t.assetId == transaction.assetId

                # Проверяем, является ли комиссия больше 1 Waves
                let feeMore1Waves = t.fee >= minimalFeeToMove

                # Если транзакция получена больше 5000 блоков назад И комиссия меньше 1 Waves
                # Бросаем исключение
                # Иначе разрешаем транзакцию
                if (!receivedAssetInLastNMs && !feeMore1Waves) then {
                    throw("You got potato long time ago, now you have to pay 1 WAVES fee")
                } else {
                    true
                }
            }
        }
    case burn: BurnTransaction => {...}
    case _ => ...
  }
```

Мы реализовали весь необходимый функционал, используя несколько функций и переменные стандартной библиотеки:

- `transferTransactionById(txId: ByteVector)` позволяет получить информацию о `Transfer` транзакции по ее Id. Предвосхищая вопросы сразу скажу, что такой же функции для других типов транзакций не существует.
- `blockInfoByHeight(n: Int)` позволяет получить информацию о блоке по ее номеру
- `lastBlock` - содержит всю информацию о текущем (последнем) блоке

Смарт-ассеты могут иметь и гораздо более интересные и витиеватые механики и условия использования, однако пример горячей картошки в достаточной степени описывает какие могут быть типы ограничений и как можно использовать токены в своем приложении.

Одним из таких приложений, использующих мощь смарт-ассетов, является проект [Tokenomica](https://tokenomica.com/), который позволяет выпускать токенизированные ценные бумаги и инвестировать в них.
