# Лучшие практики разработки

Как вы могли уже заметить, разработка децентрализованных Web3 приложений может быть местами нетривиальным занятием, которое отличается от обычной разработки приложений во многих аспектах:

- **Цена ошибки**. Ошибка в децентрализованных приложениях часто может приводить к потере средств, иногда потере средств пользователей
- **Открытость кода**. Даже если вы не хотите, чтобы ваш код был доступен другим пользователям и разработчикам, он будет лежать в блокчейне и всегда остается возможность его декомпилировать (в Waves, например, это делается крайне просто даже в обозревателе блокчейна)
- **Большое количество взаимосвязанных элементов**. Одни децентрализованные приложения могут опираться на логику других
- **Возможные обновления протокола**. Например, обновление протокола Waves до 1.2 и активация feature 14 (в случае его принятия в mainnet), полностью меняют логику работы с транзакциями вызовов скриптов. Фактически, у приложения может меняться окружение. Сложно такое представить в обычной разработке.

Давайте разберемся, какие ошибки чаще всего допускают разработчики и что надо делать, чтобы их избежать.

## Всегда проверяйте подпись

Одна из самых распространенных ошибок разработчиков - использовать в скриптах смарт-аккаунтов или функции `@Verifier` децентрализованных приложений конструкцию проверки `case _ => true`. Например, можно подумать, что следующий скрипт запрещает только `Transfer` транзакции и разрешает все остальные:

```scala
{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

match (tx) {
    case t:TransferTransaction => false
    case _ => true
}
```

Но дьявол кроется в деталях. Такой скрипт полностью запрещает делать с аккаунта `Transfer` транзакции и резраешает все остальные виды транзакций **любому пользователю**. Любой человек или даже просто скрипт сможет сделать транзакцию с этого аккаунта, указав в поле `senderPublicKey` транзакции публичный ключ аккаунта и **не указав ни одной подписи.**

**Всегда проверяйте** наличие подписи и ее корректность:

```scala
{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE EXPRESSION #-}
{-# SCRIPT_TYPE ACCOUNT #-}

match (tx) {
    case t:TransferTransaction => false
    case _ => sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublikey)
}
```

Быть внимательным надо не только в mainnet, но и в testnet, потому что и там и там есть есть скрипты, которые смотрят все транзакции в блокчейне и если находят аккаунты с такой уязвимостью, выводят все токены с аккаунта.

## Понимайте разницу между @Verifier и @Callable

Некоторые разработчики децентрализованных приложений допускают ошибку при проектировании своего dApp, ошибочно погалая, что `@Verifier` проверяет **входящие** транзакции на адрес dApp. Например, встречаются такие скрипты:

```scala
@Callable(i)
func foo() = {
    [StringEntry("foo", "bar")]
}

@Verifier(tx)
func verify = {
    match (tx){
        case i: InvokeScriptTransaction => true
        case _ => false
    }
}
```

Но такой скрипт занимается не тем, что разрешает вызывать методы данного dApp, а **разрешает вызывать с аккаунта этого децентрализованного приложения вызывать другие dApp даже без предоставления подписи.** То есть, любой пользователь сможет вызвать другой аккаунт и передать туда все токены с аккаунта этого приложения. Не надо забывать, что аккаунт децентрализованного приложения остается аккаунтом, который тоже может делать какие-то действия и отправлять транзакции и эти действия контролируются функцией `@Verifier`.

## Проверяйте транзакции перед отправкой

Транзакции вызовов скрипта могут завершаться ошибкой, но раньше такие транзакции просто не попадали в блокчейн, с выходом Waves 1.2 (на момент написания этих строк пока только в stagenet) эта ситуация изменилась. Теперь `InvokeScript` транзакции и транзакции, связанные с использованием смарт-ассетов, попадают в блокчейн даже если возвращают ошибку, и пользователь платит за них комиссию.

Убедиться на 146%, что транзакция успешно выполнится полностью и попадет в блокчейн невозможно, так как состояние блокчейна меняется достаточно быстро, новые транзакции появляются в UTX, попадают в блоки и могут менять ветку, по которой пойдет скрипт. Максимизировать вероятность, что транзакция успешно выполнится можно с помощью предварительной валидации. В REST API ноды есть метод [`debug/validate`](https://nodes.wavesplatform.com/api-docs/index.html#/debug/validate), который принимает транзакцию и валидирует ее. Метод возвращает какой был бы результат выполнения скрипта транзакции, если бы она добавлялась в блок прямо сейчас.

Используйте этот метод для предварительной валидации, прежде чем отправить транзакцию с помощью метода `broadcast`.

> Важно: данный метод API требует ключ, который невозможно получить для публичных нод, поэтому используйте ноду, чей API Key вы знаете.

## Будьте внимательны с ключами

В разработке децентрализованных приложений много операций совершается с key-value хранилищем аккаунта. Ключи в хранилище часто являются композитными, например, `voting_12_vote_3MEEsWQtsS5WV2SczdEvipY3Ch5LuSHuLWa`, который может хранить голос аккаунта `3MEEsWQtsS5WV2SczdEvipY3Ch5LuSHuLWa` в голосовании с `id=12`. Формирование ключа для такой записи в хранилище может быть реализовано в Ride следующим образом:

```scala
func keyVoteByAddress(votingId: Int, address: String) = "voting_" + votingId + "_vote_" + address
```

Часто встречается ошибка, что в формировании ключа допускают ошибку: записывают в один ключ, а пытаются читать из другого ключа. Например, забаывают символ `_` в одном из мест. Чтобы избежать такой ошибки, всегда используйте отдельные функции для формирования ключа, вместо любимого нами разработчиками поведения "копировать&вставить". Ну и, конечно, пишите тесты для ваших приложений.

## Используйте значения по умолчанию

Другой распространенной ошибкой, связанной в том числе с ключами в хранилще, является попытка чтения значений из переменных с типом `Union(T|Unit)` с помощью `value()` или `extract()` в тех местах, где можно было бы использовать значения по умолчанию. Например, если функция пытается прочитать голос пользователя из хранилища, но может быть ситуация, что голоса пока нет, используйте функцию `valueOrElse` или pattern matching:

```scala

let NONE = "NONE"

func keyVoteByAddress(votingId: Int, address: String) = "voting_" + votingId + "_vote_" + address


@Callable(i)
func vote(id: Int) => {
    let voteKey = keyVoteByAddress(id, i.caller.toBase58String())
    let vote = getString(this, voteKey).valueOrElse(NONE)

    # альтернативный вариант

    let vote = match getString(this, voteKey){
        case s: String => s
        case _ => NONE
    }

    if (vote == NONE) then ...
    else ...
}
```

Стоит так же учитывать, что функции вашего приложения могут вызываться не только из вашего пользовательского интерфейса, но кем угодно и как угодно, поэтому значения по умолчанию могут помочь и им.

## Держите под контролем ваши транзакции

В работе реальных децентрализованных приложений относительно часто встречаются случаи, когда необходимо выполнять несколько зависимых транзакций последовательно. Например, если вы используете схему [коммит-раскрытие](https://en.wikipedia.org/wiki/Commitment_scheme), то фаза раскрытия может быть только после фазы коммита. Если вы отправите транзакцию раскрытия до того, как транзакция коммита попадет в блокчейн, то ваш скрипт вернет ошибку, пользователь заплатит комиссию и не получит ожидаемый результат.

В блокчейне Waves могут быть редкие ситуации, когда происходит форк в блокчейне и последний блок или микроблок откатывается, что может вести к нарушению последовательности зависимых транзакций. Например, если отправить транзакцию для фазы коммита, дождаться пока она попадет в последний (жидкий) блок и сразу же отправить транзакцию раскрытия, то может быть ситуация, когда последний блок или микроблок откатится, транзакция коммита "выпадет" из блокчейна. Это приведет к тому, что транзакция для фазы раскрытия станет невалидной.

Если вы используете функцию `waitForTx` из библиотеки `waves-transactions`, то она ожидает только попадания в последний жидкий блок, что может приводить к проблемам. Если у вас есть зависимые транзакции, то более безопасным способом использование функции `waitForTxWithNConfirmations` с ожиданием 1-2 подтверждений после попадания первой транзакции в блок.
