# Oraculus

Лучший способ выучить язык - начать на нем писать. Заставить вас писать я не могу, поэтому предложу вам второй по крутизне вариант - читать как пишется код! Мы разберем несколько примеров контрактов, начнем с относительно простых, и закончим на достаточно сложных и разухабистых. Первым контрактом, который будем писать является контракт Oraculus, его идея очень проста - сделать децентрализованных оракулов.

## Блокчейн и данные из реального мира

Блокчейн отлично работает с данными внутри себя, но не имеет никакого представления о том, что проиходжит за границами его консенсуса, а ведь там вся жизнь. Блокчейн не может сходить во внешний API и получить данные оттуда, потому что должна быть детерменированность операций. Если каждая нода будет ходить во внешний API в разное время, то какая-то может получить один результат, вторая - другой, третья - вообще получить ошибку, в итоге ноды блокчейна никогда не придут к консенсусу, ведь нельзя понять, какой ноде надо довериться. Чтобы решить эту проблему, вместо модели pull (когда ноды ходят за данными в реальный мир) принято применять модель push, когда есть какие-то поставщики данных, которые сохраняют данные в блокчейне, а дальше любые децентрализованные приложения в блокчейне используют эти данные. Сущности, которые сохраняют данные в блокчейне называются оракулами. Но с оракулами есть одна проблема - они централизованные, то есть мы доверяем одной сущности, которая поставляет нам какие-то данные. В общем случае, система является настолько централизованной, насколько централизованна самая "плохая" часть. То есть, децентрализованное приложение, которое использует для принятие критичных решений одного оракула на самом деле является централизованным приложением. Почему? Логика простая - повлияв на поведение одной сущности (оракула) можно добиться нужного поведения от такого приложения.

> Если децентрализованное приложение опирается на одного оракула, то такое приложение не является децентрализованным.

Идея сделать децентрализованных оракулов лежит на поверхности, но простого решения у этой проблемы нет, поэтому ее часто называют "проблемой оракулов". Давайте рассмотрим, что можно с этим сделать.

Самым простым решением является мультиподпись, когда нескольько разных пользователей должны придти к консенсусу и подписать одни и те же данные. Например, мы хотим получать данные о курсе USD/EUR и у нас есть 3 оракула, которые должны договориться о цене (каким-то образом за пределами блокчейна), подписать транзакцию и отправить ее в сеть на специальный аккаунт, который примет эту транзакцию только при наличии всех 3 подписей. Простейший контракт для такого случая выглядел бы так:

```scala
#define public keys

let oracle1PublicKey = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM'
let oracle2PublicKey = base58'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF'
let oracle3PublicKey = base58'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD'

#check whoever provided the valid proof
let oracle1Signed = if(sigVerify(tx.bodyBytes, tx.proofs[0], oracle1PublicKey )) then 1 else 0
let oracle2Signed = if(sigVerify(tx.bodyBytes, tx.proofs[1], oracle2PublicKey )) then 1 else 0
let oracle3Signed = if(sigVerify(tx.bodyBytes, tx.proofs[2], oracle3PublicKey )) then 1 else 0

#sum up every valid proof to get at least 2


aliceSigned + bobSigned + cooperSigned == 3

```