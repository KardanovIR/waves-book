<!DOCTYPE html>
<html>
<head>
<title>all-in-one.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<!-- <p>&nbsp;</p> -->
<!-- <p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p> -->
<!-- <p>&nbsp;</p> -->
<!-- <h1 align="center">Web3 приложения на Waves</h1>
<h3 align="center">пособие для начинающих</h3>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p> -->
<!-- <h5 align="center">Inal Kardanov<br>2020</h5> -->
<!-- </div> -->
<img src="./../../assets/A4_Cver_Waves_B.png" width='100%' height='100%'>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="table-of-contents">Table of Contents</h1>
<p><a href="../../sections/0-intro.md">Introdution</a></p>
<p><a href="../../sections/1-Waves-Introduction/1-0-intro-web3.md">Chapter 1. A Brief History of the Web, or Web 1.0 to Web 3.0</a></p>
<ul>
<li><a href="../../sections/1-Waves-Introduction/1-1-history-of-waves.md">1.1 What is Waves?</a></li>
<li><a href="../../sections/1-Waves-Introduction/1-2-development-principles.md">1.2 Development principles of the Waves protocol</a></li>
<li><a href="../../sections/1-Waves-Introduction/1-3-features-and-USPs.md">1.3 Distinctive features of the Waves blockchain</a></li>
</ul>
<p><a href="../../sections/2-Network-Features/2-1-node-configuration.md">Chapter 2. Waves node and how it works, its configuration</a></p>
<ul>
<li><a href="../../sections/2-Network-Features/2-2-mining-and-waves-ng.md">2.1 Mining process and Waves NG</a></li>
<li><a href="../../sections/2-Network-Features/2-3-upgrades-and-other-votings.md">2.2 Protocol updates and other polls</a></li>
</ul>
<p><a href="../../sections/3-Accounts/3-1-keys.md">Chapter 3. Accounts and Keys</a></p>
<ul>
<li><a href="../../sections/3-Accounts/3-2-accounts-vs-smart-accounts.md">3.1 Regular accounts vs. Smart accounts</a></li>
</ul>
<p><a href="../../sections/4-Tokens/4-1-tokens-and-how-to-work.md">Chapter 4. Tokens</a></p>
<ul>
<li><a href="../../sections/4-Tokens/4-2-sponsorship.md">4.1 Sponsoring transactions</a></li>
<li><a href="../../sections/4-Tokens/4-2-sponsorship.md">4.2 Smart assets</a></li>
<li><a href="../../sections/4-Tokens/4-3-smart-assets.md">4.3 Asset and DEX trading</a></li>
</ul>
<p><a href="../../sections/5-Transactions/5-1-transactions-intro.md">Chapter 5. Transactions</a></p>
<ul>
<li><a href="../../sections/5-Transactions/5-2-transaction-types.md">5.1 Transaction types</a></li>
<li><a href="../../sections/5-Transactions/5-3-utx.md">5.2 UTX processing features</a></li>
</ul>
<p><a href="../../sections/6-Ride/6-1-introduction.md">Chapter 6. The Ride Programming Language</a></p>
<ul>
<li><a href="../../sections/6-Ride/6-2-runtime-details.md">6.1 Language runtime</a></li>
<li><a href="../../sections/6-Ride/6-3-main-functions.md">6.2 Standard library</a></li>
<li><a href="../../sections/6-Ride/6-4-tooling.md">6.3 Tools for developing decentralized applications</a></li>
</ul>
<p><a href="../../sections/7-dApp-Examples-and-Recipes/7-1-Oraculus.md">Chapter 7. Workshop: Writing Web3 Applications</a></p>
<ul>
<li><a href="../../sections/7-dApp-Examples-and-Recipes/7-1-Oraculus.md">7.1 Oraculus</a></li>
<li><a href="../../sections/7-dApp-Examples-and-Recipes/7-2-Billy.md">7.2 Billy</a></li>
<li><a href="../../sections/7-dApp-Examples-and-Recipes/7-3-hot-potato-token.md">7.3 Smart assets and where does the hot potato come in?</a></li>
<li><a href="../../sections/7-dApp-Examples-and-Recipes/7-5-best-practices.md">7.4 Development best practices</a></li>
<li><a href="../../sections/7-dApp-Examples-and-Recipes/7-6-5-things-to-know.md">7.6 5 things I would like to know before I started developing decentralized apps</a></li>
</ul>
<p><a href="../../sections/8-important-aspects/8-0-important-aspects.md">Chapter 8. Developer's best friends</a></p>
<ul>
<li><a href="../../sections/8-important-aspects/8-1-keeper-singer.md">8.1 User interactions</a></li>
</ul>
<p><a href="../../sections/9-next-big-things/9-0-defi.md">Chapter 9. Looking to the future</a></p>
<ul>
<li><a href="../../sections/9-next-big-things/9-1-gravity-hub.md">9.1 Gravity</a></li>
</ul>
<p><a href="../../sections/10-outro.md">Final words</a></p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="introduction">Introduction</h1>
<p>This book can help you make your first Web3 application on the Waves blockchain as quickly as possible, avoiding fatal mistakes. This book focuses on examples, analysis of real cases, specific recipes that you can apply in your applications. But as with many aspects of life, getting to real-world tasks requires fundamental knowledge of the protocol. Therefore, the first three chapters talk about the specifics of Web3 and the Waves blockchain, how it differs from other blockchains, along with a discussion of &quot;what&quot; and &quot;how&quot; can affect the architecture of your application and what limitations there may be. The book focuses on the specifics of working with Web3 applications on Waves, but not on basic concepts like &quot;what is blockchain?&quot; and &quot;how does the consensus algorithm work?&quot;, since there is a huge amount of materials on how the blockchain works, while finding the features of individual protocols, examples and recipes is quite problematic.</p>
<p>It is important to understand that the book is also not a &quot;complete guide&quot; to Waves, as it focuses on the applied aspects of the protocol. It does not try to compete with the <a href="https://docs.wavesplatform.com">protocol documentation</a>, which has been around for a long time and covers many aspects of working with Waves.</p>
<p>After reading this book, you will be able to write smart contracts in the Ride language, understand the features of the Waves platform, and make your first decentralized Web 3 application.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-1-a-brief-history-of-the-web-or-web-10-to-web-30">Chapter 1. A Brief History of the Web, or Web 1.0 to Web 3.0</h1>
<p>You are holding a book on Web3 in your hands, but perhaps you first want to know what Web3 is, how it differs from Web2, and what does Waves have to do with it. In this chapter, we will look at all of these issues.
You've probably heard that the Internet, as a signal transmission technology, appeared more than 50 years ago, or to be more precise, on September 2, 1969. It was on this day that 2 computers transmitted data to each other for the first time. But the world wide web, as we currently understand it, was invented by Sir Tim Berners Lee 20 years later, in 1989. In fact, he invented the Internet as we know it today, made up of millions of hypertext markup documents linked together by links. The Internet in 1989 was completely different, lacking social networks like Facebook, online shops like Amazon, or even search engines and memes sites.</p>
<p>The Internet was read-only back then. Sites were only at research centers, large universities and companies, and it was they who created all the content and distributed it in the form of static web pages, the only form of interaction with which was clicking on a link to another page. It was the wonderful world of Web 1.0.</p>
<p>** In other words, Web 1.0 is a read-only Internet for most of its users. **</p>
<p>As time went on and the speed of spread of technology only increased, in the 90s the Internet experienced a boom and the &quot;crash of dot-coms&quot;, but it was this crash that gave the opportunity to the next evolution of web pages on the Internet. These web pages were different in that they offered users the tools to interact with each other. One of the first such forms of interaction were forums, which have now almost disappeared into oblivion, but were once very popular. In addition to forums, other platforms began to appear with content from users, not just site owners (user generated content). The Internet became not only for reading, but also for creation and creation, pages became interactive, technologies allowed users to interact without page reloads (AJAX appeared). We still live in the Web 2.0 world.</p>
<p>** Web 2.0 - Internet with content from users and the ability to interact with other users **</p>
<p>But what exactly is Web 3.0? How to define it? You may be old enough to remember the idea of ​​the &quot;semantic web&quot;. Semantic Web - a family of standards that aimed at creating protocols for exchanging data on the Web. A couple of years ago, this was what was meant by Web 3.0, but now the vision of the future has changed.</p>
<p>The world wide web is becoming more complex, connected, and even smart. The number of users, the number and quality of their interactions are growing. The number of challenges and problems facing the World Wide Web is also growing, especially in connection with hacks, data leaks, manipulations, sales of personal information, etc. This is largely due to the history of the web, because from the very beginning there were practically no monetization models on the Internet other than advertising, which leads to user tracking. And the most natural form of development of Internet platforms has become monopolies, because the Internet has no borders, physical restrictions, so it is much easier to capture markets. One of the answers to these problems is ** decentralization **. The web of the future must be focused on security, privacy, and focus on the user, not the corporation. For this, Web 3.0 can use technologies such as Blockchain, but, obviously, there will be a lot of Artificial Intelligence, Big Data, VR / AR on the web of the future.</p>
<p>The transition to Web 3.0 is different from the transition from Web1.0 to Web2.0. Web 3.0 isn't about speed, performance or convenience, it's about ** power **. Users have power over their data, not corporations have power over users.</p>
<p>One of the pioneers of Web 3.0 and co-founder of the Ethereum blockchain platform Gavin Wood back in 2014 in his [blog post] (http://gavwood.com/dappsweb3.html) described Web 3.0 with the following words:</p>
<blockquote>
<p>“Rethinking things for which we already use the Web, but with a fundamentally different model of interaction between the parties. We publish information that we consider to be publicly available. We put the information that we want to negotiate in a distributed ledger. We keep information that is private and never disclose it. Communication always takes place over encrypted channels and only with aliases as endpoints; but never with tracked aliases (like IP addresses). In short, we are designing a system that ** mathematically ** enforces our assumptions about the availability of information, because no government or organization can be trusted. &quot;</p>
</blockquote>
<p>The mathematical compulsion to comply with our assumptions is the use of cryptography, and blockchain allows us to get rid of trust. In this book, we will practically not touch on the issues of cryptography, since we are more interested in the practical applicability of the ideas of Web3 and how we can start making web applications of the future today.</p>
<h2 id="what-is-web-30-made-of">What is Web 3.0 made of</h2>
<p>Web3 is now in its infancy, both in terms of the number of applications and the number of users of those applications. And that is why now is the time to start making applications that will help attract more users. At the same time, no one rules out the scenario that our current understanding of Web 3.0 will change in the future and the principles described in this book will become as irrelevant as the &quot;semantic web&quot; is not.</p>
<p>Let's take a look at what Web 3.0 currently consists of. The description of the layers of Web 3.0 technologies, which can be found on the [Web3 Foundation] website (https://web3.foundation/about/), will help us with this. At the moment, the Web3 stack describes everything related to the blockchain, without affecting other possible technologies. The stack consists of 5 layers, from level 0 to level 4.</p>
<p>Layer 0 is the backbone of the Web3 technology stack, which consists of how hosts interact and how they can be programmed at the lowest level. As part of this book, we will look at the Waves Blockchain and its node communication protocol. In many cases, level 0 is a black box for application developers that does not affect the user experience or development process in any way.</p>
<p>The next level is Level 1, which disseminates and interacts with data. The layer can also be referred to as the &quot;zero trust interworking protocol&quot;. Basically, it is a protocol that describes how different nodes on the blockchain network interact with each other, it allows them to exchange and verify each other. This layer mainly deals with data distribution protocols and temporary / intermediate messages. Level 1 is required for the blockchain itself to function properly. This level can affect the user experience, for example, in terms of delays in getting information into the blockchain, so it is important to understand how the system works at this level.</p>
<p>When developing Web3 applications, you will definitely work with Layer 2 protocols. It is a series of protocols that include many interesting technical solutions such as State Channels, Plasma Protocols, oracles, and so on. This layer extends the capabilities of Layer 1 to provide scalability, encrypted messaging, and distributed computing. In this book we will describe working with oracles. Oracles are a way to get data from the real world within the blockchain system (for example, weather or stock prices). Web3 applications are very often tied to data that is outside the blockchain, so working with such data and oracles is extremely important. Chapter 7 will take a closer look at the oracle problem.</p>
<p>Level 3 focuses on programming languages ​​and libraries that allow developers to create programs at the proper level of abstraction, without unnecessary low-level details. This layer is also known as &quot;extensible protocols, APIs, and developer languages&quot;. There are many languages ​​that can be used to develop applications without using real bytecode, such as Solidity for Ethereum, Plutus for Cardano, and Ride for Waves. In addition, there are many platforms and libraries that facilitate the development of blockchain interoperable applications. We will be using Ride and the Waves Blockchain JavaScript library. There are many libraries for different languages, for PHP, Java, Python, Kotlin, Swift and many others, but we will only cover the JavaScript / Typescript library.</p>
<p>Finally, we move on to the top level of the stack, level 4, which is the UI level. It contains technologies that allow the average user, non-developer, to interact with Web3 applications. Some common browsers (like Opera) allow users to interact directly with blockchains, but some of the most popular browsers: Chrome, Firefox and Microsoft Edge require additional tools from users, the most common tool being browser extensions. In Chapter 8 we'll look at an example of such a browser extension and see how to work with it.</p>
<p>The general layout of the Web3 stack looks like this:</p>
<p><img src="../../assets/1-0-1-1-web3-stack.png" alt="Web3 Stack" title="Web3 Stack"></p>
<h2 id="waves-technology-stack">Waves technology stack</h2>
<p>In this book, we will look at all layers of the Web3 stack using the Waves protocol as an example.</p>
<p><img src="../../assets/1-0-1-2-waves-web3-stack.png" alt="Waves Web3 Stack" title="Waves Web3 Stack"></p>
<p>We will start our examination with the most basic layers, then we will talk about the Ride programming language, development tools, oracles and ways of interacting with the user. In the course of considering technologies, we will also talk about philosophy and the reasons for certain technical solutions.</p>
<h1 id="11-history-of-waves">1.1 History of Waves</h1>
<h2 id="what-is-waves">What is Waves?</h2>
<p>Waves is a Proof-of-Stake permissionless, general-purpose blockchain platform created since 2016 to help mainstream blockchain technology. Waves blockchain platform is one of the most mature (both in terms of age and in view of the large number of projects) and easy for beginner developers who want to take advantage of blockchain to the maximum benefit. Within the framework of this book, we will analyze the main technical features, talk about the advantages and consider a lot of real code, but before we do this, let's talk a little about the history of Waves in order to better understand the origins of certain features.</p>
<h2 id="start-project">Start project</h2>
<p>Waves as a blockchain began in 2016, when the founder of the platform <a href="https://twitter.com/sasha35625">Alexander Ivanov</a> initiated a fundraising event as part of an ICO. From the very beginning, the platform has positioned itself as a general-purpose blockchain, without a focus on certain specific areas of application. The main task that the platform was going to solve (and in many ways successfully solved it) is throughput. At the beginning of 2016, there were very few blockchains that could process hundreds of transactions per second. In fact, only Bitcoin (and its forks like Litecoin) with 7 transactions per second and Ethereum with 15 transactions / sec fully worked on the market. So the problem of blockchain bandwidth was extremely urgent.</p>
<h3 id="major-milestones-in-the-development-of-the-project">Major milestones in the development of the project</h3>
<p>The successful fundraising for the ICO was only the beginning of the project, then it was necessary to implement everything promised as well as possible. Initially, the technological base of the <a href="https://github.com/ScorexFoundation/Scorex">Scorex</a> framework was chosen . Almost nothing is left of the framework itself in the project's code base, but Scorex is written in Scala, which determined the technological stack of the protocol development for a long time. Until recently, the implementation of a node (that is, a protocol) in Scala was the only one, only relatively recently there was also an implementation in Go. It is worth noting that at the time of this writing, the Go version was lagging behind the Scala version in terms of capabilities, we will talk about this in the following sections. The Waves mainnet (hereinafter referred to as mainnet) was launched in December 2016. The project had features from the very beginning: easy release of its tokens / assets (by sending one transaction) and PoS with a leasing (staking) model. We will analyze these features in further sections.</p>
<p>Other notable milestones in the history of the protocol include the following dates:</p>
<ul>
<li>Issue of DEX (hybrid exchange) in 2017. A logical continuation of the native support for the issuance of tokens using a transaction (not a contract as in Ethereum) was the release of the matcher, which ensured the operation of the decentralized exchange.</li>
<li>In the same year, the Waves NG protocol was implemented, which allowed us to achieve good throughput. Waves NG was implemented based on the ideas outlined in <a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">article</a>. These proposals were aimed at improving the Bitcoin protocol, but were never implemented there, but were implemented in Waves.</li>
<li>In the summer of 2018, the Ride smart contract language was released, which allowed changing account logics, and in January 2019, it became possible to write contracts for tokens</li>
<li>In the summer of 2019, Ride reached the mainnet for full-fledged decentralized applications (Ride4dApps)</li>
<li>In the fall of 2019, the first of its kind (among the main blockchain projects) monetary policy appeared</li>
</ul>
<h3 id="impact-of-waves-history-on-protocol">Impact of Waves history on protocol</h3>
<p>The history of the creation of Waves strongly influenced the technical details of the project. For example, the Scorex framework is rooted in the Nxt project, another Proof-of-Stake blockchain with native tokens. Both features were inherited by Waves from Nxt. The ease of creating tokens and the speed of the protocol later made the project the second most popular platform for issuing tokens and launching ICOs (right after Ethereum). A large number of projects on Waves have used the blockchain specifically for working with tokens. Since 2019, projects related to financial services have been actively developing, so we can say that the focus of Web3 projects on the platform is now the task of creating an open ecosystem of financial products.</p>
<h1 id="12-development-principles-of-the-waves-protocol">1.2 Development principles of the Waves protocol</h1>
<p>The developers of the Waves protocol have always been guided by some basic principles that strongly influence the further development of the protocol. Understanding these principles and the motivation behind them will make it easier to follow the further development of the project, so I will list these features.</p>
<h2 id="blockchain-for-people">Blockchain for people</h2>
<p>The Waves mantra has long been &quot;Blockchain for the people&quot;. It fully reflected and reflects what the team is doing. The main thing the platform wants to achieve is ** popularize blockchain technology for the masses **. At the moment, blockchain is a technology for a very small group of people who understand what this technology is and how to use it correctly. Waves wants to change this state of affairs and ensure that technology brings the maximum benefit to everyone.</p>
<p>Many people think that blockchain technology is extremely complex and knowledge-intensive (in many ways it is), while Waves tries to hide all the complexity behind a simple layer of abstraction. Blockchain is not the most user-friendly database, which has several important properties: decentralization, immutability and openness. These features are not values ​​in themselves, but only if applied correctly by developers of specific applications. Waves' goal is to provide the tools to developers that will enable them to deliver value to end users faster, easier, without too much technical immersion.</p>
<p>We can say that the principle of orientation towards real application breaks down into several steps:</p>
<ol>
<li>The platform provides application developers with an easy tool to use blockchain features</li>
<li>Application developers make products that solve user problems and use blockchain correctly</li>
<li>Users get the benefits of blockchain. At the same time, it is not necessary that users know anything about the blockchain. The main thing is to solve their problem.</li>
</ol>
<h2 id="focus-on-practical-applicability">Focus on practical applicability</h2>
<p>Always, during the development of a new functionality or product, ** practical applicability ** is at the forefront and how many people <strong>potentially</strong> will be able to solve their problems using this. The protocol developers try not to make &quot;spaceships&quot;, solve &quot;spherical problems in a vacuum&quot; or over-engineer, choosing the applicability &quot;here and now&quot;. It's better to have it working now than perfect in 10 years. Of course, this principle should not conflict with network security.</p>
<h2 id="openness-of-development">Openness of development</h2>
<p>The Waves protocol is completely open and the development process is as decentralized as possible. All source codes are available on <a href="https://github.com/wavesplatform">Github</a>. In addition to the source code itself, the development of the protocol, various problems and options for their solution are discussed there. Protocol updates related to consensus changes are always discussed with <a href="https://forum.wavesplatform.com/t/wep-0-waves-enhancement-proposal-unified-proposal-system/14781">Waves Enhancement Proposals</a> ... But the discussion is only the first stage, because all consensus updates must still go through the activation procedure with a vote, which we will talk about in the next section. Now you know what to do if you want to change or add something in the protocol.</p>
<h1 id="13-distinctive-features-of-the-waves-blockchain">1.3 Distinctive features of the Waves blockchain</h1>
<p>If you already have experience with other blockchains, you may be wondering how Waves differs from conditional Ethereum and why it is different. Let's quickly go over the differences, which will be explored in detail in the following sections.</p>
<h2 id="working-with-tokens--assets">Working with tokens / assets</h2>
<p>One of the features of working with Waves from day one was the ease of issuing tokens. To do this, just send a transaction or <a href="https://docs.waves.exchange/en/waves-exchange/waves-exchange-online-desktop/online-desktop-asset/online-desktop-token-creation">fill out a 5-field form</a> in any UI client.
The issued token automatically becomes available for transfers, trading on a decentralized exchange, dApp use and burning.</p>
<p>Unlike Ethereum, Waves tokens are not smart contracts, but are &quot;first-class citizens&quot;, that is, they are a separate full-fledged entity. This has both advantages and disadvantages, which we'll talk about in Section 4 Tokens.</p>
<h2 id="transactions">Transactions</h2>
<p>Another distinctive feature of Waves is the large number of transaction types. For example, Ethereum has smart contracts that can be anything, depending on their implementation. The ERC-20 describing the token is just a description of the smart contract interface - what methods it should have. Waves assumes that it is better to have lightweight/narrow specific things than abstract &quot;about everything and nothing&quot;. The specificity of the primitives makes development easier in many places, but this is sometimes a less flexible solution.</p>
<p>Below is a list of current transactions at the time of this writing:</p>
<p><img src="../../assets/5-1-1-transaction-types.png" alt="Waves transaction types" title="Waves Transaction Types"></p>
<p>In Chapter 5, &quot;Transactions,&quot; we'll go over each of them in detail.</p>
<h2 id="leasing">Leasing</h2>
<p>Waves has a staking mechanism called leasing. Any Waves token holder can lease tokens to any Waves node to produce blocks &quot;on behalf of those tokens.&quot;</p>
<blockquote>
<p>The lessor transfers the right to generate blocks on behalf of its tokens to the lessee (the owner of the node).</p>
</blockquote>
<p>This is usually done when the user does not want or cannot deal with the deployment of his node and its support. Typically, the owners pay lizngovyh pools used about most of the earned through leasing by the lessor. You can lease funds instantly, but they will start to be taken into account in the generating balance of the node only after 1000 blocks.</p>
<p>You can pick up tokens from leasing instantly.</p>
<h2 id="fair-pos">Fair PoS</h2>
<p>Waves uses the Proof-of-Stake algorithm to determine the right to generate a block. Blocks are generated on average every minute, and the probability of a block being generated by a node depends on 3 parameters:</p>
<ul>
<li>The generating balance of the node, that is, the balance of the node itself + the number of tokens that have been leased to it.</li>
<li>Current time and randomness (great random is always in life!)</li>
<li>Generating network balance, because not all tokens in the network participate in block generation, they can be in orders on exchanges or lie in cold wallets.</li>
</ul>
<p>To start generating blocks, it is enough to have 1000 Waves generating balance (own + leased). Why do you need to generate blocks? For each block, the node receives commissions from transactions in this block and a reward &quot;out of thin air&quot; on its balance sheet. Both of these points are not so simple, so we will look at them a little later.</p>
<p>A very common question that comes up - how many blocks will I generate per month with balance N? It is impossible to predict the exact number, as it depends on chances and changes in the network, but it is possible to predict approximately. To do this, you need to know the current network parameters:</p>
<ol>
<li><em>How many Waves tokens are involved in block generation?</em> This is the so-called generating balance of the network as a whole. For ease of calculation, let's say that 50 million tokens are involved in block generation.</li>
<li><em>What is the balance of our node?</em> That is, how many tokens we have on the node's account and how many we have been leased. In our case, let's take the generating balance equal to 10,000 Waves.</li>
<li>The average block time is 1 minute, that is, the network generates approximately 1440 blocks per day or 43,200 blocks per month.</li>
</ol>
<p>To calculate the approximate number of blocks that we will generate, divide the number of blocks for the period by the generating network balance and multiply by our balance:</p>
<p>$ ForgedBlocks = BlocksCountInPeriod / NetworkGenBalance * NodeGenBalance $</p>
<p>Having done some simple calculations, we get:</p>
<p><code>43200/50000000 * 10000 = 8.64</code></p>
<p>That is, on average, a node will generate 8-9 blocks per month if it works stably and the network parameters do not change, but, of course, this does not happen, because a large number of transactions are constantly being made on the network, which change generating balances of the entire network in as a whole and each node separately.</p>
<h2 id="community-driven-monetary-policy">Community driven monetary policy</h2>
<p>At first, Waves had a limited emission of 100 million tokens, which were issued immediately at the time the mainnet was launched, but since the fall of 2019, the community decided that for the further growth of the ecosystem, it would be better to include the emission of tokens in the protocol. That is, new Waves tokens appear in each new block. The exact number of tokens is determined by the community, which votes for the size of the reward every 100 thousand blocks. At the time of this writing, the block reward was 6 Waves. At the same time, it is guaranteed that the size of the reward cannot change by more than 0.5 Waves after each voting period.</p>
<h2 id="sponsorship">Sponsorship</h2>
<p>The token sponsorship feature is a way to reduce barriers to entry for users. The bottom line is that the account that issued the token can sponsor transactions with that token. Let's say there is token A, it was issued by Cooper and sponsored. For example, Alice has earned 100 A tokens and wants to send 10 of them to Bob. We know that for each transaction in the blockchain, you need to pay a commission, in the Waves network, miners accept only Waves in the form of a commission, and Alice does not have Waves. Have to go and buy Waves somehow?</p>
<p>No. Sponsoring a token allows its owner to say that he is ready to take on commissions for operations with this token (token A in our case). The owners of token A will pay the same token as a commission when sending a transaction. In our example, Alice will be able to indicate in her transaction that the recipient is Bob, the amount to be sent is 10 tokens A, the commission is 5 tokens A. As a result, 15 tokens will be debited from her account, 10 will receive Bob, 5 will receive Cooper as the issuer and the sponsoring token, and the miner will receive Waves from Cooper's account.</p>
<p>Why will Alice pay 5 tokens and how much will the miner receive? We'll talk about this in the next chapters. The main thing to remember now is <strong>there are ways to send a transaction in Waves without having Waves tokens on your balance sheet.</strong></p>
<h2 id="ride-and-smart-contracts">Ride and smart contracts</h2>
<p>Waves is a general purpose blockchain that does not specialize in one thing, so the emergence of smart contracts was a logical continuation of the platform's development. We'll talk about smart contracts in Waves in Chapter 6 &quot;Ride&quot;. Now it is worth noting that contracts are written in the Ride language, which was invented specifically for smart contracts and is not Turing complete. There are no cycles in the language, but there is no gas, there are no &quot;Out of gas&quot; errors like in Ethereum, and the cost of a transaction is always known in advance. Intrigued? This is just the beginning, we will talk about the Ride execution model and language syntax later.</p>
<h2 id="waves-ng">Waves NG</h2>
<p>Earlier, I already <a href="./1-1-history-of-waves.md">touched on the topic</a> related to Waves NG and mentioned that it allows transactions to get into blocks faster and work on the blockchain so quickly that the platform is able to process hundreds of transactions per second on the mainnet. And there, for a minute, there are more than 400 nodes distributed around the world, on completely different hardware and with different bandwidth.</p>
<p><img src="../../assets/1-3-2-nodes-on-the-map.png" alt="Waves nodes map" title="Waves nodes map"></p>
<h2 id="dex">DEX</h2>
<p>The easy and fast token issuance along with &quot;class equality&quot; (remember that tokens are first class citizens?) Make token trading easy. The Waves node (talking about the Scala version) supports the ability to create extensions, one of such extensions is the matcher. The matcher accepts orders to buy and sell tokens and stores them (centrally). For example, Alice wants to sell wBTC token and buy Waves, while Bob wants to do the opposite. They form orders (cryptographically signed primitives) and send them to the matcher, which determines that these orders are placed in one pair and that they can be matched at a certain price. As a result, the matcher forms an Exchange transaction that contains 2 orders (one from Alice, the other from Bob) and sends it to the blockchain. At the same time, the matcher takes a commission from users, and the node that will mine the block from the Exchange of transactions receives a commission from the matcher.</p>
<p><img src="../../assets/1-3-3-how-dex-works.png" alt="How does DEX work" title="How does DEX work"></p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-2-waves-node-and-how-it-works-its-configuration">Chapter 2. Waves node and how it works, its configuration</h1>
<p>I would recommend starting a direct technical acquaintance with the Waves platform with installing and configuring a node. Not necessary for the main network, it is possible for testnet (full copy of technical capabilities) or stagenet (experimental network). Why do I recommend starting by installing a node? Firstly, I myself began my acquaintance with the Waves blockchain with this, and secondly, the installation and configuration make you understand what settings the node has and what parameters the network has.</p>
<h2 id="what-the-waves-node-consists-of">What the Waves node consists of</h2>
<p>As in almost all blockchains, a node is a software product that is responsible for accepting transactions, creating new blocks, synchronizing data between different nodes and reaching consensus between them. Each member of the network starts its own copy of the node and synchronizes with the rest. We'll talk about the rules of consensus a little later, now let's figure out what a node is from a software point of view.</p>
<p>By and large, a node is an executable file (a <code>jar</code> file for the Scala version and a binary for Go) that at the time of launch reads the configuration file in order to start communicating with other nodes in the network using the protocol over TCP based on these parameters. The node adds the received and generated data to LevelDB (key-value storage). By and large, that's all, but the devil is in the details. As you delve into the specifics of the work, you will realize that this is not as easy as it might seem. For now, let's talk about where the node starts its work at the time of launch - the configuration file.</p>
<h2 id="installing-a-node">Installing a node</h2>
<p>In this book, we will not analyze the process of installing a node, since this has already been described many times in different sources (documentation, videos on youtube, posts on the forum). No book will be enough for us if we want to plunge into this topic, because there are many ways to launch a node:</p>
<ol>
<li>Running the <code>jar</code> file</li>
<li>Running a Docker container</li>
<li>Install and run from a <code>.deb</code> file</li>
<li>Installing from the <code>apt-</code> repository</li>
</ol>
<p>Personally, I prefer running a Docker container as it makes it easier to maintain, configure, and configure. Another reason for my love for Docker may be that I made a Docker image hosted in the Docker Hub and I know perfectly well how what works there. Although unlikely, it's just more convenient! <img class="emoji" alt="smiley" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAWaUlEQVR4Xu2bebAlV33fP79zum/fe9+99+3z3qyaGc0iCQ3LzEhIMpalICQKx0JYyEAkgTEJlAtX4qLKdhHsgBIndoWYONj8gR0gWAI5BoPAC7KQUyJG20gapAgxZvbhzfZm3r7crfuck+5TXdXFvEUjBymqsk/Vd86dmdPn/j7f/p2tXz9xzvGPuSj+UZd/MuCfDAh4mcs9Iuquu9gaOHaheI0I2wRGlZY+HFUAhKY1bsbBWec4jOWFRHj+vvs4+nHnLC9jeVkmQUnLsbu52gm3hpqbVShX6FBVVUmhSoIoAS0AhYzDWYftZrKY2DZt7H4QGx4Sxze33Ms+l5ZXtQHP3CrVwT5+QWl+qVRWP6UrSqmqRkUZuEOURbRLJSAXGOAczmQSnFXYrmA7Fts0mJa13bZ91Bo+PznDn+35pmu+quaAR26U4Ph75RdHhuXJakN/oWc0+ulofaSidQHRsKM0rCmNDlHe9nqiK28h2vNeytf8MpXr/o1X+tn/W/p/vk3aNrvGX+v7SPvK+sz6zr4j+67sO18VGXDwTrm6HPKfyjX95qA3IGhoJDKockDQtxE1+gbUyB6ktg0pD0BQBdEgAA4AEHCAM5A0ce0p3MJh7Pgz2LPfI5kZw7YTXEeTzBmS2YT2gvnbdsy/3fElt+//iwGSlqN38pFyVe4p9Yc9ui9M2SyqGhCM7EJfcjNq+GqoDORwCWAhNxwBHMt8FkCBBCBAawp7fh/mxEMk489jmwlJU2FmYrrT8WK76T6+9Ut8yqXllTDAgz99B43hCn9Yruu7wqESQa9GVwzBmh3obbej1lwDQRlcF5xBRPEPKc7ZPFtKkLSx557AHP5zknMHMS1NMmuIJ7q0581951v8yt6vMOeNeJkM8PD7b2XtwABfqvYGN4QjKXxdCGppfektqM23I1Ef2DYCSyc6uVhylk6QAKqM68xgj6cmHPkbkoUuybwjHu/SnE0emZrizt3f5MxLMSF4qfBDAzxQHgyvioYjdB2C/n6Cy9+DGvlpcDGSzILIamAvXQ4EIOmA1uhtdyL1TciB+xE1jVJlCDo3KOIH0hhvE5GLNiG4WPgHb6E/hb/fw49m8ELYP0jwmg8g/ZcjZhaQJWP7J1IKFMQBNFFrriYM68gLnwM9SaQjgKuGiO9PY32HiExfjAnBxcAD6rJRPl3uD66P1kTohkrh+wguvxvV2AzxNIgq4HnZDCgywrSQxmaCK+6GA18EmSGyEVh3/WUu+TTwPhGxL2ZCcDHwB+/iI5WGvjNcUyLo0wT1tN76s0htIyQzHh63DHBUgkBDqwPW8pKKUlCJIDHQ6S5vSNLOYvCxcPCrCF2sLVFJ3J0H7zLP7biPTxUmvKRJsIB/7A72bO6X/1VeX+4pDUcEDQg2vgm1/iYgARGE5eBDnt9/mB8eOs0/f+teyrWyh7moEmjaC23+8sGn2bl9Hbt2b4NOvMQEB+DZAuyph0nGvksyB93zHdqn2ovHp90/u+4rPAOsaEKwGvzdI5TX1/lkNBj2hP0hQU2h+0dRQ28Auwg4JKdHfhz+hf2H+K3f/AJTkx0OHjjEb3z03WgsWFYvCkyi+NR//VMe/NZzDAxG/Mfffj+vef3WHzfBgeA8P4iPSS8cBXsWl4S4tulZn3Q/mTK87d5x2kUmXNwQEEB97CbeVanp64MUXtdCVEWhBq8ErcA0EVl+qbOdDv/zyw/RCDpsujTk2Sef46lHL+ean7kCWl1WLaUST33neX/N69NrZxZ8X3zi8rtQ1oJbksJ4LB2gBnfhmufRiRD0GyqL5vqP3WTede+XuBdwwIsZUKT+R6+m0RPJr3v4eqqyoGpDSHUUzAIiDpwsTf1Qc/zQec786BSXDIdEocLE8MRjz3PNdZvBxeBWsT1OfNvhGqxpKHorYdZX2ucYW7cPQ2wAlmaCFaQ64mPU8XlsPfQm9CzYX//o1e4bv7OPWRFxWXmxDFCAfs82bo8aemfQCFCVVJFCautBHGKbK6/1UYnDh04S2A6NckQYCAP1gNNjZ2nNzFKpKjArOKAlbdPM2vprapEQacXEbMf3uXVnL5juSpMZTgIfo2pO+piz2KNGsvM925LbUwO+CDjALG9AcffljQNE9bJ8IGhoVE+ALiskipByL2JbgIUV+Iktp0+fpxIKoU6loFJSzC02GT83xebN9ZVXBK3SNvN0mk36epS/Fi1ZX75P4jbY7iqbpRiyGKMIHXewPf5wRn3OfOCNA+5Pn5zCSJ4GK2WAAPp3r2d3pSp7dS1AlTWqpJBSBVEBmBaIA1Y2YHZ6nigUtAIleCOcSZidmQNXAmNWmv2zNr5tqBVKvCdZX75Pb4BZZQ5xksXoY1Wl2MeeMVSq8d7fvd7tvvEBHgcssKIB3vORmro1rGn/MEOXNBIoCCIgWX0MA1hLu90m0IIIXkrhodutRaABNmb5Evo2GINSKr+erC/fJ7bIgJUlPlYJlI/dVDUZy0iNW8HuAwxgCwMumPy29hNWyu5G8U9yNBIqJBCUDsB2eNF1zBp/B5UIQu6qgADOxjlEsvK1Nkbya4D8s88gsK3CvBWlfKw2EB+7Z6hqKuXkxozt6DRJMQwguHDp+/getkZl2akrGilpVGaA1oDxBuBWMECKk1sUBTQdRXGgAkUYxBDPpUqKTCwwIQiyNr4tDii69H3iukUGrLiSKMD4mFXoPEPGkjF9fI/b+r6HOZCzLmuA3lhnVxCpin+OFwjoPA9dB2yTFTf8LpP17WoNmLQFg3UQhJpaeQoWZyC2yxAIWJW2sb6tdQWntfg+cfNgbA4JwNJYnPMxID52z5CxZEwb63YXcDCHYNkM6KuoK3QkSJhKK0SJFy6GZB5U+YL9qAEbg8tkQMOaYcth42PxSgyEkWKwX3mAFU9KxmZtfNvE2Px6iI3vE+Jx6AKiQUJQqUQXPJBnaZzHnTOEQsaUsYH9+koGqExR4C6VQOHhtYBSxZqfLIJ0QVQBnwlHEYBm44YII4KxDqWETtfSP1qmvxFAe5UxbPFt+odKtM42sRXt+zAivk8sxXfSBSMgujDBWQ8P5LOvZ/AsGVMUJJeScxYGUKz/gA6FNeSpL5LDowpG1y0ARJbeza5l2+YKPX0pRCdGRFhsO153RR0dAq1VjskO32ZH2vax44v01qDVcVlfvk+63R8fcuSGkFAUKSTWM6AFAsGzgfbI+USoLrgy1AF9ko97dDHii71DAY1jqRJHowa73zTAuemEyZmEoFHi2msb0IpBWLkIvk3a1l+TXuv7SPvyfZK45Xf0TnCuqFOuoonHFTKmjA0IV50DlFAWlYM7L8T/UZhQ0IKw1Bfm2tzylj4mZgxHfjDHO9+3gTU1C9MGRFi1xI41/Zbb/9UmvvrFk1x5XcP3xeQCCAV9URWflzkv56EjCjI2QC1nQLFkC3j/XOGA82OriD3vdeUnPwbKswt84P3DtNUo5fkWnFvM4d3qyyjAdJPdW3q44vd2ULYGTs2BsUUbdwG4W6aTIn7AMyEChQFeLrhgLVHG0saQQxucE8TpvFGRGYIDWQZHcnUNcmKSst8GO9AX95TM5QxMzFOeXsh/ZgioAhhZCu/jLDIij9PgZS0Y8GxFT27Zs0BimcsucCZJJeByM6RYZ5VyEAlY5+Vc4Ssur3EFTGHzcmVFZzy4AJqlk1++HRAtgGA7zpvgkMIVDx7nLJaMbbXnAQ6gkzDhHbOZewpnFYKlyBHH7ILlqccT1o0Il25WRI3cAAsY8KYASKF/0ENQDdjCH5RAkJsdw/wUHDhsiGPh6l0BWgvOFkY561KZnMV6NkCWHIZcWkTEAcx25cS62Pm09Q66BKzgFAiCKju+9rU2n/l8m9EBxaYNiu3bFVfsVGzZLN6UWg2kLKBzEilAsKtkgyyzsgqQCLbpmJ2BsVOOI0cdB/7ecPio5eRpy2IC/+3fV9n7uhDbLoYGzjPgEoeLnWcDR47slsuA5MScPbKzq7HGYa1FOZWP9yIdDbChoRiMHBM/Sjh+EP76r6DSA319MLpWs3ZU0hpG1giDg1BvCOVK8aA4LIHWgIM4gaSbykC7Da0mzM45Jifg7LhLBafPWMbPWubnoNuCioZGGTY1NBNNRywOlEGUgC224BmDZ+lCxgaYlY7DFkgePcPRN2+3bWJbdkbhhwOCKEAsAJdsgZ7IURvqY+ueG2m12kycPMTcxBTz8zOMP2fY9xQUx2EPTKUCpciDE+ZGOCCOIUllDLRb3gT/dzwAiEBUhkojYmB9L72jIwyt3YbqLDD+zCP0Bwlr1+Y703y9w4CzeSYnFtOx7YwNiAG7kgHxn7zAyY9cxZFyx73GJXkKofK1FB/RJZvBhQ4zuI4rf+6DlIIAl7RJ4i7NmTMsTE3SWphhdvwIi1Oz/izfac/TmZ9J6wUfVDu2JE0DCGGkUZFQ0pr6aINyT18K3EO5ElEfXkN9aAuVnlpajxLVBglKJSSoMHHqGIf2P8rQSMLwEGAcqAwYHOBjj52fIBdaHMnYVjPAAZ3FmHh8Tp4YzAzwTXMBCGBgwzphYKPi6InjzE+cZP2m7agopFQqEW3aSpjWQRCgtUJEobTCJV1M3MSktQCCFCdrBeBwgA4rXojGp6+zmMSQJAndTodOp0XcjUEFjI8d5FS2Z7g2pKcOdhaQIk5vRKaWI2NajD1RZ+kQKCbCGGg9PGa/u2Ojen/Qdsp08RMfThAFDqjW4bVXBTx73yJ/99Cfcdudv8rQ8AhBoFEC4gwKRagDb0QYhqnqlEpr0UHo2+nMIAGAxFiM8ZAkcUw37qaQXTx0Cuuwvs9AK1Slig4SThw9yKMPfxWlYe81CiygQBxYBxiHyeDbjqTtbMYEtIA4Y13pFRkLND/1FH8/Neu+b5oW17XY2IEFBDxhF274Gc26Yc2hfQ/xh//hQ9z/+d/j/+x/gsXFRaJyhWpPnUq1RikqEwQhWmuKE6RFUlEs+DhrvESEQOvMNH9tT62W9lUjCCOmJs/zxN99my/8wT388X/+FeZPHeGyywLe8FoFHRDvPmDAJg7XsZiWJWPJmIAmYFd7LG6B1lxM69nT7oGbh+1rXVtBFbA+TiQQ6Dp2bBOu/SnNs49CqzPG/oe/zOPf/jK9QxvYsPlyLrtyNxsv2cHmbTtZM7KOWi0zpJeoFHJhCYLAC2Cx2UpNXGBhYYFTY0c5cewIxw+/wMED3+PMiR/Smp+iFsDaOqiy5pa3BdSq4NoAAhYweep3HG7ekrFkTOC1ggHFMGgBcx/7Lt9540Z7fKDXblYVQVVASgq0AxHoOG57V8CpH1h6gpCdQzAXW6aaJzn7wkkOPfNtDBBWqvTUB+kbGGZgzTr6B0YolatUUkWlEs5lBrbotFu0mvNMT5xh8vwZZqcnaC1MknRiIgWNClxSg4HBFFgL8aKjsll481sULDrwW25SCT5rWxYzb9N+7PGMBZgDWhfzg5EEmD8yy/zjY+5P3tpn/53uUdgKqAgIBTTQxm98bnxnyL6vxGzoUyit6VpFy8Bi4liMHc24RbM7Rmt8jB+N7edwAsbm4zSTeKEBrSEKoFKCDamqo0JPqFMpqgFUNIQidDqOMzG845dCqiHgBEHACi5/7moWHGbGkjFkLOCVLL8VXpoFC8DML/8t33lird2/tm52S9VnASpUoAUJgVnHLW/XnD1hmf6+Yf2wohQITsBYIXaOxCq6lrSG2Hl4/OrqKHbXgJZ8p6u8x4TKf6aU1SJo8dfQ7sLZSceb7gi5cpfAOQciuAw+gXzck8waxifs/owBmAEWXsoPRzvAzGyb3s8+6z7zGw3zGamoskRCGFiUVhCAWCHoWO74cMi9n4RzpyzrhhVR6IEQkeJUCljnLjil5pJifhUyCSLgRfFccbHjOD3t2PmWgJvfoWHCgCh8fwZs2/qhkcxa2lOmncWeMswBMzkTL25AkQVzwOTvP82RGzbK566vmA/rSLChQgILgaQCaUGj1/KeXyvx1T+IOXXMsnZYqOQ7Pa1ACtJVXvsQYOl53+QPRRe6KfyUY9tNAW9/b4CaMmBU/hgQXNtiU3ibwptJw5PH5HO//7Q7AkwCcxf/fkChLjAFVG/7uv3GU3XZvi1MbiYMQBRKCSoARJB5RzpZcmdqwl/fG3PiyYSRXqFeE0qSmyAXosqKh0DncngLnZhsGWMmdlz17hI3vFUhEwY6+aTXBdsCO++IZyzd8wlHxuxDt33dfQOYyBm6AKsasMpcMAVU7v5L90cP3G7XjGjzevIxKlohCE5AZqGnx/DOD4Y8faVm3zdjZs87BnuhWhHvm1KgAN9+OXgHNr/r3QQWFh1TKVh9s+a2O0K2bQXOWegKLgZfNx12zhJPpzpnsmH4bBYrMO3hlx37hfQnPvEJVirp/7l77rnHAEy00M+e5/s3jborKophAkEE8DAKEIhBWo71OxQ7rguII+H0acfMtKMbCw6wgPMSbCHi/G4vtv0dZ6oJekSx5+0lbv6FkOGK9fAuFjx4W7BNm8I7PPx4Bm8O/Mtvud/ZP84p4AwwlbJ3/59flBSROjACrH/TRtZ99hb5tXWb1BvC0QDdqwjqgvQoJAIJHRIAPcCAZqElHD5gOfqcYXrM0p13kBTDorjroCKI+hQjWxVbX6fZuk0oWQuTFjr5JjIRXAtc05LMO8ysJT6bcHrMfu9DD7r/8t2TnAROA+Mp2/xP7E1REekH1gCj23sZuv82+eDWTermcFij+1VugqDKApHkr8UDVaChIFI02zA97ZibhsUZR9x1AERVod4vNHqF/gEoBQ4WLcw6PLj14NB12LbDLTiSfJ2PzxsO/8h++1/8hfvvh6c4C17nU65pgJ+kAQL0A8N5NjT+/OfV26671L2/MqjLwaBGNwRdU0gZJBKkBBKACKDxxlABQoFAipOIARLnAWllNWBy8Kzu5tvaFphFi5lzJFOG1qRpP3ZEvnD71+y3gBlgPIMHZlxaXo53hRXQCwzlRgz86z1s+dAe+cW1o2q3HlAEfQqVZUJFpQIJMwloEA/tQFY4hjnAb2jyM33sPLxt47e2Nl/jzZTlzFm7/7PPuP/x6Wc4Ckzl4JPAbMpkX9a3xYE6MJirv6Kpf+atXHfDFvn5viG1RfcqdF2hqoJUBF0CSuLNQIOoYtcD5OAOH7bJwIGOw3T9WR7bdJgF68f7zIQ99sgx97UPP8hjLcM8MO3BvZh3aXmlfl+glmdDP9AHNNbXqP32Dey9dqPcMtgvu4KakswEXVXFkPDZgJdSAGBzcFye6nnKm6b18MmCdZNT7vnHT7q/+c1HePrUAguQ7/BgOr/rC6/4b4yISJRnQyM3oQ7UgOBX97LlZ7ervVv63d5anc2liopUJBAKEoAKfjwD/Pk9AfJHWN2W7SzMc/zYtDz9V4fs0+mO9BiQgIefz+Hn8rveAXjFDSjmBSoevlAV6AEiDerndrDm+o2s3zmoNg5V3bpqyEAUUAs1EUBs6HQSFpoxUxNNOf3DSTv2v8c49RcHOWfAAh1gEWh6+EKtYry/0gYsNSLIjejJVc2NKQOlXDqXLWoAFGCK2qubqw20cvjFTDl48ur7vcHCiAgo56p4+EIaUHlNIQxgC/hcHp52rs4S8FeVAUtXi/ACBb4uDChmgcKAGEh8TSFXBMqr24DV5woNKK/lz0M2l/Fj+xUo/xd+DYsy448VUQAAAABJRU5ErkJggg==" /></p>
<h2 id="node-configuration">Node configuration</h2>
<p>The configuration file of the Waves node is described in the <a href="https://github.com/lightbend/config/blob/master/HOCON.md">HOCON</a> format  (it's like JSON, only with comments, the ability to compose several files and, no less important , with fewer quotes). The complete configuration file looks cumbersome, but I will still provide it here, the version at the time of this writing (the file is constantly changing, but the current version can be found in the <a href="https://github.com/wavesplatform/Waves/blob/master/node/src/main/resources/application.conf">Waves Github repository</a>.</p>
<p>The file contains a large number of comments explaining each parameter, so we will not analyze all the parameters in detail. Let's talk only about the main points.
The configuration contains the following sections:</p>
<ul>
<li>waves</li>
<li>kamon</li>
<li>metrics</li>
<li>akka</li>
</ul>
<p>The last 3 sections are service ones, which are responsible for logging parameters, sending metrics and the akka framework. We are only interested in the first section, which relates directly to the protocol and contains the following subsections at the first level:</p>
<ul>
<li><strong>db</strong> - parameters for working with LevelDB and setting what data to save. For example, the results of some transactions can be compressed (save up to 10 GB), but this hurts the usability of the API. Therefore, be careful about what to enable and what to disable and save disk space.</li>
<li><strong>network</strong> - parameters of communication with other nodes in the network. There are many important parameters in this section, which we will discuss below.</li>
<li><strong>wallet</strong> - file parameters for saving keys. Each node that wants to generate blocks (in order to receive rewards for them) must sign their blocks. To do this, the node must have access to the account key. In this section, the private key is set (or, to be more precise, the seed phrase encoded in <a href="https://en.wikipedia.org/wiki/Base58">base58</a>, the password in order to encrypt this phrase, and the path by which to store the file with this encrypted key.</li>
<li><strong>blockchain</strong> - parameters of the blockchain in which the node will operate. In this section, there is a <code>type</code> setting that allows you to set one of the predefined blockchain types (stagenet, testnet or mainnet). When specifying the value <code>custom</code>, you can change all the parameters of the blockchain, including the initial number of tokens, their distribution, network bytes (unique identifier of each network), supported functionality, etc.</li>
<li><strong>miner</strong> - parameters for generating new blocks. By default, generation is enabled (you need to understand that this will only work if there is a generating balance of more than 1000 Waves on your account), but it can be disabled using the <code>enable</code> parameter. It can be useful if, for example, you need a node that will only validate blocks, but not generate them. Another useful parameter is <code>quorum</code>, which determines how many connections to other nodes are needed for a node to try to generate blocks. If you set this parameter to 0, then you can start a blockchain consisting of 1 node. Why do you need such a blockchain, if this one node can rewrite the whole history and do whatever it wants? For testing! The perfect sandbox for blockchain games.</li>
<li><strong>rest-api</strong> - the node has a built-in REST API, which is disabled by default, but after enabling (the <code>enable</code> parameter is responsible for this) allows you to make HTTP requests to receive data from the blockchain or write new transactions to it. This API has both methods open to all and those that require an API key, which is specified in the same settings section. The <code>port</code> parameter specifies on which port the node will listen for incoming HTTP requests, on the same port the Swagger UI will be available with a description of all API methods. <code>api-key-hash</code> allows you to specify a hash from the API key with which private methods will be available. That is, in the configuration file we specify not the key itself, but the hash from it. What hash should you take? SHA-1? SHA-512? Or, God forgive me, MD5? None of the above, because Waves uses a <code>secure hash</code>, which is a sequential computation of the<code> Blake2b256</code> and <code>Keccak256</code> -<code>keccak256 (blake2b256 (data))</code>hashes. The REST API has a method <a href="https://docs.wavesprotocol.org/en/waves-node/node-api/utils"><code>/utils/hash/secure</code></a> that allows you to pass a value and get a ready-made hash.</li>
<li><strong>synchronization</strong> - synchronization parameters in the network, including the maximum fork length and the <code>max-rollback</code> parameter, which specifies how many blocks can be rolled back and by default equals 100. In fact, we can say that the transaction finalization time, after which exactly you can be sure that the transaction will not disappear from the network, is 100 minutes (average block time is 1 minute).</li>
<li><strong>utx</strong> specifies the uncommitted transaction pool parameters. Each node configures these parameters depending on the amount of available RAM, power, and the number of CPUs. The <code>max-size</code> parameter, which specifies the maximum number of transactions in the pending list, is 100,000 by default, and<code> max-bytes-size</code> has the value <code>52428800</code>. Upon reaching any of these limits, the node will stop accepting transactions on its waiting list. We'll talk about UTX separately in Chapter 5 &quot;Transactions&quot;.</li>
<li><strong>features</strong> - each new functionality and consensus changes (namely the consensus rules, not changes to the API or the internals of the node!) must go through the voting procedure. We'll discuss how voting works later in this section. For now, let's just say that each node votes using the <code>supported</code> array in this part of the configuration. Also, a node can automatically shutdown if the entire network has accepted some update that is not supported by this version using the <code>auto-shutdown-on-unsupported-feature</code> flag.</li>
<li><strong>rewards</strong> allows you to set the size of the block miner reward As with protocol updates, a vote is taken, but the reward vote works differently.</li>
<li><strong>extensions</strong> describes which extensions should be run with this node.</li>
</ul>
<p>In the section <code>waves</code>, at the first level, there are also some parameters:</p>
<ul>
<li><code>directory</code> - path to the directory in which the node will save all the files that refer to it, including LevelDB files with data</li>
<li><code>ntp-server</code> - time synchronization server</li>
<li><code>extensions-shutdown-timeout</code> is the time that is given to extensions connected to the node to exit correctly when the node itself is shut down</li>
</ul>
<p><strong>In the next sections, we will analyze in more detail which parameters affect the behavior of the node and how.</strong></p>
<h2 id="configuration-features">Configuration Features</h2>
<p>You have already seen that the configuration of a node is done using HOCON files, which support the ability to compose. In other words, you can use the <code>include filename.conf</code> statements in the configuration file, which can load different configuration sections from another file. Some sections can be repeated in different files, so there is also a conflict resolution mechanism there (the lower the file is connected, the higher priority it has). If you have experience with CSS, the principle is the same. In some places in the Waves documentation, a notation like <code>waves.network.port</code> is given, as you might guess, this means a parameter in the configuration along with the path:</p>
<p>hocon
waves {
network {
port = 6868
}
}
``</p>
<h3 id="safety">Safety</h3>
<p>When configuring a node, it is important to pay special attention to those parameters that directly affect security - the <code>wallet</code> and<code> rest-api</code> sections. It is considered good practice to specify the seed phrase and password in the base58 configuration file, start the node, and then delete the phrase from the file (without restarting the node). Thus, the launched node will know the private key and password (this is in RAM), but nothing will remain in the configuration file. If suddenly someone gets access to your configuration or even the <code>wallet</code> file, he will not be able to decrypt the key.</p>
<p>The node's API key is equally important, because it allows you to send transactions from the node, signed by the keys stored in the node. Unlike account data, only the hash is stored in the configuration, so there is no point in deleting from there after launch, but it makes sense to use the most complex key and not the default one (in older versions there was a key by default, in the latter it is already not).</p>
<h3 id="optimal-blockchain-settings">Optimal blockchain settings</h3>
<p>A very frequently asked question - what are the optimal settings? First of all depends on what kind of network we are talking about - <code>stagenet</code>,<code> testnet</code>, <code>mainnet</code> or<code> custom</code>? For example, there are no optimal ones for <code>custom</code> because of the different network requirements. But you need to understand that the Waves node is not omnipotent, it is empirically shown that when the block time is less than 12 seconds (<code>waves.blockchain.genesis.average-block-delay</code>), the microblock time is less than 3 seconds (<code> waves.miner.micro-block -interval</code>) and a relatively large number of nodes in the network (10+), the network can quickly split into several. This behavior is caused by delays in the transmission of network messages.</p>
<p>An important parameter that needs to be adjusted taking into account the peculiarities of the environment is the maximum number of transactions in UTX. 100,000 transactions is optimal for a node that meets the minimum system requirements.</p>
<p>I described above only the most basic parameters, we will consider many others in the following sections, as we dive into the protocol and its features. Now I will give a complete configuration file with comments:</p>
<pre class="hljs"><code><div># Waves node settings in HOCON
# HOCON specification: https://github.com/lightbend/config/blob/master/HOCON.md
waves {
  # Node base directory
  directory = &quot;&quot;

  db {
    directory = $ {waves.directory} &quot;/ data&quot;
    store-transactions-by-address = true
    store-invoke-script-results = true
    # Limits the size of caches which are used during block validation. Lower values ​​slightly decrease memory consummption,
    # while higher values ​​might increase node performance. Setting ghis value to 0 disables caching alltogether.
    max-cache-size = 100000

    max-rollback-depth = 2000
    remember-blocks = 3h
  }

  # NTP server
  ntp-server = &quot;pool.ntp.org&quot;

  # P2P Network settings
  network {
    # Peers and blacklist storage file
    file = $ {waves.directory} &quot;/ peers.dat&quot;

    # String with IP address and port to send as external address during handshake. Could be set automatically if UPnP
    # is enabled.
    #
    # If `declared-address` is set, which is the common scenario for nodes running in the cloud, the node will just
    # listen to incoming connections on `bind-address: port` and broadcast its` declared-address` to its peers. UPnP
    # is supposed to be disabled in this scenario.
    #
    # If declared address is not set and UPnP is not enabled, the node will not listen to incoming connections at all.
    #
    # If declared address is not set and UPnP is enabled, the node will attempt to connect to an IGD, retrieve its
    # external IP address and configure the gateway to allow traffic through. If the node succeeds, the IGD's external
    # IP address becomes the node's declared address.
    #
    # In some cases, you may both set `decalred-address` and enable UPnP (e.g. when IGD can't reliably determine its
    # external IP address). In such cases the node will attempt to configure an IGD to pass traffic from external port
    # to `bind-address: port`. Please note, however, that this setup is not recommended.
    # declared-address = &quot;1.2.3.4:6863&quot;

    # Network address
    bind-address = &quot;0.0.0.0&quot;

    # Port number
    port = 6863

    # Node name to send during handshake. Comment this string out to set random node name.
    # node-name = &quot;default-node-name&quot;

    # Node nonce to send during handshake. Should be different if few nodes runs on the same external IP address. Comment this out to set random nonce.
    # nonce = 0

    # List of IP addresses of well known nodes.
    known-peers = [&quot;52.30.47.67:6863&quot;, &quot;52.28.66.217:6863&quot;, &quot;52.77.111.219:6863&quot;, &quot;52.51.92.182:6863&quot;]

    # How long the information about peer stays in database after the last communication with it
    peers-data-residence-time = 1d

    # How long peer stays in blacklist after getting in it
    black-list-residence-time = 15m

    # Breaks a connection if there is no message from the peer during this timeout
    break-idle-connections-timeout = 5m

    # How many network inbound network connections can be made
    max-inbound-connections = 30

    # Number of outbound network connections
    max-outbound-connections = 30

    # Number of connections from single host
    max-single-host-connections = 3

    # Timeout on network communication with other peers
    connection-timeout = 30s

    # Size of circular buffer to store unverified (not properly handshaked) peers
    max-unverified-peers = 100

    # If yes the node requests peers and sends known peers
    enable-peers-exchange = yes

    # If yes the node can blacklist others
    enable-blacklisting = yes

    # How often connected peers list should be broadcasted
    peers-broadcast-interval = 2m

    # When accepting connection from remote peer, this node will wait for handshake for no longer than this value. If
    # remote peer fails to send handshake within this interval, it gets blacklisted. Likewise, when connecting to a
    # remote peer, this node will wait for handshake response for no longer than this value. If remote peer does not
    # respond in a timely manner, it gets blacklisted.
    handshake-timeout = 30s

    suspension-residence-time = 1m

    # When a new treansaction comes from the network, we cache it and doesn't push this transaction again when it comes
    # from another peer.
    # This setting setups a timeout to remove an expired transaction in the elimination cache.
    received-txs-cache-timeout = 3m

    upnp {
      # Enable UPnP tunnel creation only if you router / gateway supports it. Useful if your node is runnin in home
      # network. Completely useless if you node is in cloud.
      enable = no

      # UPnP timeouts
      gateway-timeout = 7s
      discover-timeout = 3s
    }

    # Logs incoming and outgoing messages
    traffic-logger {
      # Codes of transmitted messages to ignore. See MessageSpec.messageCode
      ignore-tx-messages = [23, 25] # BlockMessageSpec, TransactionMessageSpec

      # Codes of received messages to ignore. See MessageSpec.messageCode
      ignore-rx-messages = [25] # TransactionMessageSpec
    }
  }

  # Wallet settings
  wallet {
    # Path to wallet file
    file = $ {waves.directory} &quot;/ wallet / wallet.dat&quot;

    # Password to protect wallet file
    # password = &quot;some string as password&quot;

    # The base seed, not an account one!
    # By default, the node will attempt to generate a new seed. To use a specific seed, uncomment the following line and
    # specify your base58-encoded seed.
    # seed = &quot;BASE58SEED&quot;
  }

  # Blockchain settings
  blockchain {
    # Blockchain type. Could be TESTNET | MAINNET | CUSTOM. Default value is TESTNET.
    type = TESTNET

    # 'custom' section present only if CUSTOM blockchain type is set. It's impossible to overwrite predefined 'testnet' and 'mainnet' configurations.
    # custom {
    # # Address feature character. Used to prevent mixing up addresses from different networks.
    # address-scheme-character = &quot;C&quot;
    #
    # # Timestamps / heights of activation / deactivation of different functions.
    # functionality {
    #
    # # Blocks period for feature checking and activation
    # feature-check-blocks-period = 10000
    #
    # # Blocks required to accept feature
    # blocks-for-feature-activation = 9000
    #
    # reset-effective-balances-at-height = 0
    # generation-balance-depth-from-50-to-1000-after-height = 0
    # block-version-3-after-height = 0
    # max-transaction-time-back-offset = 120m
    # max-transaction-time-forward-offset = 90m
    # pre-activated-features {
    # 1 = 100
    # 2 = 200
    #}
    # lease-expiration = 1000000
    #}
    # # Block rewards settings
    # rewards {
    # term = 100000
    # initial = 600000000
    # min-increment = 50,000,000
    # voting-interval = 10000
    #}
    # # List of genesis transactions
    # genesis {
    # # Timestamp of genesis block and transactions in it
    # timestamp = 1460678400000
    #
    # # Genesis block signature
    # signature = &quot;BASE58BLOCKSIGNATURE&quot;
    #
    # # Initial balance in smallest units
    # initial-balance = 100000000000000
    #
    # # Initial base target
    # initial-base-target = 153722867
    #
    # # Average delay between blocks
    # average-block-delay = 60s
    #
    # # List of genesis transactions
    # transactions = [
    # {recipient = &quot;BASE58ADDRESS1&quot;, amount = 50000000000000},
    # {recipient = &quot;BASE58ADDRESS2&quot;, amount = 50000000000000}
    #       ]
    #   }
    # }
  }

  # New blocks generator settings
  miner {
    # Enable / disable block generation
    enable = yes

    # Required number of connections (both incoming and outgoing) to attempt block generation. Setting this value to 0
    # enables &quot;off-line generation&quot;.
    quorum = 1

    # Enable block generation only in the last block is not older the given period of time
    interval-after-last-block-then-generation-is-allowed = 1d

    # Mining attempts delay, if no quorum available
    no-quorum-mining-delay = 5s

    # Interval between microblocks
    micro-block-interval = 5s

    # Max amount of transactions in key block
    max-transactions-in-key-block = 0

    # Max amount of transactions in micro block
    max-transactions-in-micro-block = 255

    # Miner references the best microblock which is at least this age
    min-micro-block-age = 4s

    # Minimal block generation offset
    minimal-block-generation-offset = 0

    # Max packUnconfirmed time
    max-pack-time = $ {waves.miner.micro-block-interval}
  }

  # Node's REST API settings
  rest-api {
    # Enable / disable REST API
    enable = yes

    # Network address to bind to
    bind-address = &quot;127.0.0.1&quot;

    # Port to listen to REST API requests
    port = 6869

    # Hash of API key string
    api-key-hash = &quot;&quot;

    # Enable / disable CORS support
    cors = yes

    # Enable / disable X-API-Key from different host
    api-key-different-host = no

    # Max number of transactions
    # returned by / transactions / address / {address} / limit / {limit}
    transactions-by-address-limit = 1000
    distribution-address-limit = 1000
  }

  # Nodes synchronization settings
  synchronization {

    # How many blocks could be rolled back if fork is detected. If fork is longer than this rollback is impossible.
    max-rollback = 100

    # Max length of requested extension signatures
    max-chain-length = 101

    # Timeout to receive all requested blocks
    synchronization-timeout = 60s

    # Time to live for broadcasted score
    score-ttl = 90s

    # Max baseTarget value. Stop node when baseTraget greater than this param. No limit if it is not defined.
    # max-base-target = 200

    # Settings for invalid blocks cache
    invalid-blocks-storage {
      # Maximum elements in cache
      max-size = 30000

      # Time to store invalid blocks and blacklist their owners in advance
      timeout = 5m
    }

    # History replier caching settings
    history-replier {
      # Max microblocks to cache
      max-micro-block-cache-size = 50

      # Max blocks to cache
      max-block-cache-size = 20
    }

    # Utx synchronizer caching settings
    utx-synchronizer {
      # Max microblocks to cache
      network-tx-cache-size = 1000000

      # Max scheduler threads
      max-threads = 8

      # Max pending queue size
      max-queue-size = 5000

      # Send transaction to peers on broadcast request even if it's already in utx-pool
      allow-tx-rebroadcasting = yes
    }

    # MicroBlock synchronizer settings
    micro-block-synchronizer {
      # How much time to wait before a new request of a microblock will be done
      wait-response-timeout = 2s

      # How much time to remember processed microblock signatures
      processed-micro-blocks-cache-timeout = 3m

      # How much time to remember microblocks and their nodes to prevent same processing
      inv-cache-timeout = 45s
    }
  }

  # Unconfirmed transactions pool settings
  utx {
    # Pool size
    max-size = 100000
    # Pool size in bytes
    max-bytes-size = 52428800 // 50 MB
    # Pool size for scripted transactions
    max-scripted-size = 5000
    # Blacklist transactions from these addresses (Base58 strings)
    blacklist-sender-addresses = []
    # Allow transfer transactions from the blacklisted addresses to these recipients (Base58 strings)
    allow-blacklisted-transfer-to = []
    # Allow transactions from smart accounts
    allow-transactions-from-smart-accounts = true
    # Allow skipping checks with highest fee
    allow-skip-checks = true
  }

  features {
    auto-shutdown-on-unsupported-feature = yes
    supported = []
  }

  rewards {
    # desired = 0
  }

  extensions = [
    # com.wavesplatform.matcher.Matcher
    # com.wavesplatform.api.grpc.GRPCServerExtension
  ]

  # How much time to wait for extensions' shutdown
  extensions-shutdown-timeout = 5 minutes
}

# Performance metrics
kamon {
  # Set to &quot;yes&quot;, if you want to report metrics
  enable = no

  # A node identification
  environment {
    service = &quot;waves-node&quot;

    # An unique id of your node to distinguish it from others
    # host = &quot;&quot;
  }

  metric {
    # An interval within metrics are aggregated. After it, them will be sent to the server
    tick-interval = 10 seconds

    instrument-factory.default-settings.histogram {
      lowest-discernible-value = 100000 # 100 microseconds
      highest-trackable-value = 2000000000000 # 200 seconds
      significant-value-digits = 0
    }
  }

  # Reporter settings
  influxdb {
    hostname = &quot;127.0.0.1&quot;
    port = 8086
    database = &quot;mydb&quot;

    # authentication {
    #   user = &quot;&quot;
    #   password = &quot;&quot;
    # }
  }
}

# Non-aggregated data (information about blocks, transactions, ...)
metrics {
  enable = no
  node-id = -1 # ${kamon.environment.host}

  influx-db {
    uri = &quot;http://&quot;${kamon.influxdb.hostname}&quot;:&quot;${kamon.influxdb.port}
    db = ${kamon.influxdb.database}

    # username = ${kamon.influxdb.authentication.user}
    # password = ${kamon.influxdb.authentication.password}

    batch-actions = 100
    batch-flash-duration = 5s
  }
}

# WARNING: No user-configurable settings below this line.

akka {
  loglevel = &quot;INFO&quot;
  loggers = [&quot;akka.event.slf4j.Slf4jLogger&quot;]
  logging-filter = &quot;akka.event.slf4j.Slf4jLoggingFilter&quot;
  log-dead-letters-during-shutdown = false

  http.server {
    max-connections = 128
    request-timeout = 20s
    parsing {
      max-method-length = 64
      max-content-length = 1m
    }
  }

  io.tcp {
    direct-buffer-size = 1536 KiB
    trace-logging = off
  }
}

include &quot;deprecated-settings.conf&quot;
</div></code></pre>
<h1 id="the-mining-process-and-waves-ng">The mining process and Waves NG</h1>
<p>The mining process is key for a node, after all, its main task is to produce blocks with transactions. To do this effectively, a node must also receive information about blocks from other nodes and send them its blocks. Let's take a look at a simplified Waves mining model. For more information on the mining process, including formulas, see the article <a href="https://forum.wavesplatform.com/uploads/default/original/1X/b9f220c13f73c3a41dff7f4523c6c4a1fc03ebf6.pdf">Fair Proof of Stake</a>.</p>
<h2 id="proof-of-stake">Proof of Stake</h2>
<p>Mining is based on the Proof-of-Stake algorithm, which implies that the probability of generating a block by any account is directly proportional to the balance of this account. Let's consider the simplest case: let's say we have an account with a balance of 10 million Waves (out of 100 million issued at the time of creation). The probability of mining a block will be 10%, in other words, we will generate approximately 144 blocks per day (1440 total blocks per day appear on the network on average).</p>
<p>Now let's complicate things a little. Although only 100 million tokens were issued, not all of them participate in mining (for example, tokens can be on the exchange, and not on the node's account). If 50 million are involved in mining, then a node with a balance of 10 million will already generate 288 blocks per day. But in fact, the number of tokens that participate in mining is constantly changing, so it is impossible to directly predict how many blocks will be mined.</p>
<p>The question that arose from the most curious - <em>in what order will the nodes generate blocks?</em>. To answer this question, you will need to delve into the specifics of the PoS implementation in Waves, so buckle up and cheer up.</p>
<p>We can say that to answer the question &quot;Who will be the next generator of the block?&quot; nodes use information about balances, time between blocks and a pseudo-random number generator. Let's start with the latter, using <code>urandom</code> in this case will not work, since it is non-deterministic, and each node will receive its own result. Therefore, the nodes &quot;agree&quot; about the randomness. Each block in the chain contains, along with transactions, the address of the node that generated the block, version and time, a field called <code>generation-signature</code>. Take a look at what block number 1908853 looks like in the mainnet in JSON representation (without transactions):</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"blocksize"</span>: <span class="hljs-number">22520</span>,
  <span class="hljs-attr">"reward"</span>: <span class="hljs-number">600000000</span>,
  <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"2kCWg8HMhLPXGDi94Y6dm9NRx4aXjXpVmYAE4y4KaPzgt1Z5EX9mevfWoiBLLr1cc1TZhTSqpozUJJZ3BpA5j3oc"</span>,
  <span class="hljs-attr">"generator"</span>: <span class="hljs-string">"3PEFQiFMLm1gTVjPdfCErG8mTHRcH2ATaWa"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">"reference"</span>: <span class="hljs-string">"3Jcr6m6SM3hZ1bu6xXBmAVhA2VEUHMvE6omhEiRFn3VhEuDkgb6sgeJUC1VNRB3vTSwPb5qh576a8DwGt3Ts72Tx"</span>,
  <span class="hljs-attr">"features"</span>: [],
  <span class="hljs-attr">"totalFee"</span>: <span class="hljs-number">28800000</span>,
  <span class="hljs-attr">"nxt-consensus"</span>: {
    <span class="hljs-attr">"base-target"</span>: <span class="hljs-number">74</span>,
    <span class="hljs-attr">"generation-signature"</span>: <span class="hljs-string">"6cVJBZsjzuSqp7LPD3ZSw5V1BZ25hZQHioh9gHjWPKNq"</span>
  },
  <span class="hljs-attr">"desiredReward"</span>: <span class="hljs-number">600000000</span>,
  <span class="hljs-attr">"transactionCount"</span>: <span class="hljs-number">70</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1580458301503</span>,
  <span class="hljs-attr">"height"</span>: <span class="hljs-number">1908853</span>
}
</div></code></pre>
<p>Note that for convenience, the data structures in this book are presented in JSON format, but the nodes themselves work with blocks, transactions, signatures, etc. in binary format. For this, there are descriptions of binary data structures in the documentation, and more recently the binary data format is Protobuf.</p>
<p>Generation signature is the SHA256 hash of the <code>generation-signature</code> of the previous block and the public key of the generator of this block. The first 8 bytes of the <code>generting-signature</code> hash are converted to a number and used as a kind of random, called<code> hit</code>. The base-target value is responsible for the average time between blocks and is recalculated during the generation of each block. If the network constantly had all the nodes with the entire network stake, ready to generate a block, then <code>base-target</code> would not be needed, but if this is not the case, a synthetic parameter is needed, which changes depending on the current time between blocks and automatically align the average time between blocks is 60 seconds.</p>
<p>So, we have the parameters <code>hit</code>, which is a pseudo-random number, the balance of each account and the value of<code> base-target</code>, but what should the node do with all this? Each node, at the moment of receiving a new block over the network, starts the check function when it is its turn to generate a block.</p>
<blockquote>
<p>Δt = f(hit, balance, baseTarget)</p>
</blockquote>
<p>As a result of executing this function, the node gets the number of seconds until the moment when it is time to generate the block. In fact, after this, the node sets a timer, upon the occurrence of which it will start generating a block. If it receives the next block before the timer occurs, then the operation will be performed again and the timer will be reset to the new value <code>Δt</code>.</p>
<p>Blocks are validated in the same way, with one exception that the balance is not substituted into the formula of this node, but of the one that generated the block.</p>
<h2 id="waves-ng">Waves NG</h2>
<p>If you know anything about Waves at all, you may have heard of Waves NG, which makes the Waves blockchain fast and responsive. Waves-NG gets its name from the article <a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">Bitcoin-NG: A Scalable Blockchain Protocol</a>, which was published in 2016 and offered a way to scale the Bitcoin network by changing the block generation protocol. NG in the name stands for Next Generation, and indeed the proposal would have helped the Bitcoin network reach a new level of bandwidth, but this initiative was never implemented in Bitcoin. But it was embodied in the Waves protocol at the end of 2017. Waves NG affects how blocks are generated and how nodes communicate with each other.</p>
<p>At the moment of its mining time, the node generates the so-called * key block *, becoming the leader. The key block does not contain transactions, it is only the beginning of the block that will change. Then the leader gets the right to generate the so-called * microblocks *, which add new transactions to the end of the block and change its signature. For example, the leader generates a key block with the following parameters:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"blocksize"</span>: <span class="hljs-number">39804</span>,
  <span class="hljs-attr">"reward"</span>: <span class="hljs-number">600000000</span>,
  <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"4oBqMB7szmsbSYYguiaAXSE7ZLy13e4x97EKMmA4gs6puRqPKzCVJkuC6Py9eTpiovhcLAYuUSsnEYAi4i73tvoA"</span>,
  <span class="hljs-attr">"generator"</span>: <span class="hljs-string">"3P2HNUd5VUPLMQkJmctTPEeeHumiPN2GkTb"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">"reference"</span>: <span class="hljs-string">"4KEFeMDQgPdntzqmSNZ92NBSMcNft1o4EyQexNLXEdN3976XbdYwDgqaucd9gu2PJWt9tpt1wuvRcTMiiDtkZaX7"</span>,
  <span class="hljs-attr">"features"</span>: [],
  <span class="hljs-attr">"totalFee"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">"nxt-consensus"</span>: {
    <span class="hljs-attr">"base-target"</span>: <span class="hljs-number">66</span>,
    <span class="hljs-attr">"generation-signature"</span>: <span class="hljs-string">"HpFc5qqVftyjKbqhADkQGWBg38CVR9Bz29c7uDZKKvYV"</span>
  },
  <span class="hljs-attr">"desiredReward"</span>: <span class="hljs-number">600000000</span>,
  <span class="hljs-attr">"transactionCount"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1580472824775</span>,
  <span class="hljs-attr">"height"</span>: <span class="hljs-number">1909100</span>
}
</div></code></pre>
<p>There are no transactions in the block, as can be seen from the <code>transactionCount</code> value, but the basic parameters such as the signature and the link to the previous block (the<code> reference</code> field) are already there. The creator of this block will be able in a few seconds to generate a microblock with all the transactions that appeared on the network during those seconds, and send it to the rest of the nodes. In this case, some fields in the block will change:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-comment">// unchanged parameters were omitted</span>
  <span class="hljs-attr">"blocksize"</span>: <span class="hljs-number">51385</span>,
  <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"4xMaGjQxMX2Zd4jMUUUs5cmemkVwT8Jc5sqx6wzMUokVqWg5jvWSDF6SBF1P7x4UNQjYsgsCs4csa2qtRmG8j3g4"</span>,
  <span class="hljs-attr">"totalFee"</span>: <span class="hljs-number">65400000</span>,
  <span class="hljs-attr">"transactionCount"</span>: <span class="hljs-number">167</span>,
  <span class="hljs-attr">"tranasctions"</span>: [{...}, {...}, ..., {...}]
}
</div></code></pre>
<p>167 transactions were added to the block, which increased the block size, the block signature and the commission that the leader will earn has also changed.</p>
<p>A few important points to understand:</p>
<ul>
<li>Microblock contains only transactions and the leader's signature, consensus parameters are not duplicated</li>
<li>The generation time of microblocks depends on the miner's settings (the <code>waves.miner.micro-block-interval</code> field in the configuration sets a value for each node). By default, the leader will generate microblocks every 5 seconds.</li>
<li>With each new microblock, the data of the last block changes, so the last block is called a &quot;liquid&quot; block</li>
<li>The key block and all the microblocks that belong to it are combined into one block so that no microblock data remains in the blockchain. We can say that they are used only to transfer information about transactions between nodes.</li>
</ul>
<p>The block leader will generate microblocks and change the liquid block until another key block in the network is generated (that is, the mining start timer is triggered for some other node) or the block size limits (1 MB) are reached.</p>
<h2 id="what-does-waves-ng-do">What does Waves NG do?</h2>
<p><strong>Thanks to Waves NG, the time it takes for a transaction to enter a block is reduced. That is, you can provide a much better user experience in your application.</strong> The user can receive feedback on his transaction in ~ 5 seconds, if there is no long queue for hitting the block. You just need to understand that hitting a block is not a guarantee of finalization and the block can be canceled (up to 100 blocks deep, but in practice 2-3 blocks in extremely rare cases).</p>
<p><strong>Waves NG makes the load on the network more even.</strong> In the absence of Waves NG, blocks would be generated once a minute (1 MB of data at once) and sent over the network as a whole. That is, you can imagine situations when for 50 seconds the nodes (except for the miner) do nothing and wait, and then accept the block and validate it for 10 seconds. With Waves NG, this load is more spread out over time, the nodes receive a new portion of data every 5 seconds and validate it. This generally improves throughput.</p>
<p>Waves NG, however, can sometimes behave not very conveniently. As you remember, each block contains a reference field, which is a reference to the signature field of the previous block. <code>reference</code> is fixed at the moment of generation of the key block, and it may happen that the new miner puts in his key block a link not to the last state of the liquid block. In other words, if the new miner of block <code>N</code> did not manage to get and apply the last microblock of block<code> N - 1</code> from the previous miner, then it will refer to the &quot;old&quot; version of block <code>N - 1</code>, transactions from the last microblock will be deleted from the block <code>N - 1</code> for the whole network.</p>
<p>But do not be alarmed, this will only lead to the <strong>that the excluded transactions will fall into the <code>N</code></strong> block, instead of the<code> N - 1</code> block, in which we could already have time to see these transactions in our client code.</p>
<p>Waves NG also affects the distribution of commissions in the block. The miner receives 60% of the commissions from the previous block and 40% from his block. This was done in order to exclude a possible &quot;dirty game&quot; of nodes, when they specifically refer to the very first version of the previous block in order to take all transactions from there and put them in their own block, and therefore receive commissions.</p>
<p><img src="../../assets/2-2-1-how-ng-fees-work.png" alt="Waves NG Fees model" title="Waves NG Fees model"></p>
<p>The resulting commission can be spent by the miner in the same block. He can add a transaction to the block, for which he will receive a commission of 0.1 Waves and, in the next transaction, put it in a block that transfers these 0.1 Waves from his account.</p>
<h1 id="protocol-updates-and-other-polls">Protocol updates and other polls</h1>
<p>As you could understand from the previous section, the blockchain protocol, especially Waves NG, is a completely non-trivial thing. But like any protocol, it can and should change over time to get better. But everything is not so simple here. The Waves development team cannot just release updates and order everyone to upgrade, or say that those who do not upgrade will stop working - this is against the principles of decentralization. Many blockchains follow the path of hard forks, just a new functionality is released with a new version of the node, then whoever needs it installs it and starts mining with the support of the new feature. Whoever agrees switches to a new chain, who does not continue to mine the old one. This path is far from the best and can lead to countless forks, so adding new functionality or changing the consensus rules in Waves is possible only through the procedure for proposing new functionality and voting.</p>
<p>The procedure for changing the parameters of consensus through voting is often called governance. We will not use this word, because governance in Waves is now limited to two types of voting, while in many other blockchains there are much more possible changes (account bans, hard changes in account balances and other atrocities that do not get along well with the principles of decentralization).</p>
<h2 id="procedure-for-proposing-new-functionality">Procedure for proposing new functionality</h2>
<p>There is an unwritten rule in the Waves ecosystem (there can be no written rule, because decentralization) that all new functions and consensus changes must go through a discussion procedure. All proposals for changes are so-called Waves Enhancement Proposal or WEP. Each WEP has a sequential number, a well-defined structure and questions that the proposal must answer. The WEP form was suggested on the Waves forum in a dedicated section, but at the moment the main discussions and suggestions are on github.</p>
<p>So, each proposal is formulated in the form of a WEP, then this proposal is discussed by all interested parties, corrections are made, the wording is clarified, etc. In the end, anyone can implement the proposed WEP in the code of a node (the repository is open) and send a Pull Request to add changes to the main development branch. The Waves team is responsible for the quality of the code in the repository, so if there are no quality problems, the code will be added to the main branch and will be included in the build of the next release, which are also published on github. But this does not mean that the new code will start working, because each new functionality (hereinafter a feature, from the word &quot;feature&quot;) must be approved not only by the developers, but also by the community, for this a voting procedure is launched.</p>
<p>Here is a link to <a href="https://forum.wavesplatform.com/c/waves-improvment-proposals/23">Waves WEP</a></p>
<h2 id="voting-for-consensus-rules">Voting for Consensus Rules</h2>
<p>As soon as the owner of the node installs a new version, he will have the opportunity to vote for the new feature to be activated. Each feature has an order of the number by which the voting and identification goes, usually the numbers of new features are listed in the release descriptions on Github, but you can also look at the API of the node. A node owner can add a supported feature number to his configuration in the <code>waves.features.supported</code> array. After that (or rather, after restarting the node), the number of the supported feature is added to each generated block from this node. That is, in the binary representation of the block (in which the work is in progress), a new value appears with the feature number.</p>
<p>In order for a feature to be activated, it is necessary that its support is at least 80% - at least 80% of the blocks during the voting period must contain information about the support of the feature. The voting periods begin at each multiple of ten thousand blocs (block number 100,000, 110,000, 120,000, etc.). Simply put, at least 80% of blocks with numbers 100000-109999 contain information about support for a new feature.</p>
<p>In fact, the governance at Waves is very close to how the US presidential election system works. Residents of the country do not directly vote for the president, they elect representatives from each state (the number of representatives varies from state to state. Representatives already directly vote for the president of the United States.</p>
<p>In Waves, token holders can directly vote on feature activation, however, in most cases they do not have their own nodes and lease their tokens, thus transferring their voting rights to the owner of the leasing pool. It is important to understand that they can cancel the lease at any time if the pool owner does not vote the way they would like, which will reduce the number of blocks that this pool will generate. The largest pools in Waves often vote among leasers using decentralized apps (we'll look at an example of such voting in section 7), so representative <em>democracy</em> / decentralization can be transparent.</p>
<p>If the feature has been supported by more than 80% of the steak, then it will be activated 10,000 blocks after the end of the voting period. For example, if the voting was during blocks 10000-19999, then the feature will become active at an altitude of 30,000. This delay allows you to check once again that everything is normal and the new feature will not cause forks.</p>
<p>&lt;! - TODO: why is this delay actually needed? -&gt;</p>
<p>If you look at the code of the node or in the API (<code>/ activation / status</code>), you will notice that each feature has the following possible statuses:</p>
<ul>
<li><strong>VOTING</strong> - voting is in progress</li>
<li><strong>APPROVED</strong> - the feature has been approved, but not yet activated (due to a delay of 10,000 blocks)</li>
<li><strong>ACTIVATED</strong> - the feature is activated, all nodes on this chain must support this feature</li>
</ul>
<p>As you can see, the feature does not have the <code>REJECTED</code> status, that is, voting for a feature can go on indefinitely.</p>
<h2 id="block-bounty-voting">Block Bounty Voting</h2>
<p>There is another type of node voting in Waves that is not found almost anywhere - block reward voting. In 2016, the Waves blockchain was launched with a limited emission of 100 million tokens, which had already been created at the time of the network launch. But in the fall of 2019, the community realized that, after all, the emission model is more lively, so there was a proposal for an update - WEP-7, which went through the voting procedure and the feature was activated on block N. Now, for each block generated, the miner receives not only commissions (and that is 40% of his block and 60% of the previous one, do you remember about Waves NG?), But also receives Waves &quot;generated from the air&quot;. Approximately every minute, the total number of Waves in nature increases by a certain value. Which value is the subject of the node vote.</p>
<p>Every 100 thousand blocks (approximately 2 and a half months), a vote begins for the amount of the reward. At the moment of feature activation, N was set to 6 Waves. Every 100,000 blocks, this value can change by no more than 0.5 Waves, and then provided that more than 50% of miners are supported.</p>
<p>Voting for block rewards is done in a slightly different way from features. Node owners can set the reward value that they would like to see in the long term in their configuration file in the <code>waves.reward.desired</code> parameter. At the end of the voting period, it is calculated how many blocks contain the desired reward more than the current one, and if more than 50%, then the reward is increased by 0.5 Waves for the next 110,000 blocks (the beginning of a new voting period + the voting period itself).</p>
<p>Some community members asked why <code>waves.reward.desired</code> simply did not include<code>+</code>or<code> -</code>, since the reward will not be changed by more than 0.5 Waves anyway. Specifying the desired reward in the long run eliminates the need for frequent configuration changes. You can set the value to <code>10</code> and not go into the configuration every voting period, since you will vote for an increase until the reward reaches 10 Waves per block. And as soon as it reaches (if it does), the node will stop voting for increasing the reward. So simple.</p>
<p>Here is a link to <a href="https://forum.wavesplatform.com/t/wep-7-an-alternative-proposal-for-block-generation-reward/17013">WEP 7 - An alternative proposal for Block Generation Reward</a>
&lt;! - TODO: Add a link to what height WEP-7  was the activation -&gt;</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-3-accounts-and-keys">Chapter 3. Accounts and Keys</h1>
<p>The first thing a person encounters when he starts using the blockchain is working with keys. Unlike classic web applications, where we have a username and password, blockchains only have keys that allow us to identify the user and the validity of his actions.
Each account has a public key and a corresponding private key. The public key is actually the account identifier (ID), while the private key allows you to form a signature. Waves uses signatures with <a href="https://en.wikipedia.org/wiki/EdDSA#Ed25519">curve Curve25519-Ed25519</a> with X25519 keys (which is sometimes a problem, because not all libraries for languages ​​have support for X25519 keys programming).</p>
<p>The public and private keys are 32 byte values ​​that correspond to each other according to certain rules (you can find more details in the <a href="https://blog.filippo.io/using-ed25519-keys-for-encryption/">EdDSA</a> description... It is important to understand several things that make Waves different from other blockchains:</p>
<ul>
<li>not any 32 bytes can be a private key</li>
<li>the private key does not contain the public key (for example, in Ethereum, the private key contains the public one, therefore it has a size of 64 bytes, in Waves the public key is calculated each time for the private key)</li>
<li>the signature using EdDSA is non-deterministic, that is, the same data can be signed with the same key and receive different signatures, since random values ​​are also used</li>
</ul>
<h2 id="key-travels">Key travels</h2>
<p>Most users still come across keys not in the form of an array of bytes, but in the form of a seed phrase, often also called a mnemonic phrase. Any combination of bytes can be a seed, but Waves clients typically use 15 English words. Based on the seed phrase, the private key is calculated as follows:</p>
<p>1.the string is translated into a byte array
2.calculated hash <code>blake2b256</code> for the given array of bytes
3.calculate hash <code>keccak256</code> for the result of the previous step
4.the private key is calculated based on the previous step, an example of the function for this step is presented below</p>
<pre class="hljs"><code><div>func GenerateSecretKey (hash [] byte) SecretKey {
    var sk SecretKey
    copy (sk [:], hash [: SecretKeySize])
    sk [0] &amp; = 248
    sk [31] &amp; = 127
    sk [31] | = 64
    return sk
}

</div></code></pre>
<p>In other words, or rather the code:
<code>privateKey = GenerateSecretKey (keccak256 (blake2b256 (accountSeedBytes)))</code></p>
<p>Public and private keys are usually represented as <code>base58</code> strings like<code> 3kMEhU5z3v8bmer1ERFUUhW58Dtuhyo9hE5vrhjqAWYT</code>.</p>
<p>When sending transactions (for example, sending tokens), the user deals with the address, not the recipient's public key. The address is generated from the recipient's public key with some additional parameters: version of the address specification, network byte and check-sum. At the moment, there is only one version of the addresses on the Waves network, so the first byte in this sequence is <code>1</code>, the second byte is a unique network identifier that allows you to distinguish addresses in different networks (mainnet, testnet, stagenet, etc.). Network bytes for the above networks <code>W</code>,<code> T</code>, <code>S</code>, respectively. Thanks to the network byte, it is impossible to make a mistake and send tokens to an address that cannot exist on the network in which the transaction is sent (you cannot send tokens in the mainnet to an address in the testnet network). After the first two overhead bytes, there are 20 bytes obtained as a result of the blake2b256 and keccak256 hashing functions over the public key. This operation <code>keccak256 (blake2b256 (publicKey))</code> returns 32 bytes, but the last 12 bytes are discarded. The last 4 bytes in the address are the check sum, which counts as <code>keccak256 (blake2b256 (data))</code>, where <code>data</code> are the first 3 parameters (version, network byte and 20 bytes of the public key hash). The resulting sequence of bytes is converted to base58 representation to get something like this: <code>3PPbMwqLtwBGcJrTA5whqJfY95GqnNnFMDX</code>.</p>
<blockquote>
<p>Experienced developers at Waves use the features of address generation to determine which network the address belongs to by the type alone. Due to the fact that the first 2 bytes in the address are similar for all addresses in the same network, you can roughly understand which network the address belongs to. If the address looks like <code>3P ...</code>, then the address most likely belongs to the mainnet, and if the address starts with <code>3M ...</code> or <code>3N</code>, then you are most likely an address from testnet or stagenet.</p>
</blockquote>
<h2 id="working-with-keys">Working with keys</h2>
<p>If, for some reason, the application needs to generate keys for the user, then you can use libraries for different programming languages. For example, in the JavaScript / TypeScript <code>waves-transactions</code> library, you can generate a seed phrase using the following code:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> {seedUtils} <span class="hljs-keyword">from</span> <span class="hljs-string">'@ waves / waves-transactions'</span>

<span class="hljs-keyword">const</span> seedPhrase = seedUtils.generateNewSeed (<span class="hljs-number">24</span>);

<span class="hljs-built_in">console</span>.log (seedPhrase);

<span class="hljs-comment">// infant history cram push sight outer off light desert slow tape correct chuckle chat mechanic jacket camp guide need scale twelve else hard cement</span>
</div></code></pre>
<p>The console will display a string of 24 words, which are the seed phrase of the new account. These words are a random subset of the dictionary found <a href="https://github.com/wavesplatform/ts-lib-crypto/blob/master/src/crypto/seed-words-list.ts">in the @ waves / ts-lib-crypto library code</a> and which contains 2048 words.</p>
<p>In this example, I've generated 24 words, but by default, many Waves apps generate a set of 15 words. Why exactly 15 and does the safety increase if more words are generated?</p>
<p>15 words out of 2048 in any order is enough for the probability of generating two identical seed phrases to be negligible. At the same time, 24 words further reduce this probability, why not use larger meanings? The answer is simple - the more words we use, the more the user needs to write down and / or memorize and the more difficult it will be for him. The point of using a seed phrase (rather than a private key) is to simplify the user experience, and with 24 words, we noticeably degrade the user experience.</p>
<blockquote>
<p>What is the likelihood that someone will be able to pick up 15 words of a wallet? This question is asked by many users, so the user <code>deemru</code> on one of the forums about Waves even carried out [calculations] (https://wavestalk.ru/t/bezopasnost-koshelka-waves/123/2). I will give them below.</p>
</blockquote>
<ul>
<li>We have 20 bytes of the public key hash in the address, which should match, these are 2 ^ 160 options.</li>
<li>(Here we note that 15 words of 2048 (2 ^ 11) options each, which gives 2 ^ (11 * 15) = 2 ^ 165, that is, they overlap 160 bits with a margin of 5 bits, that is, 15 words are not taken from the ceiling, this is the minimum sufficient amount, more will be redundant, less will not cover all the bits of the public key in the address).</li>
<li>Suppose we have a search speed of 2 million samples per second (for example, F72s_v2 (72 virtual CPUs, 144 GB memory) gives such results on Azure, it costs 171 thousand rubles a month).</li>
<li>We start counting: 2 million is ~ 2 ^ 21 samples per second, for a year it will be 60 \ * 60 \ * 24 * 365 = 31536000 seconds, this is ~ 2 ^ 25, we get 2 ^ (21 + 25) = 2 ^ 46 samples in a year.</li>
<li>The probability of finding a specific wallet is 1/2 ^ (160-46) = 1/2 ^ 114</li>
<li>A million is ~ 2 ^ 20, then the probability of finding a wallet out of a million wallets is 1/2 ^ (114-20) = 1/2 ^ 94</li>
<li>While it's hard ... let's suppose we have not 1 car, but a million: 1/2 ^ (94-20) = 1/2 ^ 74</li>
<li>And not one year, but a million years: 1/2 ^ (74-20) = 1/2 ^ 54</li>
<li>Multiply a million available capacities per million data centers: 1/2 ^ (54-20) = 1/2 ^ 34</li>
<li>Well, this is a normal probability (which you can imagine at least in your head): 1 chance in 17 billion to find in a million years, in millions of data centers with a million machines in each 1 wallet in a million.</li>
<li>Good luck.</li>
</ul>
<p>Now let's get back to how to work with the seed phrase. Having a seed phrase, you can get a private key, public key and address. I'll show you again how to do this in JS, but do you remember that there are libraries for other languages ​​too?</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">import</span> {seedUtils} <span class="hljs-keyword">from</span> <span class="hljs-string">'@ waves / waves-transactions'</span>;
<span class="hljs-keyword">import</span> {
  address,
  privateKey,
  publicKey
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@ waves / ts-lib-crypto'</span>


<span class="hljs-keyword">const</span> seedPhrase = seedUtils.generateNewSeed (<span class="hljs-number">24</span>);

<span class="hljs-built_in">console</span>.log (privateKey (seedPhrase)); <span class="hljs-comment">// 3kMEhU5z3v8bmer1ERFUUhW58Dtuhyo9hE5vrhjqAWYT</span>
<span class="hljs-built_in">console</span>.log (publicKey (seedPhrase)); <span class="hljs-comment">// HBqhfdFASRQ5eBBpu2y6c6KKi1az6bMx8v1JxX4iW1Q8</span>
<span class="hljs-built_in">console</span>.log (address (seedPhrase, <span class="hljs-string">'W'</span>)); <span class="hljs-comment">// 3PPbMwqLtwBGcJrTA5whqJfY95GqnNnFMDX</span>
</div></code></pre>
<p>Please note that in the <code>privateKey</code> and<code> publicKey</code> functions we pass only the seed phrase, while in the <code>address</code> we pass one more<code> chainId</code> parameter (aka the network byte). As you remember from the explanation above, the address itself contains such an additional parameter.</p>
<h2 id="how-an-account-appears-on-the-blockchain">How an account appears on the blockchain</h2>
<p>We examined how the keys work, how the seed phrase, private and public keys are related, as well as how the address relates to them, but I did not mention one very important point that some novice developers forget about. Until the moment of performing any action with the account (sending a transaction from it or to it), the blockchain knows nothing about this account. If you generated an account (locally or in any client), but there were no transactions associated with this account (incoming or outgoing) in the blockchain, you will not be able to find any information about your account in the explorer or using the API. This is different from the behavior in centralized systems and APIs, so it might not be as intuitive or straightforward, but it's important to keep this in mind.</p>
<h1 id="regular-accounts-vs-smart-accounts">Regular accounts vs. smart accounts</h1>
<p>As you probably already understood from the previous section, Waves uses the account model, and not the inputs and outputs (input and output) as in Bitcoin. But the Waves model differs not only from Bitcoin, but, for example, from Ethereum, which also has accounts. The main difference is that Waves has several account types. Let's break them down in order.</p>
<h2 id="regular-accounts">Regular accounts</h2>
<p>The work of regular accounts is as simple and intuitive as possible. Each account (with a certain public key) &quot;possesses&quot; certain tokens and stores the data in its own storage. To make an action from an account, you need to form a transaction, sign it with the private key of this account and send it to the network. ** A valid transaction signature allows you to perform operations from this account. ** When validating a transaction, nodes actually verify that the signature and the body of the transaction match. They also need to check some parameters from the blockchain, for example, if an account wants to send tokens, does it have them on its balance. The easiest way to understand how it works is by analogy - an account is a barn with which you can do anything (take away <s> cheese </s> tokens from there, for example) if you have a key to the barn lock.</p>
<p>But a regular account can be turned into a smart account that behaves differently.</p>
<h2 id="smart-accounts">Smart accounts</h2>
<p>If you put a script on a regular account that sets other validation rules for <strong>outgoing</strong> transactions, then it will become a ** smart account. ** The smart account will also &quot;own&quot; tokens, but in order to do something with them ( translate, burn, exchange, etc.), you must not provide a signature, but satisfy the conditions described in the body of the script. The model is very similar to that in Bitcoin, with one exception - Waves does not use a primitive Bitcoin script, but the much more powerful Ride language. This book will have a separate section devoted to Ride, so now let's talk more about the concept of smart accounts. The code on the Ride is sent to the network using a script install transaction (<code>SetScript</code>) and turns a regular account into a smart one.</p>
<p>Smart accounts are a type of smart contracts. In general, there are 3 types of smart contracts that occur in nature:</p>
<ul>
<li>Simple smart contracts for managing accounts (multisignature, escrow, etc.)</li>
<li>Complex contracts with non-trivial logic (Crypto-Kitties, Bancor, etc.)</li>
<li>Token contracts (ERC-20, ERC-721)</li>
</ul>
<p>Smart accounts are representatives of the first category, being intended for basic account operations. Waves has tools for creating complex contracts, which will be discussed in Section 6, and Waves does not require contracts at all to create tokens, which will also be discussed in Chapter 4.</p>
<p>Smart accounts <strong>only allow outgoing transactions</strong> (not incoming) to be validated. The smart contract script is a predicate that is executed when an attempt is made to send a transaction from an account, and the transaction is considered valid only if the body of the script returns <code>true</code>. The body of the script can contain various logic based on:</p>
<ul>
<li>Transaction parameters (for example, the size of the commission, the recipient of the transfer transaction, the type of transaction, etc.)</li>
<li>Data from the blockchain (number of the last block in the blockchain, data from the storage <strong>of any</strong> account)</li>
<li>Transaction signatures</li>
</ul>
<p>Continuing the analogy with the barn, we can say that a smart account is a barn with a different type of lock, which is not opened by a key (or not only by a key), but can also rely on time, the contents of the barn (or any other barns), the identity of the opening etc. I think many barns in many collective farms would be safer if there were locks that can only be opened with 5 keys from different people.</p>
<h2 id="when-to-use-smart-accounts">When to use smart accounts</h2>
<p>Smart accounts are very lightweight, do not require a lot of computing power from the nodes, while at the same time they cover a large number of cases. The most common uses for smart accounts are:</p>
<ul>
<li><strong>Multi-signature.</strong> For example, there is an account with tokens from 3 parties, and you can spend them only if 2 parties out of 3 agree.</li>
<li><strong>Escrow.</strong> Often, when performing transactions in real life between 2 parties, it is necessary to have some kind of arbitrator who fixes the fact of an action on one side and the need to transfer money to it. Selling an apartment is a great example where money must be transferred when handing over the keys. This can be done using an escrow contract.</li>
<li><strong>Atomic exchange.</strong> Exchange of tokens in two networks, when tokens are blocked by parties in 2 different networks using a secret. As soon as one side unlocks the tokens on network A with a secret, the other will see this secret and can pick up tokens on network B.</li>
</ul>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-4-tokens">Chapter 4. Tokens</h1>
<p>After we talked about accounts, it is quite logical to talk about another important entity in the Waves blockchain - tokens. For me personally, it seems necessary to start with the background, because many people still know Waves as a platform for issuing tokens. During the ICO boom era (2017), Waves was the second most popular platform for issuing tokens, because it made it very easy and simple. In the first place was Ethereum, in which a smart contract must be written in order to issue tokens (simple and most often in accordance with ERC-20, but still). In Waves, issuing a token is very simple - sending one transaction of a special type <code>Issue</code>.</p>
<p>In some Waves clients (for example, Waves.Exchange), it is enough to fill out one small form to issue a regular token, which will automatically be available for transfers between accounts, work with decentralized applications, or trade on the DEX decentralized exchange. At the moment, more than 20,000 different types of tokens have been issued on the Waves blockchain.</p>
<h2 id="how-tokens-work">How tokens work</h2>
<p>In Waves, all tokens are &quot;first-class citizens&quot;, they are right in the core of the blockchain, as there are, for example, accounts. Some (especially those with experience with Ethereum) are surprised by this, but this approach has several advantages:</p>
<ul>
<li><strong>Ease of release.</strong> In 2017, Waves ranked second precisely because of the ease of release, that there was no need to understand how Solidity or Ethereum Virtual Machine works to make a token, peg to some assets in real life, and start use.</li>
<li><strong>Fast work.</strong> Simple tokens in Waves do not execute any smart contract code for their work, so they will work faster than in the case of Solidity. In fact, a simple token in Waves is an entry in the LevelDB database.</li>
<li><strong>Ability to trade out of the box.</strong> Issued tokens on Waves are automatically supported for trading on decentralized exchanges based on the Waves Matcher. We will talk about the work of the matcher separately.</li>
</ul>
<blockquote>
<p><em>You should already have a question, what if I want to not just issue a token, but make my own logic for it?</em></p>
</blockquote>
<p><strong>This is also possible by creating smart assets, which we will look at later in this chapter.</strong></p>
<p>A lot of new developers are asking how a <strong>asset</strong> differs from a ** token **. In the code of the Waves node, you will more often come across the word <code>asset</code> than<code> token</code>, but for convenience, for the sake of this book, I suggest that these two concepts be considered interchangeable. Yes, in real life, <code>asset</code> is more of an asset, and<code> token</code> is more like something close to a token / coin, but in the world of blockchain the border between the concepts has become blurred.</p>
<p>Waves has only one token that is not an asset - the Waves token itself, which is paid as a commission to miners. We can say that all tokens in Waves are equal in capabilities, but the Waves token is a little &quot;more equal&quot; and its behavior differs from other assets.</p>
<h2 id="token-issue">Token Issue</h2>
<p>As I wrote above, to issue a token, it is enough to send a transaction of type <code>Issue</code>, which can be easily done using a JavaScript library:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> {issue} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'seed phrase of fifteen words'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Euro'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">'It is an example of token'</span>,
  <span class="hljs-attr">quantity</span>: <span class="hljs-number">1000000</span>,
  <span class="hljs-comment">// senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-attr">reissuable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">decimals</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">script</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">Date</span>.now (),
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000000</span>,
}

<span class="hljs-keyword">const</span> signedIssueTx = issue (params, seed)
<span class="hljs-built_in">console</span>.log (signedIssueTx)

</div></code></pre>
<p>As a result of executing this code, the following JSON transaction object will be displayed in the console:</p>
<pre class="hljs"><code><div>{
  &quot;id&quot;: &quot;CZw4KCpPUv5t1Uym3rLc9yEaQyDsP3VVPspdpmWKvVPE&quot;,
  &quot;type&quot;: 3,
  &quot;version&quot;: 2,
  &quot;senderPublicKey&quot;: &quot;HRQUmzJKgHDGbsfS23kSA1VRuudy5MY3wGCroUmNhKuJ&quot;,
  &quot;name&quot;: &quot;Euro&quot;,
  &quot;description&quot;: &quot;It is an example of token&quot;,
  &quot;quantity&quot;: 1000000,
  &quot;decimals&quot;: 2,
  &quot;reissuable&quot;: false,
  &quot;script&quot;: null,
  &quot;fee&quot;: 100000000,
  &quot;timestamp&quot;: 1575034734086,
  &quot;chainId&quot;: 87,
  &quot;proofs&quot;: [
    &quot;2ELbuezHiaHUDCuWpfhULwqSA8SUm4vGzWQe5QUmLEPZTA5WMXctiaXaoF9aUbr8TBSBreQxa8WYMsp6Sy2qSSGU&quot;
  ]
}
</div></code></pre>
<p>Let's take a look at the main parameters:</p>
<ul>
<li><strong>name</strong> - token name (4-16 bytes)</li>
<li><strong>description</strong> - description for the token (0-1000 bytes)</li>
<li><strong>quantity</strong> - the number of tokens issued</li>
<li><strong>decimals</strong> - number of decimal places. Please note that if you set the value to <code>0</code>, then the token will be indivisible. In the example above, the minimum unit will not be 1 token, but one hundredth of the token, which is logical, since we are issuing an analogue of the euro as an example. To be more precise, we issue 1 million tokens under the name <code>Euro</code>, the minimum unit of which will be the euro cent.</li>
<li><strong>reissuable</strong> - token reissuable flag. If the value is <code>true</code>, then the owner of the token at any time can add as many new tokens of this type as he wants. At the time of re-release, the owner can change the value of this flag, thus fixing the number of tokens in the blockchain.</li>
<li><strong>script</strong> - compiled Ride script that describes the logic of the token. In our example, the value is <code>null</code>, since we don't want to set any rules for token circulation.</li>
<li><strong>fee</strong> - commission for issuing a token. At Waves, the minimum transaction for issuing a regular token (not NFT) is 1 Waves. Why, then, is 100,000,000 indicated in the transaction, where there are already 8 zeros? It's simple, the Waves token has 8 decimals, and the commission is indicated in the smallest units, in the case of Waves, the minimum units are sometimes called <em><strong>waveslet</strong></em>.</li>
</ul>
<p>By sending such a signed transaction, you can create a new token called <code>Euro</code>. Of course, there is no value in such a token, but value is the next question. The newly created token will receive a unique identifier <code>assetId</code> equal to the ID of the transaction that generated it, in our case<code> CZw4KCpPUv5t1Uym3rLc9yEaQyDsP3VVPspdpmWKvVPE</code>.</p>
<p>This rule can be extremely useful, so I propose to remember - the <code>assetId</code> of the token is equal to the<code> ID</code> issue of the transaction that created it. In the future, when working with this token, in the overwhelming majority of cases, you will have to use its assetId, and not its name.</p>
<p>Another important parameter to remember is that the Waves token (native / system for paying transaction fees) does not have an <code>assetId</code>, so in places where a long string is inserted for other tokens, you need to set<code> null</code> for Waves.</p>
<h2 id="issue-nft-token">Issue NFT token</h2>
<p>Non-fungible tokens are very often used for various mechanics, most often gaming. NFTs differ in that each token is unique and has its own unique identifier.</p>
<blockquote>
<p>The easiest way to explain the essence of NFT is with a simple analogy. For example, if you take one coin, put it in a bag with 100 of the same coins and mix the bag, then you cannot later determine which coin you put in the bag last. It would be another matter if the coins had numbers. NFT are coins with a unique identifier (number), when they can never be confused with others of the same.</p>
</blockquote>
<p>In Waves, the issuance of Non-fungible tokens is carried out in the same way as the issuance of fungile tokens, but with several restrictions:</p>
<ul>
<li><code>quantity</code> must be equal to one</li>
<li><code>decimals</code> must always be 0</li>
<li><code>reissuable</code> must be set to<code> false</code></li>
</ul>
<p>If the conditions above are met, it is already possible to issue a token with a commission not in 1 Waves, but a thousand times less - 0.001 Waves. For convenient work with NFT tokens, there is a JavaScript library <code>@ waves / waves-games</code>, which simplifies the creation and storage of meta-information about the token. An example of NFT release using this library can be found below:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">import</span> {wavesItemsApi} <span class="hljs-keyword">from</span> <span class="hljs-string">'@ waves / waves-games'</span>
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'my secret backend seed'</span>

<span class="hljs-keyword">const</span> items = wavesItemsApi (<span class="hljs-string">'T'</span>) <span class="hljs-comment">// testnet, use 'W' for mainnet</span>
<span class="hljs-keyword">const</span> item = <span class="hljs-keyword">await</span> items
  .createItem ({
    <span class="hljs-attr">version</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">quantity</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'The sword of pain'</span>,
    <span class="hljs-attr">imageUrl</span>: <span class="hljs-string">'https://i.pinimg.com/originals/02/c0/46/02c046b9ec76ebb3061515df8cb9f118.jpg'</span>,
    <span class="hljs-attr">misc</span>: {
      <span class="hljs-attr">damage</span>: <span class="hljs-number">22</span>,
      <span class="hljs-attr">power</span>: <span class="hljs-number">13</span>,
    },
  }). broadcast (seed)
<span class="hljs-built_in">console</span>.log (item)

</div></code></pre>
<p>Note that in the example above, 100 tokens are issued, not a token with a quantity of 100, but 100 different ones, each of which will have a unique ID. In other words, the library will send 100 issue transactions. The minimum commission for each token will be 0.001 Waves, and for all 100 - 0.1 Waves. You can find more examples on working with the library for NFT in <a href="https://docs.item.market/sdk/lib.html#installation">their tutorials</a>.</p>
<h2 id="token-re-issue">Token re-issue</h2>
<p>If the token at the time of creation had the value <code>true</code> for the<code> reissuable</code> field, then the creator can send transactions of the <code>Reissue</code> type, which will allow additional tokens to be issued. The example of generating a reissue transaction is very similar to the example from the issue:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> {reissue} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">quantity</span>: <span class="hljs-number">1000000</span>,
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'CZw4KCpPUv5t1Uym3rLc9yEaQyDsP3VVPspdpmWKvVPE'</span>,
  <span class="hljs-attr">reissuable</span>: <span class="hljs-literal">false</span>
}

<span class="hljs-keyword">const</span> signedReissueTx = reissue (params, seed)

</div></code></pre>
<p>The main difference is that we cannot change the title or description. In our example, we add another million to the already issued one million Euro tokens.</p>
<p>You may also notice that this transaction also has a <code>reissuable</code> flag. If you send a reissue transaction with the <code>reissuable</code> field equal to<code> false</code>, then it will no longer be possible to send such reissue transactions for this token in the future.</p>
<p>In the example above, the field for the commission (<code>fee</code>) is omitted, but the library<code> @ waves / waves-transactions</code> will automatically substitute the minimum value in 1 Waves. I often write the &quot;minimum value&quot; of the commission to show that this value can be increased, but the Waves network is not experiencing any bandwidth problems right now, so even transactions with the lowest commission almost instantly fall into blocks.</p>
<p>Please note that there was a bug in the history of Waves for a short time, which allowed reissuing tokens for which the <code>reissuable</code> was<code> false</code>. The bug was promptly fixed, but some tokens may be embedded in the blockchain, which were always unreleased, but were reissued. It will not be possible to remove them from there, because the blockchain is immutable. So it's only worth knowing about this if you suddenly do an explorer or some kind of analytics.</p>
<h2 id="burning-tokens">Burning tokens</h2>
<p>Sometimes it happens that a token gets in the way and you don't want to see it in your portfolio, but very often you need to burn it according to some business logic. For this, Waves has a <code>Burn</code> transaction that allows you to burn tokens (but only from your account, of course).</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> {burn} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'CZw4KCpPUv5t1Uym3rLc9yEaQyDsP3VVPspdpmWKvVPE'</span>,
  <span class="hljs-attr">quantity</span>: <span class="hljs-number">100</span>
}

<span class="hljs-keyword">const</span> signedBurnTx = burn (params, seed)

</div></code></pre>
<p>The burn transaction is as simple as possible and allows you to set the assetId of the token that you want to burn and the amount. Actually, that's all.</p>
<h2 id="changing-token-information">Changing token information</h2>
<p>Many users ask if it is possible to change the name or description of their token. There can be many reasons for this - renaming the company, changing the website address (the website address could be in the token description). Until recently, such a change was impossible and the name and description set at the very beginning of life were forever with the token, but at the beginning of 2020 the <code>UpdateAssetInfo</code> transaction appeared, which allows you to update the name and description, but not more often than once every 100,000 blocks. which is about 2.5 months. At the time of this writing, the functionality was activated only in stagenet and the <code>UpdateAssetInfo</code> transaction was not yet supported by the libraries.</p>
<h2 id="what-next">What next?</h2>
<p>The release of a token in most cases is just the beginning of the integration, so in the future we will talk about how to use Ride to define the logic and API for integrating your business logic with the blockchain.</p>
<h1 id="sponsoring-transactions">Sponsoring transactions</h1>
<p>There are several topics among developers of decentralized applications, the discussion of which leads to pronounced pain on the faces. These topics are:</p>
<ol>
<li><strong>Working with keys.</strong> You cannot ask the user for keys, but he must somehow sign transactions.</li>
<li><strong>The need to pay a commission in tokens for each transaction</strong>. How to explain to users that each transaction requires a commission in the platform token, and what is equally important - where will they get commissions for their first transactions?</li>
</ol>
<p>These problems lead to a very high cost of attracting one user. For example, one of the popular dApps in the Waves ecosystem had a customer acquisition cost of about $ 80 (!), With LTV (Lifetime Value or customer profit for all time) less than $ 10. The conversion was spoiled by the barriers with the need to install an extension for working with keys and commission.</p>
<p>The first problem is often solved with browser extensions like Metamask and Waves Keeper, but this solution is not user friendly and requires a lot of effort, which is why Signer appeared in the Waves ecosystem. It does not require dApp keys to be provided, and at the same time does not force browser extensions to be installed. See <a href="https://medium.com/@izhur27/getting-started-with-waves-signer-893017c9b7ae">@Vladimir Zhuravlev's article</a> about this and how to integrate Waves Signer into your application.</p>
<p>What about the second problem? Many dApp creators simply do not care about this issue, users have to get tokens for commissions from somewhere. Others require you to bind your bank cards during registration, which greatly reduces motivation.</p>
<p><strong>Now I will tell you how to solve the problem with fees</strong>. How can you create such an application on the blockchain that does not require a user to have a native token? This would allow, for example, to make trial periods for your projects on the blockchain!</p>
<h2 id="how-sponsoring-works">How sponsoring works</h2>
<p>If you have your own token that the users of your application need, then you can use the <a href="https://docs.wavesplatform.com/en/blockchain/waves-protocol/sponsored-fee">Waves transaction sponsor mechanism</a>. Users will pay a commission in your token, but since miners always receive commission only in Waves, Waves will actually be debited from the account that issued this token. Let's take the steps again, as it is important to understand:</p>
<ul>
<li>The user pays a commission for a transaction in your token (for example, he sends 10 of your tokens, additionally pays 1 token in the form of a commission, as a result, 11 tokens are debited from his account)</li>
<li>You receive these tokens (1 in our example), since it was you who issued the token</li>
<li>WAVES are debited from your account in the required amount and go to miners (the number of sponsored tokens and their correspondence Waves is configured by sending a special transaction <code>SetSponsorship</code>)</li>
</ul>
<p><img src="../../assets/4-2-1-sponsorship.png" alt="How sponsorship works" title="How sponsorship works"></p>
<blockquote>
<p><em>A question that should have immediately arisen - how many tokens will the user pay and how many tokens will be debited from the sponsor's account?</em></p>
</blockquote>
<p>Answer: the owner can set the ratio himself. At the start of sponsoring, the creator of the token sets how many of his tokens correspond to the minimum commission (0.001 Waves or 100,000 in the minimum fraction). Let's move on to examples and code to make it clearer.</p>
<p>To enable sponsorship, you need to send a transaction of type <code>Sponsorship</code>. Using the UI this can be done in Waves.Exchange, and using <a href="https://github.com/wavesplatform/waves-transactions">waves-transactions</a> the following code can be executed:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {sponsorship} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'...'</span>,
  <span class="hljs-attr">minSponsoredAssetFee</span>: <span class="hljs-number">100</span>
}

<span class="hljs-keyword">const</span> signedSponsorshipTx = sponsorship (params, seed)
</div></code></pre>
<p>The code above will form (but not send to the blockchain) a transaction:</p>
<pre class="hljs"><code><div>{
  &quot;id&quot;: &quot;...&quot;,
  &quot;type&quot;: 14,
  &quot;version&quot;: 1,
  &quot;senderPublicKey&quot;: &quot;3SU7zKraQF8tQAF8Ho75MSVCBfirgaQviFXnseEw4PYg&quot;,
  &quot;minSponsoredAssetFee&quot;: 100,
  &quot;assetId&quot;: &quot;4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC&quot;,
  &quot;fee&quot;: 100000000,
  &quot;timestamp&quot;: 1575034734209,
  &quot;proofs&quot;: [
    &quot;42vz3SxqxzSzNC7AdVY34fM7QvQLyJfYFv8EJmCgooAZ9Y69YDNDptMZcupYFdN7h3C1dz2z6keKT9znbVBrikyG&quot;
  ]
}
</div></code></pre>
<p>The most important parameter in the transaction is <code>minSponsoredAssetFee</code>, which sets the correspondence that 100<code> A</code> tokens are equal to 0.001 Waves. Thus, to send a <code>Transfer</code> transaction, the user will have to attach 100<code> A</code> tokens as a commission.</p>
<p>It is important to understand some of the limitations associated with sponsoring. You can use sponsored tokens as a commission only for transactions of types <code>Transfer</code> and<code> Invoke</code>. Only the account that issued this token can sponsor a token. That is, you will not be able to sponsor tokens not issued by you. As soon as the balance of the token creator becomes less than 1.005 Waves, sponsorship will automatically turn off (and turn back on when the balance becomes more than this value again).</p>
<h3 id="safety">Safety</h3>
<p>Before including sponsorship, there are several important points to understand.</p>
<ol>
<li>The user can use sponsored tokens for transactions not only with this token. For example, an account with <code>A</code> tokens on the balance can send<code> B</code> tokens, and apply <code>A</code> tokens as a commission.</li>
<li>The user can pay no minimum transaction fee. For example, if a user has 100,000 of your tokens, and you set the <code>minSponsoredAssetFee</code> parameter to 100, then the user will be able to specify all his 100,000 tokens as a commission for 1 transaction. You will receive 100,000 <code>A</code> tokens, and the miner will receive 1000 Waves from your account (100,000 / 100 = 1000), if you have them on your account.</li>
</ol>
<p>The sponsorship feature has been in Waves for a long time and works great, but there is a <a href="https://forum.wavesplatform.com/t/wep-2-customizable-sponsorship/15880">WEP-2 Customizable Sponsorship</a> that has ideas for it. improvement. If you have anything to add - join the discussion on the forum.</p>
<h1 id="smart-assets">Smart assets</h1>
<p>Tokens on Waves are not smart contracts by default (unlike Ethereum), so they are freely tradable, and token holders can do whatever they want with them. But if you really want to change the behavior of the token and add any restrictions, then this can be done by turning a regular asset into a smart asset. We have already considered smart accounts, whose behavior differs from ordinary accounts in that before sending a transaction from such an account, its script is executed and it must return <code>true</code>. Smart assets are very similar to smart accounts. In the same way, a script on Ride is added to the asset, which is executed for each operation with this token and must return <code>true</code> for the transaction to be considered valid. But there are several distinctive features of a smart asset.</p>
<h2 id="adding-a-script-to-an-asset">Adding a script to an asset</h2>
<p>The main difference between smart assets and smart accounts is that if a token is issued without a script, then it cannot be added to it later. This is done so that the creators of tokens do not have the ability to deceive users, for example, by sending them tokens, the circulation rules of which may change. It is also important to clarify that if a token is issued with a script and this script does not directly prohibit, then such a script can be updated. You can say that the owners of tokens can also cheat in this way, but in this case, users will at least see from the very beginning that the token is a smart asset and can mean it.</p>
<p>Another reason for the impossibility of adding a script to assets released without this is that the functionality of smart assets appeared in the third year of the life of the Waves blockchain, and to give simple tokens, which have been living on the network for several years, the ability to change the rules of the game on the go without considering opinions users, it would not be entirely correct.</p>
<p>But what if we want to issue a token, but have not yet written its script? It is enough to put <code>true</code> in the form of a script (or rather a compiled version of such a script in base64 format -<code> AwZd0cYf</code>) as a script. Such a script will not prohibit any operations with the token, but will allow you to update the script in the future and set the rules you need.</p>
<p>In Sections 5 (Transactions) and 6 (Ride), we will take a closer look at the specifics of setting a script for assets and the distinctive features of Ride for tokens.</p>
<h2 id="smart-asset-example">Smart asset example</h2>
<p>An example of a smart asset used in the Waves ecosystem is the Waves Reward Token, which was released by the Waves team and distributed to many platform users so that they can later transfer them to ambassadors (and only them) as a thank you for their help. The Waves team buys these tokens in the future. Thus, the most active ambassadors earn tokens from users and sell them to the Waves team. The WRT token code ensures that it can only be transferred to ambassadors whose list is administered by the Waves team and stored in one of their accounts.</p>
<h1 id="asset-and-dex-trading">Asset and DEX trading</h1>
<p>After the possibility of creating your own tokens appeared, it was logical to make it possible to trade them (or, to be more precise, exchange) without the participation of intermediaries. To do this, a matcher was created in Waves (from the English &quot;match&quot; - match, match), which for a long time was part of the node, disabled by default (it was enough to enable the <code>waves.matcher.enabled</code> flag in the node configuration), which is now distributed as a node extension.</p>
<h2 id="how-matcher-works">How matcher works</h2>
<p>The matcher accepts applications for exchanging tokens from users; in the Waves ecosystem, such applications are called Order. An example of such an &quot;order&quot; or &quot;intention&quot; of a user to make an exchange is presented below:</p>
<pre class="hljs"><code><div>{
  &quot;version&quot;: 3,
  &quot;senderPublicKey&quot;: &quot;FMc1iASTGwTC1tDwiKtrVHtdMkrVJ1S3rEBQifEdHnT2&quot;,
  &quot;matcherPublicKey&quot;: &quot;7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy&quot;,
  &quot;assetPair&quot;: {
    &quot;amountAsset&quot;: &quot;BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa&quot;,
    &quot;priceAsset&quot;: null
  },
  &quot;orderType&quot;: &quot;buy&quot;,
  &quot;amount&quot;: 150000000,
  &quot;timestamp&quot;: 1548660872383,
  &quot;expiration&quot;: 1551252872383,
  &quot;matcherFee&quot;: 300000,
  &quot;proofs&quot;: [
    &quot;YNPdPqEUGRW42bFyGqJ8VLHHBYnpukna3NSin26ERZargGEboAhjygenY67gKNgvP5nm5ZV8VGZW3bNtejSKGEa&quot;
  ],
  &quot;id&quot;: &quot;Ho6Y16AKDrySs5VTa983kjg3yCx32iDzDHpDJ5iabXka&quot;,
  &quot;sender&quot;: &quot;3PEFvFmyyZC1n4sfNWq6iwAVhzUT87RTFcA&quot;,
  &quot;price&quot;: 1799925005,
}
</div></code></pre>
<p>In addition to information about the sender, service fields and signature, each order contains information about which pair of tokens should be exchanged, the type of order (<code>buy</code> or<code> sell</code>), the expiration date of the order, the number of tokens to be exchanged and the price the user wants to exchange. Looking at the example above, you can understand that the user wants to exchange <code>Waves</code>, because<code> assetPair.priceAsset</code> is <code>null</code> and the order type is<code> buy</code>, for a token with assetId equal to <code>BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQca</code> and [] with the name https://wavesexplorer.com/tx/BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa) which can be found in the explorer.</p>
<p>The number of tokens for exchange is indicated as 150,000,000 (we always remember that Waves has 8 decimal places, so he actually wants to exchange 1.5 Waves) for Zcash at a price of 17.99925005 per unit (Zcash also has 8 decimal places). In other words, if there is a person willing to sell 1 Zchah token in exchange for 17.99925005 Waves no later than the specified expiration date (1551252872383 or 02/27/2019 @ 7:34 am UTC), then the exchange will be made.</p>
<p>Let's imagine that another user sent a counter order for the same pair with the following parameters:</p>
<pre class="hljs"><code><div>{
  &quot;version&quot;: 3,
  &quot;senderPublicKey&quot;: &quot;FMc1iASTGwTC1tDwiKtrVHtdMkrVJ1S3rEBQifEdHnT2&quot;,
  &quot;matcherPublicKey&quot;: &quot;7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy&quot;,
  &quot;assetPair&quot;: {
    &quot;amountAsset&quot;: &quot;BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa&quot;,
    &quot;priceAsset&quot;: null
  },
  &quot;orderType&quot;: &quot;sell&quot;,
  &quot;amount&quot;: 3000000000,
  &quot;timestamp&quot;: 154866085334,
  &quot;expiration&quot;: 1551252885334,
  &quot;matcherFee&quot;: 300000,
  &quot;proofs&quot;: [
    &quot;YNPdPqEUGRW42bFyGqJ8VLHHBYnpukna3NSin26ERZargGEboAhjygenY67gKNgvP5nm5ZV8VGZW3bNtejSKGEa&quot;
  ],
  &quot;id&quot;: &quot;Ho6Y16EFvFmyyZC1n4sfNWq6iwAVhzUT87RTFcAabXka&quot;,
  &quot;sender&quot;: &quot;3PAKDrySs5VTa983kjg3yCx32iDzDHpDJ5i&quot;,
  &quot;price&quot;: 1799925005,
}
</div></code></pre>
<p>The sender of this order wants to make a reverse exchange operation (<code>Zcash</code> -&gt;<code> Waves</code>) at the same price, but wants to exchange 30 Zcash.</p>
<p>Both orders are sent to one matcher with the public key <code>7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy</code>, which, after seeing the match of parameters (pair, price) and the validity of the signature and expiration date, will form an exchange transaction -<code> Exchange</code>. At the same time, the first order will be fully executed (all 1.5 Waves will be exchanged for Zcash), and the second will only partially wait for a suitable order for the exchange. An approximate scheme of work is shown in the figure:</p>
<p><img src="../../assets/4-4-1-how-dex-works.png" alt="How matching works" title="How matching workks"></p>
<p>We will look at an example of an <code>Exchange</code> transaction in the next chapter, which is devoted to transactions, let's now talk about the features of the matcher.</p>
<h2 id="matcher-functions">Matcher functions</h2>
<p>Matcher is the heart of Waves-based decentralized exchanges (DEXs), the most popular of which is waves.exchange. Let's take a look at how the matcher works and the whole decentralized exchange procedure.</p>
<p>The matcher accepts orders for the purchase or sale of tokens from everyone who wants them, stores them in the orderbook and, when a match is found, forms an exchange transaction and sends it to the blockchain (sends it to the node, which already adds to the block, directly exchanging tokens on user balances) ...</p>
<p>Let's describe the entire path for exchanging tokens:</p>
<ol>
<li>The user creates an order for the exchange, indicating a pair of tokens, the type of order (what he wants to exchange for), the exchange price, the number of tokens to exchange, validity period, the size of the commission for the matcher and to which matcher he wants to send his order.</li>
<li>The user signs the order and sends it to the matcher via API.</li>
<li>The matcher checks the validity of the order signature, the correctness of the specified dates, the commission specified by the user and the presence of tokens for exchange and commission on the user's balance (for this, he makes a request to the blockchain node).</li>
<li>If the exchange is made in a pair, where one or both tokens are smart assets, the matcher executes the asset script and considers the order as valid only upon receiving <code>true</code>. In case of receiving <code>false</code> or an exception, the matcher considers the order invalid and it is rejected.</li>
<li>If there is a counter-order in the orderbook, with which an exchange operation can be performed, the matcher generates an <code>Exchange</code> transaction, signs it and sends it to the blockchain node. If there was no suitable order in the order book, then the newly created order is added to the order book, where it will remain until a correct counter order is found or the order expires. It is worth noting that the exchange transaction is done on behalf of the match and with the signature of the match, and not on behalf of the users; accordingly, the commission for getting into the blockchain is paid by the matcher.</li>
<li>When the blockchain node receives an <code>Exchange</code> transaction, it validates it and the orders included in it (the exchange transaction includes the orders themselves too) and adds it to the block.</li>
<li>The state of account balances in the blockchain changes in accordance with the parameters of the <code>Exchange</code> transaction.</li>
</ol>
<h2 id="features-of-the-exchange-in-the-waves-blockchain">Features of the exchange in the Waves blockchain</h2>
<p>Decentralized exchange in Waves can be carried out without a matcher: two users can combine their orders in an <code>Exchange</code> transaction and send them to the network on behalf of a third account (or one of them), but in view of the inconvenience of this method, most exchange transactions are made using a matcher ...</p>
<p>Each individual matcher is a centralized entity and is controlled by one person or team, but why then do we call the exchange decentralized, and exchanges using the matcher - DEX? It is necessary to understand the main difference between ordinary centralized exchanges and DEX - control over user funds. Centralized exchanges have direct access to users' funds and their keys, so they can do whatever they want with them, while the matcher in Waves has access only to user intentions (orders) and cannot do anything with your tokens directly. The worst thing that a matcher can do is exchange at a not the best price available on the market or not complete an exchange transaction, although the counter order was in the order book.</p>
<p>Are there more decentralized solutions? Of course there are, there are completely decentralized exchanges, but with full decentralization, it is impossible to solve the problem of <a href="https://www.investopedia.com/terms/f/frontrunning.asp">front-running</a> blockchain nodes (in the Waves matcher scheme, nodes cannot implement such an attack, however, the matcher itself, which you trust).</p>
<p>Another feature of the exchange is that there are many matchers in the Waves ecosystem, but they do not exchange orders with each other. In fact, you trust one matchmaker when you send him your order. You trust him that he will perform the operation and he will do it honestly (for example, he will not let your order forward, which came later). It is this trust that prevents the exchange of orders between matchers: most likely, you are ready to trust one match, but you are not ready to trust all of them, because any of the many may turn out to be a &quot;pest&quot;.</p>
<p>The presence of centralized matching allows to achieve excellent throughput of thousands of generated <code>Exchange</code> transactions per second. The maximum possible speed of the matcher is now much higher than the throughput of the blockchain. Of course, trading in high-frequency trading (HFT) will not work, but there are a large number of bots that make hundreds of transactions per second. You can find examples of bots in Github, the most popular of which are <a href="https://docs.wavesplatform.com/en/building-apps/waves-api-and-sdk/examples/trading-bot">Scalping Bot</a> and <a href="https://github.com/PyWaves/BlackBot">Grid Trading Bot</a>.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-5-transactions">Chapter 5. Transactions</h1>
<p>Unlike many other blockchains where there are 1 (Bitcoin) or 2 (Ethereum) types of transactions, Waves at the time of this writing, there are 17 of them. Below is a diagram with a conditional division of all current types of transactions into categories:</p>
<p><img src="../../assets/5-1-1-transaction-types.png" alt="Waves transaction types" title="Waves Transaction Types"></p>
<p>You may already have questions: &quot;Why do transactions have such a chaotic numbering order? Why does the numbering not go sequentially within at least one category?&quot;</p>
<p>The fact is that transactions received numbers (aka IDs) as they were added to the protocol. In this part, we will consider transactions in the same order, that is, as they appear on the blockchain.</p>
<p>** Important: Many types of transactions have multiple versions, in this book we will look at the latest current versions on the Mainnet. **</p>
<p>Working with transactions is carried out using the node's API, which allows you to both receive information about transactions and send them. For you as a developer, a transaction in most cases will look like plain JSON:</p>
<pre class="hljs"><code><div>{
  &quot;senderPublicKey&quot;: &quot;CRxqEuxhdZBEHX42MU4FfyJxuHmbDBTaHMhM3Uki7pLw&quot;,
  &quot;amount&quot;: 1000000000, &quot;signature&quot;: &quot;4W9nWkfRm62rTQiuZX6bowWmDnz5n3cKhCZmLcYgivK53mBt3TzH6Z52fV6fXPSZn5bZc97rNo76usnNEoQcTHaq&quot;,
  &quot;fee&quot;: 100000,
  &quot;type&quot;: 4,
  &quot;version&quot;: 1,
  &quot;attachment&quot;: &quot;&quot;,
  &quot;sender&quot;: &quot;3NBVqYXrapgJP9atQccdBPAgJPwHDKkh6A8&quot;,
  &quot;feeAssetId&quot;: null,
  &quot;proofs&quot;: [&quot;4W9nWkfRm62rTQiuZX6bowWmDnz5n3cKhCZmLcYgivK53mBt3TzH6Z52fV6fXPSZn5bZc97rNo76usnNEoQcTHaq&quot;],
  &quot;assetId&quot;: null,
  &quot;recipient&quot;: &quot;3N78bNBYhT6pt6nugc6ay1uW1nLEfnRWkJd&quot;,
  &quot;feeAsset&quot;: null,
  &quot;id&quot;: &quot;8W9BkioPSWmPfDjcTFGaCy8vLEmcwkzJeSWno1s3Wra7&quot;,
  &quot;timestamp&quot;: 1485529237072,
  &quot;height&quot;: 56
}
</div></code></pre>
<p>The node itself stores transactions in a binary representation, not in the form of JSON, but at the time of an API request it encodes in JSON and sends it in that form. She also accepts it in the form of JSON. REST API nodes have the following useful endpoints:</p>
<p><code>GET / transactions / info / {id}</code> - get information about one transaction</p>
<p><code>GET / transactions / address / {address} / limit / {limit}</code> - get transactions at</p>
<p><code>GET / blocks / at / {height}</code> - get a list of all transactions in the block</p>
<h2 id="signature-of-transactions">Signature of transactions</h2>
<p>All transactions have an important field - <code>senderPublicKey</code>, which defines on behalf of which account the action is performed. For a transaction (&quot;action&quot;) to be considered valid, the signature of the transaction must match this public key (we are not considering cases with smart accounts now).</p>
<p>Cryptographic signature functions do not know anything about transactions, since they work with bytes. In the case of Waves, to sign transactions, it is necessary to arrange the bytes of the transaction in the correct order and transfer the signature functions along with the private key, as a result, we will receive the signature.</p>
<pre class="hljs"><code><div>signature = sign (transactionBytes, privateKey)
</div></code></pre>
<p>The correct byte order for each transaction is described in the documentation. Cryptography is outside the scope of this book, but you can find examples of correct byte ordering for different types of transactions in the <a href="https://github.com/wavesplatform/marshall">Marshall JS Library on Github</a>.</p>
<p>Signing transactions is usually done on the side of the client application, but the node itself is also able to sign transactions sent via the API. You need to understand that a node will sign such a transaction with the private key that is specified in its configuration. ** You cannot sign a transaction from an arbitrary sender using the REST API. ** Many developers think that they need to get an API key in order to sign their transaction using a node, but this will only work if there is a private key from of the account that should perform the action.</p>
<h2 id="transaction-lifecycle">Transaction lifecycle</h2>
<p>Let's take a look at all the stages of working with a transaction using the example of one action - sending a token from one user to another. We had a desire to send tokens from our account, from which we know the seed phrase (<code>A</code> in our example). We will send to an account with a public key <code>B</code>. First of all, we need to set the transaction parameters:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">amount</span>: <span class="hljs-number">300000000</span>,
  <span class="hljs-attr">recipient</span>: address (<span class="hljs-string">'B'</span>),
  <span class="hljs-attr">feeAssetId</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">assetId</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">attachment</span>: <span class="hljs-string">'TcgsE5ehTSPUftEquDt'</span>,
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000</span>,
}
</div></code></pre>
<p>We'll look at the transaction fields in the next part of this chapter. Now let's focus on the sequence of actions. To get the transaction along with the signature for our parameters, we use the <code>waves-transactions</code> library. To the <code>transfer</code> function, we pass the above parameters and the seed phrase. As a result, we get a JavaScript object that will contain all the fields we specified, as well as the signature in the <code>proofs</code> array, the transaction signing time (<code> timestamp</code>) and the sender's public key (account with the seed phrase <code>A</code>) in the<code> senderPublicKey</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> signedTransferTx = transfer (params, <span class="hljs-string">'A'</span>);
broadcast (signedTransferTx);
</div></code></pre>
<p>The library hides cryptography from us and the preparatory stage - the formation of the correct byte order for the signature. A signed transaction in the form of a JS object can be sent to any node that has an open API. The request is sent to <code>POST / transactions / broadcast</code> as JSON. The node will accept the transaction if there are no problems - the signature is valid, there are enough tokens on our account balance to complete the transaction, etc. A validated transaction will go to the UTX nodes where we sent the request, and it will then send information about this transaction to all the nodes with which it is connected.</p>
<h3 id="utx">UTX</h3>
<p>UTX is a list of transactions that are awaiting block hits. That is, someone sent them and the node accepted the transaction, but the transaction has not yet entered the block. Waves has certain quirks related to how these transactions are processed. How can a transaction end up in UTX? There are only 2 ways to do this:</p>
<ul>
<li>Someone will send a transaction to this node (using REST API or gRPC)</li>
<li>The node will receive a binary protocol transaction from another node in the network</li>
</ul>
<p>Ultimately, we can say that almost always transactions in the network come through the API, but it is not necessary that it was the API of this particular node.</p>
<p>A transaction that got into UTX has 2 options for further development of events:</p>
<ul>
<li>At some point in time, it will be added to the block by one of the miners</li>
<li>The transaction will become invalid and will be removed from UTX (and can never get into the block). A transaction can become invalid for several reasons - the state of the blockchain has changed (another transaction entered the block and changed the sender's balance, the script on the account or asset now returns <code>false</code>, etc.), the transaction lifetime has expired (now in the Waves network the timestamp` of the transaction may differ by -2 or +1.5 hours from the current blockchain time).</li>
</ul>
<p>The lifetime of a transaction can only expire because the network is 100% loaded. Nodes in Waves add transactions to the block one by one, starting with the most profitable for them (with the highest commission per byte). If at the time of sending our token transfer transaction, there were many transactions with a higher commission in UTX, then the miners will not add ours to the block, because the block has a size (1 MB) and number (6000 transactions) limit. Miners will produce blocks of maximum size with the most profitable transactions for them. If this continues for 90 minutes, then our transaction will become invalid. In fact, the sorting of a transaction in UTX by miners is done not only on the basis of the size of the commission, so we will consider the features of UTX operation in the future.</p>
<p>** For many newbies, it comes as a surprise that Waves blocks may contain transactions &quot;from the past&quot; and &quot;from the future&quot;, which have <code>timestamp</code> 120 minutes less or 90 minutes longer than the present time. ** In some cases, this must be taken into account when developing your applications.</p>
<h1 id="transaction-types">Transaction types</h1>
<p>To use the Waves blockchain as efficiently as possible and understand all of its capabilities, you need to understand the types of transactions and their features. In this section, we'll break down all types and discuss potential pitfalls.</p>
<p>There are two types of transactions in Waves that are currently not used and that you will definitely not use when working on the main network - <code>Genesis</code> and<code> Payment</code> transactions.</p>
<h2 id="genesis-transaction-type--1-deprecated">Genesis transaction (type = 1) [deprecated]</h2>
<p><code>Genesis</code> transactions were only in the [very first block of the blockchain] (http://nodes.wavesplatform.com/blocks/at/1) and were responsible for the distribution of pre-issued tokens (there were 100 million of them). Let's see what the genesis block looked like.</p>
<p>** Note: ** Many people confuse the <code>genesis</code> block and the<code> genesis</code> transaction. The <code>Genesis</code> block is the very first block in the blockchain network (in all blockchains it is customary to call it that), which differs from the rest of the blocks only by the absence of a reference to the previous block, since the previous block simply did not exist. The <code>Genesis</code> block contains the<code> genesis</code> transactions that are responsible for the initial distribution of issued Waves tokens. The very first block on the Waves network is shown below:</p>
<pre class="hljs"><code><div>{
  &quot;reference&quot;: &quot;67rpwLCuS5DGA8KGZXKsVQ7dnPb9goRLoKfgGbLfQg9WoLUgNY77E2jT11fem3coV9nAkguBACzrU1iyZM4B8roQ&quot;,
  &quot;blocksize&quot;: 500,
  &quot;signature&quot;: &quot;FSH8eAAzZNqnG8xgTZtz5xuLqXySsXgAjmFEC25hXMbEufiGjqWPnGCZFt6gLiVLJny16ipxRNAkkzjjhqTjBE2&quot;,
  &quot;totalFee&quot;: 0,
  &quot;nxt-consensus&quot;: {
    &quot;base-target&quot;: 153722867,
    &quot;generation-signature&quot;: &quot;11111111111111111111111111111111&quot;
  },
  &quot;fee&quot;: 0,
  &quot;generator&quot;: &quot;3P274YB5qseSE9DTTL3bpSjosZrYBPDpJ8k&quot;,
  &quot;transactionCount&quot;: 6,
  &quot;transactions&quot;: [
    {
      &quot;type&quot;: 1,
      &quot;id&quot;: &quot;2DVtfgXjpMeFf2PQCqvwxAiaGbiDsxDjSdNQkc5JQ74eWxjWFYgwvqzC4dn7iB1AhuM32WxEiVi1SGijsBtYQwn8&quot;,
      &quot;fee&quot;: 0,
      &quot;timestamp&quot;: 1465742577614,
      &quot;signature&quot;: &quot;2DVtfgXjpMeFf2PQCqvwxAiaGbiDsxDjSdNQkc5JQ74eWxjWFYgwvqzC4dn7iB1AhuM32WxEiVi1SGijsBtYQwn8&quot;,
      &quot;recipient&quot;: &quot;3PAWwWa6GbwcJaFzwqXQN5KQm7H96Y7SHTQ&quot;,
      &quot;amount&quot;: 9999999500000000
    },
    {
      &quot;type&quot;: 1,
      &quot;id&quot;: &quot;2TsxPS216SsZJAiep7HrjZ3stHERVkeZWjMPFcvMotrdGpFa6UCCmoFiBGNizx83Ks8DnP3qdwtJ8WFcN9J4exa3&quot;,
      &quot;fee&quot;: 0,
      &quot;timestamp&quot;: 1465742577614,
      &quot;signature&quot;: &quot;2TsxPS216SsZJAiep7HrjZ3stHERVkeZWjMPFcvMotrdGpFa6UCCmoFiBGNizx83Ks8DnP3qdwtJ8WFcN9J4exa3&quot;,
      &quot;recipient&quot;: &quot;3P8JdJGYc7vaLu4UXUZc1iRLdzrkGtdCyJM&quot;,
      &quot;amount&quot;: 100000000
    },
    {
      &quot;type&quot;: 1,
      &quot;id&quot;: &quot;3gF8LFjhnZdgEVjP7P6o1rvwapqdgxn7GCykCo8boEQRwxCufhrgqXwdYKEg29jyPWthLF5cFyYcKbAeFvhtRNTc&quot;,
      &quot;fee&quot;: 0,
      &quot;timestamp&quot;: 1465742577614,
      &quot;signature&quot;: &quot;3gF8LFjhnZdgEVjP7P6o1rvwapqdgxn7GCykCo8boEQRwxCufhrgqXwdYKEg29jyPWthLF5cFyYcKbAeFvhtRNTc&quot;,
      &quot;recipient&quot;: &quot;3PAGPDPqnGkyhcihyjMHe9v36Y4hkAh9yDy&quot;,
      &quot;amount&quot;: 100000000
    },
    {
      &quot;type&quot;: 1,
      &quot;id&quot;: &quot;5hjSPLDyqic7otvtTJgVv73H3o6GxgTBqFMTY2PqAFzw2GHAnoQddC4EgWWFrAiYrtPadMBUkoepnwFHV1yR6u6g&quot;,
      &quot;fee&quot;: 0,
      &quot;timestamp&quot;: 1465742577614,
      &quot;signature&quot;: &quot;5hjSPLDyqic7otvtTJgVv73H3o6GxgTBqFMTY2PqAFzw2GHAnoQddC4EgWWFrAiYrtPadMBUkoepnwFHV1yR6u6g&quot;,
      &quot;recipient&quot;: &quot;3P9o3ZYwtHkaU1KxsKkFjJqJKS3dLHLC9oF&quot;,
      &quot;amount&quot;: 100000000
    },
    {
      &quot;type&quot;: 1,
      &quot;id&quot;: &quot;ivP1MzTd28yuhJPkJsiurn2rH2hovXqxr7ybHZWoRGUYKazkfaL9MYoTUym4sFgwW7WB5V252QfeFTsM6Uiz3DM&quot;,
      &quot;fee&quot;: 0,
      &quot;timestamp&quot;: 1465742577614,
      &quot;signature&quot;: &quot;ivP1MzTd28yuhJPkJsiurn2rH2hovXqxr7ybHZWoRGUYKazkfaL9MYoTUym4sFgwW7WB5V252QfeFTsM6Uiz3DM&quot;,
      &quot;recipient&quot;: &quot;3PJaDyprvekvPXPuAtxrapacuDJopgJRaU3&quot;,
      &quot;amount&quot;: 100000000
    },
    {
      &quot;type&quot;: 1,
      &quot;id&quot;: &quot;29gnRjk8urzqc9kvqaxAfr6niQTuTZnq7LXDAbd77nydHkvrTA4oepoMLsiPkJ8wj2SeFB5KXASSPmbScvBbfLiV&quot;,
      &quot;fee&quot;: 0,
      &quot;timestamp&quot;: 1465742577614,
      &quot;signature&quot;: &quot;29gnRjk8urzqc9kvqaxAfr6niQTuTZnq7LXDAbd77nydHkvrTA4oepoMLsiPkJ8wj2SeFB5KXASSPmbScvBbfLiV&quot;,
      &quot;recipient&quot;: &quot;3PBWXDFUc86N2EQxKJmW8eFco65xTyMZx6J&quot;,
      &quot;amount&quot;: 100000000
    }
  ],
  &quot;version&quot;: 1,
  &quot;timestamp&quot;: 1460678400000,
  &quot;height&quot;: 1
}
</div></code></pre>
<p>You can see that there were 6 public keys-recipients of the newly issued Waves tokens. All transactions have the same <code>timestamp</code> and they were all free (the<code> fee</code> is zero) because there was nothing else to pay the <code>fee</code> at the time these transactions were created.</p>
<p>These transactions are not created manually, they are generated automatically by the special utility <code>genesis-generator</code>, which is in the node repository. You may need to do this if you want to launch your private blockchain. How to do this (and why) we will look at in one of the next chapters.</p>
<blockquote>
<p>Attentive readers may ask why <code>9999999500000000</code> tokens are sent in the very first transaction if only 100 million were issued? In Waves, all transactions are invoiced in minimal indivisible token units (fraction). The Waves token has 8 decimals, so the minimum unit is one hundred millionth. If the <code>amount</code> field of any transaction contains the value<code> 100000000</code> (10 ^ 8), this actually means one whole Waves token. In the case of a <code>genesis</code> transaction,<code> 9999999500000000</code> means 99,999,995 tokens or 9999999500000000 minimum units. Waves' smallest units are often referred to as WAVELET.</p>
</blockquote>
<h2 id="payment-transaction-type--2-deprecated">Payment transaction (type = 2) [deprecated]</h2>
<p>At the time of the launch of the Waves blockchain, only 2 types of transactions were implemented - the already considered type <code>genesis</code> and<code> payment</code>, which allowed transferring Waves tokens from one account to another. Examples of the <code>payment</code> transaction in JSON representation can be found in <a href="http://nodes.wavesplatform.com/blocks/at/2000">block 2000</a>.</p>
<pre class="hljs"><code><div>    {
      &quot;senderPublicKey&quot;: &quot;6q5VhGeTanU5T8vWx6Jka3wsptPKSSHA9uXHwdvBMTMC&quot;,
      &quot;amount&quot;: 10000000000,
      &quot;sender&quot;: &quot;3PGj6P4Mfzgo24i8cG3nhLU6uktF6s5LVCT&quot;,
      &quot;feeAssetId&quot;: null,
      &quot;signature&quot;: &quot;3gzk9QyfqQGvsU8A4zMMorpKTcFpdG7UtC4c5E7ds9MGMCMSyp6JZymQJoCjUSJQ8AaSWQDQwNmQ5F46ud4ofA5o&quot;,
      &quot;proofs&quot;: [
        &quot;3gzk9QyfqQGvsU8A4zMMorpKTcFpdG7UtC4c5E7ds9MGMCMSyp6JZymQJoCjUSJQ8AaSWQDQwNmQ5F46ud4ofA5o&quot;
      ],
      &quot;fee&quot;: 1,
      &quot;recipient&quot;: &quot;3P59ixWkqiEnL7RJoXtZewgbatKBZo8bG15&quot;,
      &quot;id&quot;: &quot;3gzk9QyfqQGvsU8A4zMMorpKTcFpdG7UtC4c5E7ds9MGMCMSyp6JZymQJoCjUSJQ8AaSWQDQwNmQ5F46ud4ofA5o&quot;,
      &quot;type&quot;: 2,
      &quot;timestamp&quot;: 1465865163143
    }
</div></code></pre>
<p>A <code>Payment</code> transaction can only send Waves tokens (not other ones issued on the platform) from one address to another. It became obsolete with the advent of <code>Transfer</code> transactions that can send both Waves tokens and custom tokens, so now<code> Payment</code> is no longer used anywhere.</p>
<h2 id="issue-transaction-type--3">Issue transaction (type = 3)</h2>
<p>In the section about tokens, we have already discussed in detail how to release your asset using the <code>Issue</code> transaction, so now I will not dwell on how to use it. One has only to say that the distinctive feature of the <code>Issue</code> transaction is that there are 2 fundamentally different options for issuing a token:</p>
<ul>
<li>issuance of a unique token (aka non-fungible token, NFT)</li>
<li>issue of a regular token</li>
</ul>
<p>Issuing a unique token differs in that the parameters <code>amount</code>,<code> reissuable</code>, <code>decimals</code> must have predefined values ​​-<code> 1</code>, <code>false</code> and<code> 0</code>, respectively. If this condition is met, the minimum commission will be 0.001 Waves. If these parameters differ (at least one of the parameters), then the token is considered normal and the minimum issue commission will be 1 Waves.</p>
<p>An example JSON representation of the <code>Issue</code> transaction is shown below:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: &quot;7nSKRN4XZiD3TGYsMRQGQejzP7x8EgiKoG2HcY7oYv6r&quot;,
    quantity: 210000000,
    signature: &quot;3Vj8M9tkVZmnjdYAKKN3GzAtV9uQDX5hhgUfXQDdvZsk2AmvqQum3oGBJqdjALVHXX2ibLAZHeruwjNXR46WgBnm&quot;,
    fee: 100000000,
    description: &quot;&quot;,
    type: 3,
    version: 1,
    reissuable: true,
    sender: &quot;3PAJ6bw7kvSPf6Q9kAgfSLzmpFspZmsi1ki&quot;,
    feeAssetId: null,
    proofs: [
&quot;3Vj8M9tkVZmnjdYAKKN3GzAtV9uQDX5hhgUfXQDdvZsk2AmvqQum3oGBJqdjALVHXX2ibLAZHeruwjNXR46WgBnm&quot;
],
    script: null,
    assetId: &quot;oWgJN6YGZFtZrV8BWQ1PGktZikgg7jzGmtm16Ktyvjd&quot;,
    decimals: 1,
    name: &quot;ihodl&quot;,
    id: &quot;oWgJN6YGZFtZrV8BWQ1PGktZikgg7jzGmtm16Ktyvjd&quot;,
    timestamp: 1528867061493,
    height: 1039500
}
</div></code></pre>
<blockquote>
<p>Important: if a token is issued without a script, then it cannot be added to it later, so if you want to add a script in the future, but do not have this script yet, then specify <code>AwZd0cYf</code> as a script (<code> true</code> in the compiled base64 version)</p>
</blockquote>
<h2 id="tranfer-transaction-type--4">Tranfer transaction (type = 4)</h2>
<p>The <code>Tranfser</code> transaction came to replace the<code> Payment</code> transaction, because <code>Payment</code> did not allow sending tokens created with the<code> Issue</code> transaction. Currently, the <code>Transfer</code> transaction is the most frequent one according to <a href="http://dev.pywaves.org/txs/">dev.pywaves.org</a> and accounts for about 70% of transactions on the network. Sending a <code>Transfer</code> transaction is similar to sending most token-related transactions:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> {transfer} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>);

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>;

<span class="hljs-comment">// Transfering 3 WAVES</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">amount</span>: <span class="hljs-number">300000000</span>,
  <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs'</span>,
  <span class="hljs-attr">feeAssetId</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">assetId</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">attachment</span>: <span class="hljs-string">'TcgsE5ehTSPUftEquDt'</span>,
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000</span>,
}

<span class="hljs-keyword">const</span> signedTransferTx = transfer (params, seed);
broadcast (signedTransferTx);

</div></code></pre>
<p>The example above will generate a transaction from the account with the seed phrase <code>example seed phrase</code>, automatically substitute additional fields (<code> timestamp</code>, <code>senderPublicKey</code>,<code> proofs</code>) into the created transaction, sign it with a private key from the specified seed phrase and add the transaction signature to the array <code>proofs</code>.</p>
<p>The recipient of the transaction is the address <code>3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs</code>, and we send Waves tokens. To calculate how many tokens are sent, we need to remember that the transaction indicates the value of <code>amount</code> in the minimum fractions of this token. To get it in whole units, you need to divide <code>300000000</code> by<code> 10 ^ decimals</code>. <code>300000000 / (10 ^ 8) = 3</code>.</p>
<p>The <code>Transfer</code> transaction has several interesting features:</p>
<ul>
<li>It supports sponsoring transactions, so in the field <code>feeAssetId</code> you can specify the<code> assetId</code> of some token that you have and is sponsored by the creator, then you will pay a fee in this token. In our case, <code>null</code> is specified, so the commission will be paid in Waves tokens.</li>
<li>The transaction has an <code>attachment</code> field that can contain up to 140 bytes of information. In the <code>waves-transactions</code> library, the<code> attachment</code> value must be passed in the <code>base58</code> format, so you see<code> TcgsE5ehTSPUftEquDt</code>, although in the &quot;human&quot; representation it can be read as <code>HelloWavesBook</code>.</li>
</ul>
<p>The <code>Transfer</code> transaction allows you to specify 0 in the<code> amount</code> field, that is, to send 0 tokens to the recipient. Some users use this feature to send <code>Transfer</code> transactions as&quot; messages &quot;or events that may trigger other actions outside the blockchain.</p>
<p>An example of a <code>Transfer</code> transaction is shown below:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: &quot;CXpZvRkJqBfnAw3wgaRbeNjtLJcithoyQQQSzGQZRF3x&quot;,
    amount: 32800000000,
    signature: &quot;4cR2NAor9WjeTbysg2QMerkgymc5RLrX8PPjdXkUkWEc7BFBKMCCj8RKF7X1UchbvtEGoqGyQh62MDq5KoXsnCzg&quot;,
    fee: 100000,
    type: 4,
    version: 1,
    attachment: &quot;&quot;,
    sender: &quot;3P4FoAakEyk78TxUBcXH4uZXLaSE5BiDgjz&quot;,
    feeAssetId: null,
    proofs: [
&quot;4cR2NAor9WjeTbysg2QMerkgymc5RLrX8PPjdXkUkWEc7BFBKMCCj8RKF7X1UchbvtEGoqGyQh62MDq5KoXsnCzg&quot;
],
    assetId: null,
    recipient: &quot;3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZBg&quot;,
    feeAsset: null,
    id: &quot;JAutkv1Nk4xVrkb4fkacS4451VvyHC3iJtEDfBRD7rwr&quot;,
    timestamp: 1528867058828,
    height: 1039500
}
</div></code></pre>
<h2 id="reissue-transaction-type--5">Reissue transaction (type = 5)</h2>
<p>If, when issuing a token using the <code>Issue</code> transaction, set the<code> reissuable</code> flag to <code>true</code>, then the creator of the token gets the opportunity to reissue the token. The history of <code>reissuable</code> transactions in Waves is a bit strange, as you can find tokens on the blockchain that had the<code> reissuable</code> flag equal to <code>false</code> at the time of creation, but were reissued. These tokens was only 4, so their assetId: <code>6SGeUizNdhLx8jEVcAtEsE7MGPHGYyvL2chdmPxDh51K</code>,<code> UUwsxTvvG7LiN7yaAKvNU48JHcSwQ3q1HvsXyAgc9fL</code>, <code>3DhpxLxUrotfXHcWKr4ivvLNVQUueJTSJL5AG4qB2E7U</code>,<code> CH1LNr9ASLVqSHDb482ZzSA5rBVLDtF5QbfECGgwE8bh</code>. This became possible thanks to a bug in the node's code, which allowed re-issuing non-reissued tokens. Don't be surprised if you find reissued <code>non-reissuable</code> tokens in the history of mainnet Waves.</p>
<p>An example of a <code>Reissue</code> transaction is shown below:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: &quot;4X2Fv5XaDwBj2hjRghfqmsQDvBHqSa2zBUgZPDgySSJG&quot;,
    quantity: 10000000000000000,
    signature: &quot;5nNrLV46rVzQzeScz3RmZF4rzaV2XaSjT9kjtHoyrBzAj3iVZM9Gy6t5Paho7xRx9dyqzj1AKyWYQsgL2nFa7jYU&quot;,
    fee: 1000000,
    type: 5,
    version: 1,
    reissuable: true,
    sender: &quot;3P6ms9EotRX8JwSrebeTXYVnzpsGCrKWLv4&quot;,
    feeAssetId: null,
    chainId: null,
    proofs: [
&quot;5nNrLV46rVzQzeScz3RmZF4rzaV2XaSjT9kjtHoyrBzAj3iVZM9Gy6t5Paho7xRx9dyqzj1AKyWYQsgL2nFa7jYU&quot;
],
    assetId: &quot;AC3KZWmywTEYrcQwpjg4sQiWxkZ2TZmv81JAvDmsoQvy&quot;,
    id: &quot;6qd8QbnFrKEibTr26JyNh1hc4KaafGQYStyShtXdNk3v&quot;,
    timestamp: 1528733511933,
    height: 1037381
}
</div></code></pre>
<h2 id="burn-transaction-type--6">Burn transaction (type = 6)</h2>
<p>A token burn transaction allows you to burn any number of tokens of the same type. The only condition is that these tokens must be on your account and the token script must not prohibit burning.</p>
<p>An example of a <code>Burn</code> transaction is shown below:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: &quot;EhuzuzEWHhZGo1th6YGy34AecoRP4sVi863xXCQUmgUT&quot;,
    amount: 10000000000,
    signature: &quot;5HdfqY47Pm4G6h67K9ZpN7jQ4NKr9hsNsmTAtyFD5FhBPr3J9kNxodhYn6hMSieKE7UmYZvSohv7XJpyjKvGCfTC&quot;,
    fee: 100000,
    type: 6,
    version: 1,
    sender: &quot;3PAjApsrjJWGmRDbGo65gGgrN2hFJroAZDC&quot;,
    feeAssetId: null,
    proofs: [
&quot;5HdfqY47Pm4G6h67K9ZpN7jQ4NKr9hsNsmTAtyFD5FhBPr3J9kNxodhYn6hMSieKE7UmYZvSohv7XJpyjKvGCfTC&quot;
],
    assetId: &quot;56w2Jbj8MGKwSWyTXvCzkqKKHiyX7C2zrgCQb2CEwM52&quot;,
    id: &quot;EzeiYzYPwyJNEgofQrE23rpqaYERjUSnCaXZ84vUDoec&quot;,
    timestamp: 1528814759445,
    height: 1038647
}
</div></code></pre>
<h2 id="exchange-transaction-type--7">Exchange transaction (type = 7)</h2>
<p>In the previous chapter, we talked a lot about the token exchange procedure, the work of the order matcher and the <code>Exchange</code> transactions. Among other things, they touched upon the topic that a transaction contains orders, and that is why this transaction is the most complex in JSON representation:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: &quot;7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy&quot;,
    amount: 74,
    signature: &quot;2p1BS5BPkMW4C3C6vL8MsrQ8CBQRQqDoYieaZcxeMAq5zvAsm6T4N5DDN6MfPx8emVmbHfibZRsok2v2Ss45e1mj&quot;,
    fee: 300000,
    type: 7,
    version: 1,
    sellMatcherFee: 63610,
    sender: &quot;3PJaDyprvekvPXPuAtxrapacuDJopgJRaU3&quot;,
    feeAssetId: null,
    proofs: [
&quot;2p1BS5BPkMW4C3C6vL8MsrQ8CBQRQqDoYieaZcxeMAq5zvAsm6T4N5DDN6MfPx8emVmbHfibZRsok2v2Ss45e1mj&quot;
],
    price: 103526336,
    id: &quot;GHKhG3CWNfXAPWprk9bHSE4rxN6QfNDe3d3rZGaDLWhm&quot;,
    order2: {
    version: 1,
    id: &quot;5C8qLi2eK92CJtBqXbL9pMuQ2R9VpRMaJ6NGACfxMBCn&quot;,
    sender: &quot;3P7DsCo8TN5t1PNz45exhLe6vKFkTQJYrNb&quot;,
    senderPublicKey: &quot;6mYVd69bZsLYW9gpxu3Vjneaf4xpZPnKYiLFuGXJQKQw&quot;,
    matcherPublicKey: &quot;7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy&quot;,
    assetPair: {
    amountAsset: &quot;725Yv9oceWsB4GsYwyy4A52kEwyVrL5avubkeChSnL46&quot;,
    priceAsset: null
},
    orderType: &quot;sell&quot;,
    amount: 349,
    price: 103526336,
    timestamp: 1528814695617,
    expiration: 1528814995617,
    matcherFee: 300000,
    signature: &quot;4DSQvXBLA4U4mtTRzjz62Ci757TZsys8phWbfnCmwvrKDhYFfB8kEknJ9fknAfWkJua7wN4EPbdrSLPgRShaxTsj&quot;,
    proofs: [
&quot;4DSQvXBLA4U4mtTRzjz62Ci757TZsys8phWbfnCmwvrKDhYFfB8kEknJ9fknAfWkJua7wN4EPbdrSLPgRShaxTsj&quot;
]
},
    order1: {
    version: 1,
    id: &quot;Eiy6wSzu3aZu3V5Mi7VN54Vmu5KQE18nEQ3j5bJU2WYK&quot;,
    sender: &quot;3PMFLMN9GG1coCXRn26vUmF2vtCCd4RDWRR&quot;,
    senderPublicKey: &quot;Dk3r1HwVK1Ktp3MJCoAspNyyRpLFcs2h5SKsoV5F3Rvd&quot;,
    matcherPublicKey: &quot;7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy&quot;,
    assetPair: {
    amountAsset: &quot;725Yv9oceWsB4GsYwyy4A52kEwyVrL5avubkeChSnL46&quot;,
    priceAsset: null
},
    orderType: &quot;buy&quot;,
    amount: 74,
    price: 103526336,
    timestamp: 1528814695596,
    expiration: 1528814995596,
    matcherFee: 300000,
    signature: &quot;5kM8NRVxu4xtDUwz7GCVqyHbeszjXheJn1f7Q5Kpa4zdkeXe8k1kNENAU1YVNXyxNjMHCwtY9mwUkBpZWPo2CHWf&quot;,
    proofs: [
&quot;5kM8NRVxu4xtDUwz7GCVqyHbeszjXheJn1f7Q5Kpa4zdkeXe8k1kNENAU1YVNXyxNjMHCwtY9mwUkBpZWPo2CHWf&quot;
]
},
    buyMatcherFee: 300000,
    timestamp: 1528814695635,
    height: 1038644
}
</div></code></pre>
<p>As you can see, the transaction contains the fields <code>order1</code> (an order of the<code> buy</code> type) and <code>order2</code> (an order of the<code> sell</code> type). There is also a signature in the <code>proofs</code> array, which is the signature of the matcher (not the order senders!), The size of the commission for the match (<code> sellMatcherFee</code>), the commission for the node that will mine the block (the <code>fee</code> field for the entire transaction and not for the order ).</p>
<p>The values ​​of the <code>matcherPublicKey</code> fields in the orders must match the<code> senderPublicKey</code> field for the <code>Exchange</code> transaction, which ensures that no other matcher can perform an exchange operation using these orders.</p>
<p>Forming an <code>Exchange</code> transaction in most cases is not necessary for users and developers, therefore it is not supported in many libraries for different programming languages. Another thing is orders, the formation of which is necessary for bots and many user interfaces. Formation of an order using <code>waves-tranasctions</code> does not fundamentally differ from the formation of a transaction:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {order} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'b716885e9ba64442b4f1263c8e2d8671e98b800c60ec4dc2a27c83e5f9002b18'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">amount</span>: <span class="hljs-number">100000000</span>, <span class="hljs-comment">// 1 waves</span>
  <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">// for 0.00000010 BTC</span>
  <span class="hljs-attr">priceAsset</span>: <span class="hljs-string">'8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS'</span>,
  <span class="hljs-attr">matcherPublicKey</span>: <span class="hljs-string">'7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy'</span>,
  <span class="hljs-attr">orderType</span>: <span class="hljs-string">'buy'</span>
}


<span class="hljs-keyword">const</span> signedOrder = order (params, seed)
</div></code></pre>
<p>Please note that unlike the examples with transactions, the example does not use the <code>broadcast</code> function to send the transaction, because the<code> broadcast</code> sends the transaction to the node, and we need to send the order to the matcher. You can find information about the matcher API in the <a href="https://docs.waves.exchange/en/waves-matcher/matcher-api">waves.exchange documentation</a>, since Waves.exchange works on the basis of the matcher.</p>
<h2 id="lease-and-lease-cancel-transactions-types-8-and-9">Lease and Lease Cancel transactions (types 8 and 9)</h2>
<p>At the very beginning of this book, we touched on the topic of leasing a little, which allows you to lease your tokens to other nodes &quot;for rent&quot; to generate blocks. To do this, you need to send a transaction of type <code>Lease</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {lease} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">amount</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs'</span>,
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000</span>
}

<span class="hljs-keyword">const</span> signedLeaseTx = lease (params, seed)
broadcast (signedLeaseTx);
</div></code></pre>
<p>As you can see, the transaction is extremely simple, we indicate the recipient in the <code>recipient</code> field in the form of an address or an alias (we'll talk about them below) and the amount we want to lease. It should be borne in mind that these tokens will participate in mining only 1000 blocks after they are leased.</p>
<p>The sender of the lease can cancel the lease at any time, again gaining access to them for trading, transfers or mining at their address. To do this, you need to send the transaction <code>LeaseCancel</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {cancelLease} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">leaseId</span>: <span class="hljs-string">'2fYhSNrXpyKgbtHzh5tnpvnQYuL7JpBFMBthPSGFrqqg'</span>,
  <span class="hljs-attr">senderPublicKey</span>: <span class="hljs-string">'3SU7zKraQF8tQAF8Ho75MSVCBfirgaQviFXnseEw4PYg'</span>, <span class="hljs-comment">// optional, by default derived from seed</span>
  <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">Date</span>.now (), <span class="hljs-comment">// optional</span>
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000</span>, <span class="hljs-comment">// minimal value</span>
  <span class="hljs-attr">chainId</span>: <span class="hljs-string">'W'</span> <span class="hljs-comment">// optional</span>
}

<span class="hljs-keyword">const</span> signedCancelLeaseTx = cancelLease (params, seed)
broadcast (signedCancelLeaseTx);
</div></code></pre>
<p>A lease cancellation transaction requires the transfer of the <code>ID</code> of the lease transaction. You can only cancel the entire lease transaction. For example, if you lease 1000 Waves to any node of one transaction, you will not be able to withdraw part of this amount - it can only be canceled in its entirety.</p>
<p>Please also note that this transaction specifies the <code>chainId</code>, while in the lease sending transaction, this is not required. Try to guess why.</p>
<blockquote>
<p>The answer is simple: in the lease sending transaction there is a <code>recipient</code> field, where the address is indicated (which already contains the chainId in itself), and in the lease cancellation transaction there is no<code> recipient</code> field, therefore, to make it impossible to send the same transactions in different networks, you have to specify the network byte. But if you use the <code>waves-transactions</code> library, then it will substitute the network byte for the Mainnet itself to simplify development and make your code cleaner and easier.</p>
</blockquote>
<p>Another difference between canceling a lease and sending it on lease is that the cancellation takes effect as soon as it enters the blockchain, without waiting for 1000 blocks.</p>
<h2 id="alias-%E2%80%8B%E2%80%8Btransaction-type--10">Alias ​​transaction (type = 10)</h2>
<p>Waves has a unique feature that many other blockchains do not have - the presence of aliases. It is sometimes extremely inconvenient to use addresses for transactions, they are long and impossible to remember, so each account can create aliases for itself. Alias ​​can be simple and easy to remember. In any transaction on the Waves network, in the <code>recipient</code> field, you can specify not only the address, but also the alias.</p>
<p>Ethereum has a slightly similar concept of ENS, which is built on the principles of DNS, with different levels (namespace) and management through smart contracts. In Waves, aliases are part of the protocol and all are in the global namespace, without division into domains and subdomains. One account can create an unlimited number of aliases by sending a special type of transaction:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {alias} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">alias</span>: <span class="hljs-string">'new_alias'</span>,
  <span class="hljs-attr">chainId</span>: <span class="hljs-string">'W'</span>
}

<span class="hljs-keyword">const</span> signedAliasTx = alias (params, seed)
broadcast (signedAliasTx)
</div></code></pre>
<p>Alias ​​can consist of:</p>
<ul>
<li>letters of the Latin alphabet in lower case</li>
<li>numbers</li>
<li>points</li>
<li>underscores</li>
<li>hyphen characters</li>
<li>signs <code>@</code></li>
</ul>
<p>The alias must be between 4 and 30 characters long. The problem with aliases on the Waves network is that they are all in the global space and cannot be repeated, so there are accounts with more than 2,000 aliases - a kind of cybersquatting in the blockchain.</p>
<h2 id="mass-transfer-transaction-type--11">Mass transfer transaction (type = 11)</h2>
<p>At the dawn of its history, Waves was known as a blockchain with very easy token issuance, and the community's natural desire was to simplify the next step of many token issuance campaigns - distributing tokens to recipients. To meet this demand, a transaction was created that allows you to send tokens from one address to many. There are only 2 restrictions - there can be no more than 100 recipients, and only 1 type of token is sent to all of them (you cannot make a <code>MassTransfer</code> and send the<code> A</code> token to the first half of the addresses, and <code>B</code> to the second).</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {massTransfer} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">transfers</span>: [
    {
      <span class="hljs-attr">amount</span>: <span class="hljs-number">100</span>,
      <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs'</span>,
    },
    {
      <span class="hljs-attr">amount</span>: <span class="hljs-number">200</span>,
      <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3PPnqZznWJbPG2Z1Y35w8tZzskiq5AMfUXr'</span>,
    },
  ],
  <span class="hljs-comment">// senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">// timestamp: Date.now (),</span>
  <span class="hljs-comment">// fee: 100000 + transfers.length * 50000,</span>
}

<span class="hljs-keyword">const</span> signedMassTransferTx = massTransfer (params, seed);
broadcast (signedMassTransferTx);
</div></code></pre>
<p>In addition to the convenience of working with such a transaction, compared to sending 100 transactions of the <code>Transfer</code> type, such a transaction is also cheaper. If the minimum commission for <code>Transfer</code> is 0.001 Waves (100000 Wavelet), then the minimum commission for<code> MassTransfer</code> is calculated by the formula:</p>
<p><code>100000 + transfers.length * 50000</code></p>
<p>That is, sending 100 <code>Transfer</code> transactions will cost us 0.1 Waves, while sending one<code> MassTransfer</code> with 100 recipients in just 0.051 Waves is almost 2 times cheaper.</p>
<h2 id="data-transaction-type--12">Data transaction (type = 12)</h2>
<p>A feature of Waves that makes it an extremely convenient blockchain for working with data is the presence of <code>Data</code> transactions, which appeared in April 2018 and made it possible to write data to the blockchain in a very convenient format.</p>
<p>With the introduction of <code>Data</code> transactions, each account now has a key-value storage, into which you can write data of four types: strings, numbers, boolean values ​​and byte arrays.</p>
<p>Account storage does not have a limit on the total size of data that can be written there, but there are limits on:</p>
<ul>
<li>the size of one transaction for writing data to the storage is not more than 140 kilobytes. The transaction fee depends on the size of the transaction and is calculated using the formula <code>100000 + bytes.length * 100000</code>.</li>
<li>data size per key no more than 32 kilobytes</li>
<li>key size no more than 100 characters. Keys in the store can only be UTF-8 strings.</li>
</ul>
<p>Let's see how to write data using the JavaScript library:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {data} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">data</span>: [
    {<span class="hljs-attr">key</span>: <span class="hljs-string">'integerVal'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>},
    {<span class="hljs-attr">key</span>: <span class="hljs-string">'booleanVal'</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>},
    {<span class="hljs-attr">key</span>: <span class="hljs-string">'stringVal'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'hello'</span>},
    {<span class="hljs-attr">key</span>: <span class="hljs-string">'binaryVal'</span>, <span class="hljs-attr">value</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]},
  ],
  <span class="hljs-comment">// senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">// timestamp: Date.now (),</span>
  <span class="hljs-comment">// fee: 100000 + bytes.length * 100000</span>
}

<span class="hljs-keyword">const</span> signedDataTx = data (params, seed);
broadcast (signedDataTx);

</div></code></pre>
<p>It should be understood that the state of the storage with all the keys and values ​​can be read by any user, moreover, the value for any key is available to all smart contracts on the network, be it a decentralized application, smart asset or smart account.</p>
<p>Key data can be rewritten an unlimited number of times, unless otherwise specified in the account contract. In the future, we will consider how to implement read-only pairs on an account that can be written only once and cannot be changed or deleted.</p>
<p>Many users expect that assets also have their own key-value stores, but this is not the case. Only an account has such storage, so if you need to record data for use by an asset, write to the account that issued the token. You can also write to any other account, because you can read any keys of any accounts in the code of your smart asset.</p>
<p>Another frequent question is &quot;Can a key be deleted from the repository?&quot; Until recently, this was not possible, but with the release of the Ride programming language version 4, it becomes possible. To avoid confusing both Ride and transactions for now, let's defer reviewing the Ride code until the next chapter. Better now let's talk about getting data from the account storage. This can be done using a REST request to the node's API:</p>
<ol>
<li>The endpoint <code>/ addresses / data / {address}? Matches = {regexp}</code> allows you to get all data from the repository, if necessary, filtering keys by the regular expression passed as the parameter <code>matches</code>. Filtering by values ​​is not yet supported in the node.</li>
<li>The endpoint <code>/ addresses / data / {address} / {key}</code> allows you to get the value of one key in the storage of one account.</li>
</ol>
<p>There are additional methods in the <code>waves-transactions</code> library that allow you to do this without having to write the logic for sending a request to the API yourself. Below is an example of getting the entire storage state and value by one key:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {nodeInteractions} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> address = <span class="hljs-string">'3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs'</span>

<span class="hljs-keyword">const</span> wholeStorage = <span class="hljs-keyword">await</span> accountData (address);
<span class="hljs-keyword">const</span> oneKeyValue = <span class="hljs-keyword">await</span> accountDataByKey (address, <span class="hljs-string">"demoKey"</span>);

<span class="hljs-built_in">console</span>.log (wholeStorage, oneKeyValue);

</div></code></pre>
<p>As you can see, everything is quite simple. The Waves API node has several features, some of which it would be good to know before starting work, so that at the most inopportune moment you do not get an error at the time of your code execution. These features of work, I would include the following:</p>
<ol>
<li>The node is designed primarily to support the operation of the blockchain, and not to work optimally with the API, therefore, requests for the entire storage for accounts with a large amount of data can lead to problems. I would never recommend anyone to request the entire state of the account, and if you do this, you are most likely doing something wrong.</li>
<li>The node returns the results in JSON, but there is no way to transfer an array of bytes in JSON, therefore, unlike other data types (strings, numbers and boolean values), they are encoded in the <code>base64</code> representation. In fact, when writing data like an array of bytes to the blockchain using <code>waves-transactions</code>, it also converts the bytes to a<code> base64</code> string and sends it, and not an array of bytes in the form of numbers or zeros and ones. For example, this is how the generated transaction looks for sending to the API using the <code>POST</code> request:</li>
</ol>
<pre class="hljs"><code><div>
{
  &quot;type&quot;: 12,
  &quot;version&quot;: 1,
  &quot;senderPublicKey&quot;: &quot;3SU7zKraQF8tQAF8Ho75MSVCBfirgaQviFXnseEw4PYg&quot;,
  &quot;fee&quot;: 100000,
  &quot;timestamp&quot;: 1592905798005,
  &quot;proofs&quot;: [
    &quot;KAQ9jhokgsZ8akvBbHjA8nDjR2PedkRvWZqf9ySRqjWi7dFXBpHga12CirpGeHJ3d4ATT92raZzqv2xbLetrCdZ&quot;
  ],
  &quot;id&quot;: &quot;6wHqcdQeZpYWLxHj9nC7YpT7WBzpzNyrXxWZHxVCpViz&quot;,
  &quot;data&quot;: [
    {
      &quot;type&quot;: &quot;integer&quot;,
      &quot;key&quot;: &quot;integerVal&quot;,
      &quot;value&quot;: 1
    },
    {
      &quot;type&quot;: &quot;boolean&quot;,
      &quot;key&quot;: &quot;booleanVal&quot;,
      &quot;value&quot;: true
    },
    {
      &quot;type&quot;: &quot;string&quot;,
      &quot;key&quot;: &quot;stringVal&quot;,
      &quot;value&quot;: &quot;hello&quot;
    },
    {
      &quot;type&quot;: &quot;binary&quot;,
      &quot;key&quot;: &quot;binaryVal&quot;,
      &quot;value&quot;: &quot;base64: AQIDBA ==&quot;
    }
  ]
}

</div></code></pre>
<p>As a DevRel at Waves, I received a lot of questions about the potentially uncontrolled growth of blockchain size due to account storage. Many people, especially those who have experience with other blockchains, are confused by the fact that it is possible to record a lot of data at a fixed and fairly low price, as well as the scalability of such a solution. In some cases (especially long-term storage), the Waves blockchain can be more cost effective than Amazon S3 storage, potentially dangerous for network scalability. There really is no simple answer to this question, while the size of the Waves blockchain is about 40 gigabytes (not ~ 2.8 TB as in Ethereum), so the problem is not relevant, but the ease of writing allows you to make a &quot;blockchain for people&quot;, which we talked about at the very beginning books. The problem will become relevant only if the popularity of the Waves blockchain grows rapidly, but in this case the price of tokens will also grow, respectively, the cost of storage will also, which will lead to fewer people willing to write large amounts of data to the blockchain. Where technology cannot completely solve the problem, the economy comes to the rescue, which will happen if popularity grows.</p>
<h2 id="setscript-transaction-type--13">SetScript transaction (type = 13)</h2>
<p>We indirectly touched on the transactions of the SetScript type when we talked about smart accounts. We describe the logic of the behavior of a smart account and decentralized applications using the Ride language, which is compiled into a <code>base64</code> representation in one of the available ways (JS library<code> ride-js</code>, API nodes, Java package in Maven, online IDE, plugin for Visual Studio Code or console utility <code>Surfboard</code>) and sent as part of the<code> SetScript</code> transaction:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {setScript} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE in base64 representation</span>
  <span class="hljs-comment">// senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">// timestamp: Date.now (),</span>
  <span class="hljs-comment">// fee: 100000,</span>
  <span class="hljs-comment">// chainId: 'W'</span>
}

<span class="hljs-keyword">const</span> signedSetScriptTx = setScript (params, seed)
broadcast (signedSetScriptTx);
</div></code></pre>
<p>The <code>SetScript</code> transaction is used only for accounts to make Smart Accounts or a decentralized application (dApp) out of them, but not for tokens. Installing a script using a <code>SetScript</code> transaction changes the behavior of an account, not only in terms of which transactions will go to the blockchain, but also in terms of fees. A smart account pays 0.004 Waves more for each type of transaction compared to a regular account.</p>
<p>To turn a smart account into a regular account without a script, you need to send a <code>SetScript</code> transaction with the<code> script</code> parameter equal to <code>null</code>. But not every smart account can become regular accounts again. The smart account script can explicitly prohibit making a <code>SetScript</code> transaction or impose other restrictions.</p>
<h2 id="setsponsorship-transaction-type--14">SetSponsorship transaction (type = 14)</h2>
<p>We discussed the specifics of transaction sponsorship and the SetSponsorship example of a transaction in <a href="../../ections/4-Tokens/4-2-sponsorship.md">Chapter 4</a>, but let's briefly recall the main point.</p>
<p>Create a token has the ability to send a transaction that includes sponsoring transactions using that token as a commission. Users will pay commission in token, but since miners always receive commission only in Waves, Waves will be debited from the account that issued the token.</p>
<ul>
<li>The user pays a commission for the transaction with a sponsored token (for example, he sends 10 tokens, additionally pays 1 token in the form of a commission, as a result, 11 tokens are debited from his account)</li>
<li>The creator of the token receives a commission in his token (1 in our example)</li>
<li>WAVES in the required amount are debited from the creator's account and go to the miners (the number of sponsored tokens and their correspondence Waves is configured at the time of sending the SetSponsorship transaction)</li>
</ul>
<p><img src="../../assets/4-2-1-sponsorship.png" alt="How sponsorship works" title="How sponsorship works"></p>
<p>Submitting a sponsorship enable transaction is quite simple:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {sponsorship} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'A'</span>,
  <span class="hljs-attr">minSponsoredAssetFee</span>: <span class="hljs-number">100</span>
}

<span class="hljs-keyword">const</span> signedSponsorshipTx = sponsorship (params, seed)
</div></code></pre>
<p>The code above will form (but not send to the blockchain) a transaction:</p>
<pre class="hljs"><code><div>{
  &quot;id&quot;: &quot;A&quot;,
  &quot;type&quot;: 14,
  &quot;version&quot;: 1,
  &quot;senderPublicKey&quot;: &quot;3SU7zKraQF8tQAF8Ho75MSVCBfirgaQviFXnseEw4PYg&quot;,
  &quot;minSponsoredAssetFee&quot;: 100,
  &quot;assetId&quot;: &quot;4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC&quot;,
  &quot;fee&quot;: 100000000,
  &quot;timestamp&quot;: 1575034734209,
  &quot;proofs&quot;: [
    &quot;42vz3SxqxzSzNC7AdVY34fM7QvQLyJfYFv8EJmCgooAZ9Y69YDNDptMZcupYFdN7h3C1dz2z6keKT9znbVBrikyG&quot;
  ]
}
</div></code></pre>
<p>To cancel sponsoring a transaction, it is enough to send a transaction with the <code>minSponsoredAssetFee</code> field equal to<code> null</code>.</p>
<h2 id="setassetscript-transaction-type--15">SetAssetScript transaction (type = 15)</h2>
<p>This transaction is in its essence similar to the <code>SetScript</code> transaction, with one exception - it allows you to change the script for the token, not the account.</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> {setAssetScript} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE in base64 representation</span>
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC'</span>,
  <span class="hljs-comment">// senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">// timestamp: Date.now (),</span>
  <span class="hljs-comment">// fee: 100000,</span>
  <span class="hljs-comment">// chainId: 'W'</span>
}

<span class="hljs-keyword">const</span> signedSetAssetScriptTx = setAssetScript (params, seed)
broadcast (signedSetAssetScriptTx);
</div></code></pre>
<p><code>SetAssetScript</code> is only possible for assets that already have a script. If you issued a token using the <code>Issue</code> transaction that does not have a script, then you will not be able to install a script on it in the future.</p>
<p>Installing a script on a token increases the minimum commission for operations with this token by 0.004 Waves (just like in the case of smart accounts and decentralized applications).</p>
<p>For example, the minimum <code>Transfer</code> transaction fee is 0.001, but for smart assets it is 0.005 Waves. If we want to transfer a smart asset from a smart account, then we will have to pay at least 0.009 Waves (0.001 base cost, 0.004 increments for executing the smart account / decentralized application script and the same amount for executing the smart asset code).</p>
<h2 id="invokescript-transaction-type--16">InvokeScript transaction (type = 16)</h2>
<p>The <code>InvokeScript</code> transaction is one of the most important transactions on the network, as it is designed to call functions in decentralized applications.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {invokeScript} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {

  <span class="hljs-attr">call</span>: {
    <span class="hljs-attr">args</span>: [{<span class="hljs-attr">type</span>: <span class="hljs-string">'integer'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>}],
    <span class="hljs-attr">args</span>: [{<span class="hljs-attr">type</span>: <span class="hljs-string">'binary'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'base64: AAA ='</span>}],
    <span class="hljs-attr">args</span>: [{<span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'foo'</span>}],
    <span class="hljs-attr">args</span>: [{<span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>}],
    <span class="hljs-attr">function</span>: <span class="hljs-string">'foo'</span>,
  },
  <span class="hljs-attr">payment</span>: [
    {
      <span class="hljs-attr">amount</span>: <span class="hljs-number">16</span>,
      <span class="hljs-attr">assetId</span>: <span class="hljs-string">'73pu8pHFNpj9tmWuYjqnZ962tXzJvLGX86dxjZxGYhoK'</span>},
    {
      <span class="hljs-attr">amount</span>: <span class="hljs-number">10</span>,
      <span class="hljs-attr">assetId</span>: <span class="hljs-literal">null</span>
    }
  ],
  <span class="hljs-attr">dApp</span>: <span class="hljs-string">'3Fb641A9hWy63K18KsBJwns64McmdEATgJd'</span>,
  <span class="hljs-attr">chainId</span>: <span class="hljs-string">'W'</span>,
  <span class="hljs-attr">fee</span>: <span class="hljs-number">500000</span>,
  <span class="hljs-attr">feeAssetId</span>: <span class="hljs-string">'73pu8pHFNpj9tmWuYjqnZ962tXzJvLGX86dxjZxGYhoK'</span>,
  <span class="hljs-comment">// senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">// timestamp: Date.now (),</span>
  <span class="hljs-comment">// fee: 100000,</span>
  <span class="hljs-comment">// chainId:</span>
}

<span class="hljs-keyword">const</span> signedInvokeScriptTx = invokeScript (params, seed)
<span class="hljs-built_in">console</span>.log (signedInvokeScriptTx)

</div></code></pre>
<p>The example above will call the <code>foo</code> function of the decentralized application on the account with the address<code> 3Fb641A9hWy63K18KsBJwns64McmdEATgJd</code>. When calling the function, 4 arguments are passed. The arguments in <code>InvokeScript</code> are unnamed, but their order must match the order declared in the code of the decentralized application. <code>InvokeScript</code> also allows you to attach up to 2 types of tokens to the call as payment. In the example above, the token <code>73pu8pHFNpj9tmWuYjqnZ962tXzJvLGX86dxjZxGYhoK</code> and Waves (with<code> assetId = null</code>) are attached as payment.</p>
<p><code>InvokeScript</code> along with<code> Transfer</code> can be sponsored, so in the example above the contract call is paid for with the token <code>73pu8pHFNpj9tmWuYjqnZ962tXzJvLGX86dxjZxGYhoK</code>, which must be sponsored.</p>
<p>When working with some applications, there may be a desire to send transactions like <code>InvokeScript</code> with large ** and ** arguments, but this will not work, since the size limit for the entire transaction is 5Kb (including all arguments). If the functions in the decentralized application need to be passed arguments that are larger than this limit, then the following scenario is possible:</p>
<ol>
<li>Send <code>Data</code> transaction (up to ~ 140kb of data)</li>
<li>When calling a function using <code>InvokeScript</code>, pass as an argument the keys that were written using the<code> Data</code> transaction.</li>
<li>In the code of the decentralized application, read the values ​​by the passed keys and process them.</li>
</ol>
<h2 id="updateassetinfo-transaction-type--17-stagenet">UpdateAssetInfo transaction (type = 17) [stagenet]</h2>
<p>The new transaction <code>UpdateAssetInfo</code> (type = 17) is only available on Stagenet at the time of this writing. It allows you to update the data on the issued token. The protocol has long had a <code>Reissue</code> transaction, which allows to reissue tokens and prohibit reissue in the future, but there was no possibility to change the name or description of the token before.</p>
<p>To avoid misunderstandings, let's capture the differences between the <code>Reissue</code> and<code> UpdateAssetInfo</code> transactions:</p>
<ul>
<li><code>Reissue</code> allows you to reissue a token (the amount is set by the creator) and change the<code> reissuable</code> flag (only to <code>false</code>), if the creator set<code> reissuable = true</code> at the time the token is issued.</li>
<li><code>UpdateAssetInfo</code> allows you to update the name and description of the token, but not more often than once every 100,000 blocks.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {updateAssetInfo} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE in base64 representation</span>
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">"New description"</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"New name"</span>
  <span class="hljs-comment">// senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">// timestamp: Date.now (),</span>
  <span class="hljs-comment">// fee: 100000,</span>
  <span class="hljs-comment">// chainId: 'W'</span>
}

<span class="hljs-keyword">const</span> updateAssetInfoTx = updateAssetInfo (params, seed)
broadcast (updateAssetInfoTx);
</div></code></pre>
<h2 id="peculiarities-of-working-with-transactions">Peculiarities of working with transactions</h2>
<p>When forming transactions using libraries, you often want to specify the minimum number of parameters so that the library itself will fill all the rest. The <code>waves-transactions</code> library does just that, offering to fill in only the most important fields and substituting the rest of the parameters by default. However, there are fields in the library, which you do not need to fill in yourself, but it is advisable to understand them and know about their existence.</p>
<h3 id="additionalfee">additionalFee</h3>
<p>For all types of transactions there is an additional field <code>additionalFee</code>, which allows you to add an additional fee to the default values. This can be useful in 2 cases:</p>
<ul>
<li>Specify an additional commission when working with smart assets and smart accounts. For example, the default minimum commission for a <code>Transfer</code> transaction is 0.001 Waves and this value will be indicated by the<code> waves-transactions</code> library, but in the case of working with smart assets, you need to pay an additional 0.004. The library does not know that the transaction is being sent using a smart asset, so the developer must provide an additional fee himself. Of course, you can use the <code>fee</code> field to indicate the entire fee, but using<code> additionalFee</code> is more convenient, because you don't have to remember the minimum fees for each type of transaction yourself.</li>
<li>Send a transaction with an increased commission to quickly get into the block. The download of the Waves network is now much less than the bandwidth, so the need to indicate an increased commission is extremely rare, but such a possibility exists. In the next chapter we will talk about sorting transactions in UTX (waiting list for hitting a block) and you will understand how the size of the commission affects the speed of hitting a block.</li>
</ul>
<p>The table below shows the minimum fees for different types of transactions (when sending from a regular account and without interacting with smart assets):</p>
<p><img src="../../assets/5-2-1-transaction-min-fees.png" alt="Min transaction fees" title="Min transaction fees"></p>
<h3 id="chainid">chainId</h3>
<p>In the transaction examples above, you may have noticed the <code>chainId</code> field, which was most often specified as<code> W</code>. Each transaction in the <code>Waves</code> network contains a byte of the network either directly or indirectly (when the recipient's address is involved in transactions). We considered the network byte when we talked about addresses in <a href="../../sections/3-Accounts/3-1-keys.md">section 3</a>.</p>
<p>Network byte is a unique network identifier that allows you to distinguish addresses and transactions on different networks (mainnet, testnet, stagenet). The network bytes for the networks listed above are <code>W</code>,<code> T</code>, <code>S</code>, respectively. Thanks to the network byte, it is impossible to make a mistake and send tokens to an address that cannot exist on this network on which the transaction is sent. If there were no network byte, it would be possible to attack users who use one pair of private and public keys in several networks (stagenet and mainnet, for example). An attacker could copy the transaction from the stagenet from the user and send it to the mainnet, performing an action that the user did not want to do in the mainnet. Thanks to the network byte, this is impossible.</p>
<h3 id="timestamp">timestamp</h3>
<p>Each transaction has its creation time, which is recorded in the transaction and signed by the sender along with other fields. <code>waves-transactions</code> will default to the time that is set in the operating system where the code is run. In the Waves protocol, the nodes synchronize time with each other using the NTP protocol, so the difference between them is no more than 1 second. We can say that the Waves network knows the current time, and the current time is written in the body of the block at the time of its creation by the node. If any generator tries to make a block &quot;from the past&quot; or &quot;from the future&quot;, then other generators and validators will not accept such a block.</p>
<p>As for the transaction time, it may differ from the block time by no more than 90 minutes in the past and 120 minutes in the future. You can send a transaction in which the <code>timestamp</code> will be from the future for 120 minutes and the generators will try to add it to the block, but if you send it with a time that is 121 minutes longer on the nodes, the transaction will already be rejected.</p>
<p>The <code>timestamp</code> parameter can be used to regulate how long a transaction can be in the waiting list to hit a block. If the network is loaded, transactions enter the block very slowly and we do not want to pay a large commission, but we are ready to wait, then we can put a <code>timestamp</code>, which is 120 minutes longer on the nodes. Such a transaction will be valid for 210 minutes (3 and a half hours) and only if it does not hit the block during this time, it will be rejected. There may be a reverse situation, when it is important for us that a transaction can only quickly get into a block or not get it at all. In this case, setting a timestamp 85 minutes less than the current time ensures that it is only valid for 5 minutes, and if it does not hit the block during these 5 minutes, it will be cleared from UTX and never hit block.</p>
<p>When using the field <code>timestamp</code> of transactions in the code of smart contracts, remember that it may differ from the present by [-90; +120] minutes. In section 7 we will talk about how to use time correctly, if you still need it in the contract code.</p>
<h3 id="proofs">proofs</h3>
<p>The <code>proofs</code> field is an array for transaction signatures. There can be up to 8 signatures. In fact, not only signatures can be stored in this field, but also used to pass them as arguments to smart accounts or decentralized applications. This can be especially useful when working with smart accounts that cannot accept arguments as functions.</p>
<h3 id="id">id</h3>
<p>Every transaction on the network has a unique ID, which is a hash based on the fields of the transaction. There cannot be 2 identical transactions with two identical IDs in the network. The transaction ID is calculated by <code>waves-transactions</code> automatically and it can be used to work with the API - to wait for a block hit or check the status.</p>
<h3 id="version">version</h3>
<p>Not only are there many different types of transactions on the Waves network, but there may be several different versions for each type. For example, there are 3 versions for types like <code>Transfer</code> or<code> Issue</code>. It is important to keep in mind that the JSON representation of transactions when working with an API may differ for different versions of the same type.</p>
<h2 id="signature-of-transactions">Signature of transactions</h2>
<p>Each transaction of the latest versions may have not one signature, but up to 8. In the examples above, we always used a seed phrase, from which the <code>waves-transactions</code> library itself received the public key<code> senderPublicKey</code> and the signature in the <code>proofs</code> array. There are situations when you need to send a transaction from one account, and sign with the key of another. In this case, you need to form a transaction with an explicit indication of the senderPublicKey of the sender as follows:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {setScript} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE in base64 representation</span>
  <span class="hljs-attr">senderPublicKey</span>: <span class="hljs-string">'4VStEwhXhsv6wQ6PBR5CfEYD8m91zYg2pcF7v17QGSbJ'</span>,
}

<span class="hljs-keyword">const</span> signedSetScriptTx = setScript (params, seed)
</div></code></pre>
<p>If you need to sign with several keys, then there are 2 options to do this:</p>
<ul>
<li>use the <code>addProof (tx: ITransaction, seed: string)</code> function, which accepts the body of the generated transaction and adds the signature from the seed passed as the second argument</li>
<li>when forming a transaction, send an array of seed phrases</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> {setScript} = <span class="hljs-built_in">require</span> (<span class="hljs-string">'@ waves / waves-transactions'</span>)
<span class="hljs-keyword">const</span> seeds = [<span class="hljs-string">'0 - example seed phrase'</span>, <span class="hljs-string">'1 - example seed phrase'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'3 - example seed phrase'</span>]
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE in base64 representation</span>
  <span class="hljs-attr">senderPublicKey</span>: <span class="hljs-string">'4VStEwhXhsv6wQ6PBR5CfEYD8m91zYg2pcF7v17QGSbJ'</span>,
}

<span class="hljs-keyword">const</span> signedSetScriptTx = setScript (params, seeds)
</div></code></pre>
<p>In this case, the created transaction will contain 3 signatures in the <code>proofs</code> array under indexes 0, 1 and 3, and under index 2 there will be<code> null</code>:</p>
<pre class="hljs"><code><div>{
  &quot;type&quot;: 13,
  &quot;version&quot;: 1,
  &quot;senderPublicKey&quot;: &quot;4VStEwhXhsv6wQ6PBR5CfEYD8m91zYg2pcF7v17QGSbJ&quot;,
  &quot;chainId&quot;: 82,
  &quot;fee&quot;: 1000000,
  &quot;timestamp&quot;: 1587883659092,
  &quot;proofs&quot;: [
    &quot;4cajf7tKFJR2rvzWpsufytU1p1dTtstbnRLg1A89eCgg2ezFRqe1UKyux5vzK1BeFeoiGFpZ8Vu6epzFTdhZQqWe&quot;,
    &quot;3PVzmWVnS2CJWpXDonCuWGgE48FsxZWQVriwNJXmstxZvqWQaowsebnAC5zca7j71cHQpZxB5yizmhzzKT9cvWXh&quot;,
    null,
    &quot;2d6yyeTzjF5J8frSyuyBf3B2qKyoKuHEJq4X22joghjyeW7nZJBWdQhLVfxaUYQ6GnAhjXA7Mz7FXXkhRz7n5Zh9&quot;
  ],
  &quot;id&quot;: &quot;8btD3NufMo8VApFi4opTPPdfa2ej6w2SFTojCaMcaqQq&quot;,
  &quot;script&quot;: &quot;base64: ...&quot;
}
</div></code></pre>
<h1 id="utx-processing-features">UTX processing features</h1>
<p>Waiting list transactions are never fun, they want to get into a block! How do you determine which transaction should get into the block first? It would be possible to make a simple queue and be guided by the principle &quot;Who got up first, that and the slippers&quot;, but this approach is not optimal for miners in the network. It is much more profitable for them to put transactions with a higher commission in the block. But here, too, everything is not so simple, you remember that there are different types of transactions in Waves. Each type has its own minimum commission, set in consensus, so processing depending on the size of the commission will also not lead to the expected result. For example, sending <code>InvokeScript</code> transactions with a minimum commission of 0.005 Waves will always hit the block before a Transfer transaction with a 0.001 Waves commission. What to do?</p>
<p>The first thing you can think of is sorting transactions based on cost per transaction byte. A node spends resources on validating a signature for a transaction, and the larger the transaction is in size, the more resources will be spent on it. For example, a 140 kb data transaction will be validated several tens of times longer than a Transfer transaction less than a kilobyte in size. Let's talk with examples. Let's say we have 2 transactions:</p>
<ul>
<li>Data transaction of 100 kb and a commission of 0.01 Waves</li>
<li>Transfer transaction in the size of 1kb and with a commission of 0.001 Waves</li>
</ul>
<p>Which transaction will be the first in the queue? The one that was received first, because in terms of 1 byte of a transaction, the commissions for these 2 transactions are equal.</p>
<p>The diagram below shows how exactly the node processes transactions before entering the block, as well as while it is there. In the diagram, you can see the <code>cleanup</code> function, which is constantly executed in the background and checks if the transactions in UTX have become invalid (expired, the sender's balance has become zero due to another transaction and cannot pay the commission, etc.). and whether there is a need to remove them from there.</p>
<p><img src="../../assets/37F7DE3C-90E8-49FD-BD5D-16779F29D3F0.png" alt="UTX pool details" title="UTX pool details"></p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-6-the-ride-programming-language">Chapter 6. The Ride Programming Language</h1>
<p>Ride is a compiled, statically typed, lazy execution functional programming language for building decentralized applications. The language was created with the goal of helping developers write error-free code.</p>
<p>Ride is not a Turing complete language. It has no loops (in the classical sense), recursions, and provides many restrictions that make applications easy to understand and debug. At the same time, using Ride and all the capabilities of the Waves blockchain, you can build Turing-complete systems.</p>
<h2 id="history-of-creation">History of creation</h2>
<p>The main ideological inspirer of the creation of Ride is Ilya Smagin. The language was originally aimed at implementing simple cases like multi-signature and first appeared on the Mainnet in the summer of 2018, allowing you to write scripts to create smart accounts. In January 2019, it became possible to write scripts for smart assets on Ride, and in July 2019 it became possible to write full-fledged decentralized applications thanks to a release called Ride4dapps.</p>
<p>The philosophy of the language and its creators comes down to a few simple rules:</p>
<ol>
<li>A programming language is a tool for implementing specific cases. The complication of the language and the addition of new constructions are done only if there are cases and businesses that lack this.</li>
<li>Turing completeness together with scalability are hardly achievable within the framework of a public blockchain system, so the language should be convenient without this characteristic.</li>
<li>Ride is a specific language for writing decentralized applications, not a general purpose language, so the language has specific constructs.</li>
</ol>
<p>The language has been heavily influenced by Scala and F #. This is not to say that Ride is very similar to any of these languages, but people who know these languages ​​will find it easier to start writing in Ride. At the same time, the language is simple for developers in all other languages, the initial acquaintance with the language and tools usually takes about an hour. By the end of this chapter, you will have learned almost the entire language and all the basic constructs.</p>
<p>Although Ride is simple, it provides many options for the developer. Let's move on to the syntax of the language.</p>
<h2 id="hello-world">Hello world</h2>
<pre class="hljs"><code><div>func say () = {
  <span class="hljs-string">"Hello world!"</span>
}
</div></code></pre>
<p>Functions are declared using the <code>func</code> keyword. Functions return types, but they do not need to be declared, since the compiler will infer them. In the example above, the <code>say</code> function will return the string<code>&quot;Hello World!&quot; There is no</code>return` keyword in the language because Ride is expression-based (everything is an expression) and the last expression is the result of a function.</p>
<h2 id="blockchain">Blockchain</h2>
<p>Ride is intended to be used inside the blockchain and there is no way to access the file system.</p>
<p>Ride functions can read data from the blockchain and return transactions as a result, which will be written to the blockchain.</p>
<h2 id="comments">Comments</h2>
<pre class="hljs"><code><div># <span class="hljs-type">This</span> is a comment

# <span class="hljs-type">Multi</span>-line comments cannot be created in the language

<span class="hljs-string">"Hello world!"</span> # <span class="hljs-type">You</span> can write comments in such places too
</div></code></pre>
<h2 id="directives">Directives</h2>
<p>Every Ride script must start with a compiler directive. There are 3 possible types of directives with different possible meanings.</p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">DAPP</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}
</div></code></pre>
<p><code>STDLIB_VERSION</code> specifies the version of the standard library. The latest version in mainnet is 3, in stagenet it is 4.</p>
<p>CONTENT_TYPE specifies the type of file you are working on. Currently there are types <code>DAPP</code> and<code> EXPRESSION</code>. The <code>DAPP</code> type allows you to declare functions, terminate the execution of the script with some transactions (changes in the blockchain) and use annotations, while<code> EXPRESSION</code> ends with a boolean expression (<code>true</code> or<code> false</code>).</p>
<p>SCRIPT_TYPE specifies the type of entity to which we want to add the script and change the default behavior. Ride scripts can be attached to <code>ACCOUNT</code> or<code> ASSET</code>.</p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">DAPP</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ASSET</span> # -} # dApp <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">cannot</span> <span class="hljs-title">be</span> <span class="hljs-title">used</span> <span class="hljs-title">for</span> <span class="hljs-title">ASSET</span></span>
</div></code></pre>
<p>Not all combinations of directives are correct. The example above will not work, because the <code>DAPP</code> content type is only valid for accounts, while the EXPRESSION type is available for tokens (assets) and accounts.</p>
<h2 id="functions">Functions</h2>
<pre class="hljs"><code><div>func greet (name: <span class="hljs-type">String</span>) = {
  <span class="hljs-string">"Hello,"</span> + name
}

func add (a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) = {
  a + b
}
</div></code></pre>
<p>The type must follow the name of the argument.</p>
<p>As with many other languages, functions cannot be overloaded. This helps keep the code readable and easy to modify.</p>
<p>Functions can only be used after they have been declared.</p>
<h2 id="variables">Variables</h2>
<pre class="hljs"><code><div>let a = <span class="hljs-string">"Bob"</span>
let b = <span class="hljs-number">1</span>
</div></code></pre>
<p>Variables are declared and initialized using the <code>let</code> keyword. This is the only way to declare variables in Ride. All variables in Ride are immutable. This means that you cannot change the value of the variable after the declaration.</p>
<p>The type of the variable is determined, or more precisely, it is inferred (type inference) based on the value on the right side.</p>
<p>Ride allows you to define variables within any function or in the global scope.</p>
<pre class="hljs"><code><div>a = <span class="hljs-string">"Alice"</span>
</div></code></pre>
<p>The above code will not compile because the variable <code>a</code> is undefined. All variables in Ride must be declared using the <code>let</code> keyword.</p>
<pre class="hljs"><code><div>func lazyIsGood () = {
  let a = <span class="hljs-string">"Bob"</span>
  <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>The above function will compile and return <code>true</code> as a result, but the<code> a</code> variable will not be initialized because Ride is lazy, which means that all unused variables are not evaluated.</p>
<pre class="hljs"><code><div>func callable () = {
  <span class="hljs-number">42</span>
}

func caller () = {
  let a = callable ()
  <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>The <code>callable</code> function will also not be called, since the<code> a</code> variable is not used.</p>
<p>Unlike most languages, variable reuse is not allowed. Declaring a variable with a name that is already in use in the parent scope will result in a compilation error.</p>
<h2 id="basic-types">Basic types</h2>
<p>The main base types are shown below:</p>
<pre class="hljs"><code><div><span class="hljs-type">Boolean</span> # <span class="hljs-literal">true</span>
<span class="hljs-type">String</span> # <span class="hljs-string">"Hey"</span>
<span class="hljs-type">Int</span> # <span class="hljs-number">1610</span>
<span class="hljs-type">ByteVector</span> # base58 '...', base64 '...', base16 '...', fromBase58String (<span class="hljs-string">"..."</span>), etc.
</div></code></pre>
<h3 id="strings">Strings</h3>
<pre class="hljs"><code><div>let name = <span class="hljs-string">"Bob"</span>
name + <span class="hljs-string">"is cool!"</span> # lines will be concatenated because the + sign is used

name.indexOf (<span class="hljs-string">"o"</span>) # <span class="hljs-number">1</span>
</div></code></pre>
<p>In Ride, a string is a read-only byte array. String data is encoded using UTF-8.</p>
<p>Only double quotes can be used to denote strings. Strings are immutable like all other types. This means that the function of finding a substring in a string is very efficient: no copying is done, no additional selections are required.</p>
<p>All operators in Ride must have values ​​of the same type on both sides. The code below will not compile because <code>age</code> is of type Int and<code>&quot;Bob is&quot;</code>is a string:</p>
<pre class="hljs"><code><div>let age = <span class="hljs-number">21</span>
<span class="hljs-string">"Bob is"</span> + age # won<span class="hljs-symbol">'t</span> compile
</div></code></pre>
<p>To make the code work, we have to convert <code>age</code> to<code> String</code>:</p>
<pre class="hljs"><code><div>let age = <span class="hljs-number">21</span>
<span class="hljs-string">"Alice is"</span> + age.toString () # <span class="hljs-keyword">this</span> is how it works!
</div></code></pre>
<h2 id="special-types">Special types</h2>
<pre class="hljs"><code><div><span class="hljs-type">List</span> # [<span class="hljs-number">16</span>, <span class="hljs-number">10</span>, <span class="hljs-string">"hello"</span>]
<span class="hljs-type">Nothing</span> #
<span class="hljs-type">Unit</span> # unit
</div></code></pre>
<p>Ride has several types that &quot;** look ** like ~~ ducks ~~ in Scala, swim like ~~ ducks ~~ in Scala, and quack like ~~ ducks ~~ in Scala&quot;. For example, the types <code>Nothing</code> and<code> Unit</code>.</p>
<p>Ride does not have a null type like many other languages. Usually, built-in functions return type <code>Unit</code> instead of<code> null</code>.</p>
<pre class="hljs"><code><div><span class="hljs-string">"String"</span> .indexOf (<span class="hljs-string">"substring"</span>) == unit # <span class="hljs-literal">true</span>
</div></code></pre>
<h3 id="lists">Lists</h3>
<pre class="hljs"><code><div>let list = [<span class="hljs-number">16</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1997</span>, <span class="hljs-string">"birthday"</span>] # collection can contain different data types
let second = list [<span class="hljs-number">1</span>] # <span class="hljs-number">10</span> - the second value from the list

</div></code></pre>
<p>To work correctly with lists in Ride, they must always have a known size, because there are no loops or recursions.</p>
<p>List has no fields, but there are functions in the standard library that make them easier to work with.</p>
<pre class="hljs"><code><div>let list = [<span class="hljs-number">16</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1997</span>, <span class="hljs-string">"birthday"</span>]

let last = list.getElement (list.size () - <span class="hljs-number">1</span>) # <span class="hljs-string">"birthday"</span>, postfix function call size ()

let lastAgain = getElement (collection, size (collection) - <span class="hljs-number">1</span>) # same as above
</div></code></pre>
<p>The <code>.size ()</code> function returns the length of the list. Note that this value is read-only and cannot be changed.</p>
<pre class="hljs"><code><div>let initList = [<span class="hljs-number">16</span>, <span class="hljs-number">10</span>] # init value
let newList = cons (<span class="hljs-number">1997</span>, initList) # creates a <span class="hljs-keyword">new</span> list <span class="hljs-keyword">with</span> initLinit elements and a <span class="hljs-keyword">new</span> value - [<span class="hljs-number">1997</span>, <span class="hljs-number">16</span>, <span class="hljs-number">10</span>]
let newestList = initList ++ newList # merges <span class="hljs-number">2</span> lists into one
</div></code></pre>
<p>You can add a new element to an existing list using the <code>cons</code> function. The original list will not be changed, <code>cons</code> will return a new list. You can concatenate two lists using the <code>++</code> operator.</p>
<p>The Ride standard library has functions that make it easier to work with lists, for example:</p>
<ul>
<li><code>containsElement (list: List [T], element: T): Boolean</code> - checks if there is an element in the list</li>
<li><code>indexOf (list: List [T], element: T): Int | Unit</code> - returns the first index of the element or<code> Unit</code> if the element is not found</li>
<li><code>lastIndexOf (list: List [T], element: T): Int | Unit</code> - - returns the last index of the element or<code> Unit</code> if the element is not found</li>
<li><code>min</code> - returns the minimum value in the list</li>
<li><code>max (List [Int]): Int</code> - returns the maximum value in the list</li>
<li><code>median (List [Int]): Int</code> - returns the median value in the list</li>
<li><code>makeString (List [String], separator: String): String</code> - return a string with all elements of the delimited list</li>
</ul>
<h3 id="union-types">Union types</h3>
<pre class="hljs"><code><div>let valueFromBlockchain = getString (<span class="hljs-string">"3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf"</span>, <span class="hljs-string">"someKey"</span>) # <span class="hljs-type">Union</span> (<span class="hljs-type">String</span> | <span class="hljs-type">Unit</span>)
</div></code></pre>
<p>Union types are a very convenient way to work with abstractions, <code>Union (String | Unit)</code> shows that the value is the intersection of these types.</p>
<p>If Ride had custom types, the following example could be parsed:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Human</span></span>: {firstName: <span class="hljs-type">String</span>, lastName: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>}
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Cat</span></span>: {name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>}
</div></code></pre>
<p><code>Unioin (Human | Cat)</code> is an object with one field <code>age</code>. Usually, <code>Union</code> is returned as a result of function calls when, depending on the parameters, the language runtime could receive different types.</p>
<pre class="hljs"><code><div><span class="hljs-type">Human</span> | <span class="hljs-type">Cat</span> =&gt; {age: <span class="hljs-type">Int</span>}
</div></code></pre>
<p>We can use pattern matching to figure out the real type:</p>
<pre class="hljs"><code><div>let t = ... # <span class="hljs-type">Union</span> (<span class="hljs-type">Cat</span> | <span class="hljs-type">Human</span>)
let age = t.age # <span class="hljs-type">OK</span>
let name = t.name # <span class="hljs-type">Compiler</span> error
let name = <span class="hljs-keyword">match</span> t {# <span class="hljs-type">OK</span>
  <span class="hljs-keyword">case</span> h: <span class="hljs-type">Human</span> =&gt; h.firstName
  <span class="hljs-keyword">case</span> c: <span class="hljs-type">Cat</span> =&gt; c.name
}
</div></code></pre>
<p>For example, the <code>getString</code> function for reading strings from the account store returns<code>Union (String | Unit)</code>because some keys (and their values, respectively) may not exist.</p>
<pre class="hljs"><code><div>let valueFromBlockchain = getString (<span class="hljs-string">"3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf"</span>, <span class="hljs-string">"someKey"</span>)
let realStringValue = valueFromBlockchain.extract ()

# or
let realStringValue2 = getStringValue (<span class="hljs-keyword">this</span>, <span class="hljs-string">"someKey"</span>)
</div></code></pre>
<p>To get the real type and value from <code>Union</code>, you can use not only pattern matching, but also the<code> extract</code> function, which will interrupt the script if the value is <code>Unit</code>. Another option is to use specialized functions such as <code>getStringValue</code>,<code> getIntegerValue</code>, etc., whose behavior will be identical (an exception will be thrown if the value is not in the storage or a different data type is stored for the specified key).</p>
<pre class="hljs"><code><div>
{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">3</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

<span class="hljs-keyword">match</span> (tx) {
    # example of a script <span class="hljs-keyword">with</span> a ban on updating key values
    # read-only storage
    <span class="hljs-keyword">case</span> t: <span class="hljs-type">DataTransaction</span> =&gt; {
        <span class="hljs-keyword">if</span> (getInteger (<span class="hljs-keyword">this</span>, t.data [<span class="hljs-number">0</span>] .key) .isDefined ()) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Key is already used"</span>)
        <span class="hljs-keyword">else</span> <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>
  }

</div></code></pre>
<h2 id="if">If</h2>
<pre class="hljs"><code><div>let amount = <span class="hljs-number">1610</span>
<span class="hljs-keyword">if</span> (amount&gt; <span class="hljs-number">42</span>) then <span class="hljs-string">"I claim that amount is bigger than 42"</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (amount&gt; <span class="hljs-number">100500</span>) then <span class="hljs-string">"Too big!"</span>
  <span class="hljs-keyword">else</span> <span class="hljs-string">"I claim something else"</span>
</div></code></pre>
<p>The <code>if</code> statements are quite simple and similar to most other languages, except for two differences:<code> if</code> can be used as an expression (the result is assigned to a variable) and the <code>else</code> clause is always required.</p>
<pre class="hljs"><code><div>let a = <span class="hljs-number">16</span>
let result = <span class="hljs-keyword">if</span> (a&gt; <span class="hljs-number">0</span>) then a / <span class="hljs-number">10</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> #
</div></code></pre>
<h2 id="pattern-matching">Pattern matching</h2>
<pre class="hljs"><code><div>let readOrInit = <span class="hljs-keyword">match</span> getInteger (<span class="hljs-keyword">this</span>, <span class="hljs-string">"someKey"</span>) {
    <span class="hljs-keyword">case</span> a: <span class="hljs-type">Int</span> =&gt; a
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">0</span>
}
</div></code></pre>
<p>Pattern matching is a pattern matching mechanism. Ride allows pattern matching only for predefined types.</p>
<p>Pattern matching in Ride looks the same as in Scala, but the only use case for now is to get the real type from a variable of type Union. Pattern matching can be useful when, as a result of calling a variable, we can get a value with the type <code>Union</code>, for example,<code>Union (Int | Unit)</code>or it even happens like<code>Union (Order | ReissueTransaction | BurnTransaction | MassTransferTransaction | ExchangeTransaction | TransferTransaction | SetAssetScriptTransaction | InvokeScriptTransaction | IssueTransaction | LeaseTransaction | LeaseCancelTransaction | CreateAliasTransaction | SetScriptTransaction | SponsorFeeTransaction | DataTransaction)</code>.</p>
<pre class="hljs"><code><div>let amount = <span class="hljs-keyword">match</span> tx {# tx - current outgoing transaction <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">in</span> <span class="hljs-title">global</span> <span class="hljs-title">scope</span> <span class="hljs-title">for</span> <span class="hljs-title">smart</span> <span class="hljs-title">account</span></span>
  <span class="hljs-keyword">case</span> t: <span class="hljs-type">TransferTransaction</span> =&gt; t.amount
  <span class="hljs-keyword">case</span> m: <span class="hljs-type">MassTransferTransaction</span> =&gt; m.totalAmount
  <span class="hljs-keyword">case</span> i: <span class="hljs-type">InvokeScriptTransaction</span> =&gt; <span class="hljs-keyword">if</span> (i.payment) i.payment.extract (). amount <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">0</span>
}
</div></code></pre>
<p>The above code shows an example of using pattern matching when we want to get the number of tokens transferred in the current transaction from a given account. Depending on the type of transaction, the actual amount of transferred tokens can be stored in different fields. If the transaction is of type <code>Transfer</code>,<code> MassTransfer</code> or <code>InvokeScript</code>, we will take the correct field, otherwise we will get 0.</p>
<h2 id="pure-functions">pure functions</h2>
<p>Ride functions are pure by default, which means that their return values ​​are determined only by their arguments, and their execution has no side effects. In all fairness, there has been a lot of controversy among the Ride developers about the &quot;purity&quot; of the Ride features. The fact is that in Ride there are two variables in the global scope - <code>height</code>, which stores the current blockchain height (the number of the current block into which this transaction falls) and<code> lastBlock</code>, which stores information about the current block. In theory, the result of a function depends not only on its parameters, but also on the environment (those variables <code>height</code> and<code> lastBlock</code>), so some will say that functions are &quot;not completely clean&quot; or even &quot;not clean at all&quot;.</p>
<p>In any case, Ride is not a pure functional language, since there is also a <code>throw ()</code> function that terminates the script at any time. That is, the function may not complete at all, and not just complete with an error, therefore, it will still not work to call the language fully functional.</p>
<pre class="hljs"><code><div>let a = getInteger (<span class="hljs-keyword">this</span>, <span class="hljs-string">"key"</span>). extract ()
<span class="hljs-keyword">throw</span> (<span class="hljs-string">"I will terminate it!"</span>)
let result = <span class="hljs-keyword">if</span> a &lt;<span class="hljs-number">0</span> then
  <span class="hljs-string">"a is negative"</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-string">"a is positive or 0"</span>
</div></code></pre>
<p>In the above example, the script terminates on line 2 with the message <code>I will terminate it!</code> And never reaches the <code>if</code> expression.</p>
<h2 id="annotations--access-modifiers">Annotations / Access Modifiers</h2>
<p>Functions can only be defined in a script of type <code>DAPP</code> -<code>{- # CONTENT_TYPE DAPP # -}</code>. Functions can be without annotations, or with <code>@ Callable</code> or<code> @ Verifier</code> annotations.</p>
<pre class="hljs"><code><div>func getPayment (i: <span class="hljs-type">Invocation</span>) = {
  let pmt = extract (i.payment)
  <span class="hljs-keyword">if</span> (isDefined (pmt.assetId)) then
    <span class="hljs-keyword">throw</span> (<span class="hljs-string">"This function accetps waves tokens only"</span>)
  <span class="hljs-keyword">else</span>
    pmt.amount
}

<span class="hljs-meta">@Callable</span> (i)
func pay () = {
  let amount = getPayment (i)
  <span class="hljs-type">WriteSet</span> ([<span class="hljs-type">DataEntry</span> (i.caller.bytes, amount)])
}
</div></code></pre>
<p>Functions with the @Callable annotation can be called from outside the blockchain. To call such functions, you need to send an <code>InvokeScript</code> transaction.</p>
<p>Annotations can &quot;bind&quot; some values ​​to a function. In the above example, the <code>i</code> variable was bound to the<code> pay</code> function and stored all information about the fact of the call (public key, address, payment attached to the transaction, commission, transaction id, etc.).</p>
<p>Functions without annotations ** cannot ** be called &quot;from outside&quot;, only the script itself can call them. That is, a <code>Callable</code> or a<code> Verifier</code> function starts execution, during which the function can be called without annotation.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Verifier</span> (tx)
func verifier () = {
  <span class="hljs-keyword">match</span> tx {
    <span class="hljs-keyword">case</span> m: <span class="hljs-type">TransferTransaction</span> =&gt; tx.amount &lt;= <span class="hljs-number">100</span> # no more than <span class="hljs-number">100</span> tokens can be sent
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>
  }
}
</div></code></pre>
<p>Functions with the @Verifier annotation set the rules for outgoing transactions of a decentralized application (dApp) or smart account. Verifier functions cannot be called externally, but they are executed every time an attempt is made to send a transaction from this account.</p>
<p>Verifier functions must always return a <code>Boolean</code> value as a result, depending on whether the transaction enters the blockchain or not.</p>
<p>The verifier function can &quot;bind&quot; a variable that is an object with all fields of the current outgoing (and verified) transaction (<code>tx</code> in the example above).</p>
<p>In one script, only one verifier function with the @ Verifier annotation can be defined.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func callMeMaybe () = {
  let randomValue = getRandomValue ()
  [<span class="hljs-type">IntegerEntry</span> (<span class="hljs-string">"key"</span>, randomValue)]
}

func getRandomValue () = {
  <span class="hljs-number">16101997</span> # quite a random number
}
</div></code></pre>
<p>This code will not compile because functions ** without ** annotations must be defined ** before ** functions with annotations.</p>
<h3 id="predefined-data-structures">Predefined data structures</h3>
<p>Ride has many predefined specific data structures for the Waves blockchain, such as: <code>Address</code>,<code> Alias</code>, <code>IntegerEngry</code>,<code> StringEntry</code>, <code>Invocation</code>,<code> ScriptTransfer</code>, <code>AssetInfo</code>,<code> BlockInfo</code>, etc.</p>
<pre class="hljs"><code><div>let keyValuePair = <span class="hljs-type">StringEntry</span> (<span class="hljs-string">"someKey"</span>, <span class="hljs-string">"someStringValue"</span>)
</div></code></pre>
<p><code>StringEntry</code> is a data structure that describes a key-value pair, as in an account store, where the value is a string.</p>
<pre class="hljs"><code><div>let <span class="hljs-type">ScriptTransfer</span> = <span class="hljs-type">ScriptTransfer</span> (<span class="hljs-string">"3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs"</span>, amount, unit)
</div></code></pre>
<p>All built-in data structures can be used for type checking and pattern matching.</p>
<h2 id="execution-result">Execution result</h2>
<pre class="hljs"><code><div><span class="hljs-meta">@Verifier</span> (tx)
func verifier () = {
  <span class="hljs-string">"Returning some string"</span>
}
</div></code></pre>
<p>Expression scripts (with the <code>{- # CONTENT_TYPE EXPRESSION # -}</code> directive) must always return a boolean expression along with the <code>@ Verifier</code> functions. Depending on this value, the transaction will be accepted (in the case of <code>true</code>) or rejected (in the case of<code> false</code>) by the blockchain.</p>
<p><code>@ Callable</code> functions can end with 5 types of blockchain changes:</p>
<ol>
<li>Changing the state of the key-value storage, including adding and removing pairs</li>
<li>Issue of tokens</li>
<li>Re-issue of tokens</li>
<li>Transfer of tokens</li>
<li>Burning tokens</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func giveAway (age: <span class="hljs-type">Int</span>) = {

  let callerAddress = i.caller
  let reissuable = <span class="hljs-literal">false</span>
  let assetScript = <span class="hljs-type">Unit</span>
  let decimals = <span class="hljs-number">0</span>
  let amount = <span class="hljs-number">100</span>
  let nonce = <span class="hljs-number">0</span>
  let newAsset = <span class="hljs-type">Issue</span> (assetScript, decimals, <span class="hljs-string">"Description here"</span>, reissuable, <span class="hljs-string">"MyCoolToken"</span>, amount, nonce)


  [
    <span class="hljs-type">ScriptTransfer</span> (callerAddress, age, unit),
    <span class="hljs-type">IntegerEntry</span> (<span class="hljs-string">"ageof_"</span> + callerAddress.toBase58String (), age),
    <span class="hljs-type">BooleanEntry</span> (<span class="hljs-string">"booleanKey"</span>, <span class="hljs-literal">true</span>),
    <span class="hljs-type">StringEntry</span> (<span class="hljs-string">"stringKey"</span>, <span class="hljs-string">"somevalue"</span>),
    <span class="hljs-type">BinaryEntry</span> (<span class="hljs-string">"binaryKey"</span>, base58<span class="hljs-symbol">'3P</span> '),
    <span class="hljs-type">DeleteEntry</span> (<span class="hljs-string">"ScriptTransfer (i.caller, 100, newAsset.calculateAssetId ()),"</span>),
    newAsset,
    <span class="hljs-type">ScriptTransfer</span> (i.caller, <span class="hljs-number">100</span>, newAsset.calculateAssetId ()),
    <span class="hljs-type">Reissue</span> (base58<span class="hljs-symbol">'81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9W</span> ', reissuable, amount),
    <span class="hljs-type">Burn</span> (base58<span class="hljs-symbol">'81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9W</span> ', amount)
  ]
}
</div></code></pre>
<p>Everyone who calls the <code>giveAway</code> function will receive as many Waves as he is (the user passes the number of years as an argument), and the dApp will store information about the transfer in its storage, besides this, the script will write several key pairs in the storage of this decentralized application -values ​​(boolean, byte array, string) and will delete the entire pair with the <code>deleteKey</code> key. The script will also issue a new token called <code>MyCoolToken</code>, send 100 such tokens to the calling account, add 100 tokens with<code> assetId</code> equal to <code>81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9W</code> and burn<code> 100 tokens with the same assetId</code>.</p>
<p>Each resulting <code>Issue</code> increases the commission for calling such a function by 1 Waves (if a non-NFT token is issued).</p>
<p>The resulting array can contain up to 100 data changes in the storage and 10 operations with tokens (release, burn, send, re-release).</p>
<h2 id="exceptions">Exceptions</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">throw</span> (<span class="hljs-string">"Here is exception text"</span>)
</div></code></pre>
<p>The <code>throw</code> function will immediately terminate the script execution with the provided text. There are no ways to catch thrown exceptions</p>
<p>The main idea if <code>throw</code> function is to stop script execution and send an informative feedback message to a user.</p>
<pre class="hljs"><code><div>let a = <span class="hljs-number">12</span>
<span class="hljs-keyword">if</span> (a != <span class="hljs-number">100</span>) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"a is not 100, actual value is "</span> + a.toString())
<span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span>(<span class="hljs-string">"A is 100"</span>)
</div></code></pre>
<p><code>throw</code> the function can be used to debug the code when developing dApps, since there is no debugger for Ride yet.</p>
<h2 id="execution-context">Execution context</h2>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

let a = <span class="hljs-keyword">this</span> # <span class="hljs-type">Current</span> account address
a == <span class="hljs-type">Address</span> (base58<span class="hljs-symbol">'3P9DEDP5VbyXQyKtXDUt2crRPn5B7gs6ujc</span> ') # <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> the script is executed on an account <span class="hljs-keyword">with</span> a specific address
</div></code></pre>
<p>Ride scripts in the waves blockchain can be linked to accounts and tokens (using the directive <code>{- # SCRIPT_TYPE ACCOUNT | ASSET # -}</code>), and depending on the <code>SCRIPT_TYPE</code> keyword<code> this</code> can refer to different entities. For script type <code>ACCOUNT</code> -<code> this</code> is <code>Address</code></p>
<p>For type <code>ASSET</code> -<code> this</code> is type <code>AssetInfo</code></p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ASSET</span> # -}

let a = <span class="hljs-keyword">this</span> # <span class="hljs-type">AssetInfo</span> <span class="hljs-keyword">for</span> the current token being operated on
a == assetInfo (base58<span class="hljs-symbol">'5fmWxmtrqiMp7pQjkCZG96KhctFHm9rJkMbq2QbveAHR</span> ') # <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> the script is executed <span class="hljs-keyword">for</span> the asset <span class="hljs-keyword">with</span> the specified <span class="hljs-type">ID</span>
</div></code></pre>
<h2 id="macro-fold-n">Macro FOLD <N></h2>
<p>The lack of Turing completeness (we will talk about this in more detail a little later) does not allow Ride to have full-fledged loops, but the language has a macro <code>FOLD</code>, which allows you to execute the specified function several times and&quot; collect &quot;the result into one variable.</p>
<pre class="hljs"><code><div>func sum (acc: <span class="hljs-type">Int</span>, el: <span class="hljs-type">Int</span>) = acc + el
let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
let sum = <span class="hljs-type">FOLD</span> &lt;<span class="hljs-number">5</span>&gt; (arr, <span class="hljs-number">0</span>, sum) # result: <span class="hljs-number">15</span>
</div></code></pre>
<p>The parameter in angle brackets (5 in the example above) sets the maximum number of times the <code>sum</code> function will be called. Each new call will pass the next element of the <code>arr</code> array as an argument. The second parameter of the macro <code>FOLD</code> sets the initial value. The sum function takes 2 arguments:</p>
<ul>
<li><code>acc</code> - the sum after the previous iteration</li>
<li><code>el</code> - next element of the array</li>
</ul>
<p><code>sum</code> will be called with the following parameters:</p>
<pre class="hljs"><code><div>sum (0, 1) # 1
sum (1, 2) # 3
sum (3, 3) # 6
sum (6, 4) # 10
sum (10, 5) # 15
</div></code></pre>
<p><code>FOLD &lt;N&gt;</code> is a macro, that is, syntactic sugar. The Ride interpreter does not know anything about <code>FOLD</code>, because at the time of compilation,<code> FOLD</code> turns into the following code:</p>
<pre class="hljs"><code><div>let result = {
   let size = arr.size ()
   <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) then acc0 <span class="hljs-keyword">else</span> {
      let acc1 = function (acc0, arr [<span class="hljs-number">0</span>])
      <span class="hljs-keyword">if</span> (size == <span class="hljs-number">1</span>) then acc1 <span class="hljs-keyword">else</span> {
         let acc2 = function (acc1, arr [<span class="hljs-number">1</span>])
         <span class="hljs-keyword">if</span> (size == <span class="hljs-number">2</span>) then acc2 <span class="hljs-keyword">else</span> {
            let acc3 = function (acc2, arr [<span class="hljs-number">2</span>])
            <span class="hljs-keyword">if</span> (size == <span class="hljs-number">3</span>) then acc3 <span class="hljs-keyword">else</span> {
               let acc4 = function (acc3, arr [<span class="hljs-number">3</span>])
               <span class="hljs-keyword">if</span> (size == <span class="hljs-number">4</span>) then acc4 <span class="hljs-keyword">else</span> {
                  let acc5 = function (acc4, arr [<span class="hljs-number">4</span>])
                  <span class="hljs-keyword">if</span> (size == <span class="hljs-number">5</span>)
                     then acc5
                     <span class="hljs-keyword">else</span>
                       <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Too big array, max 5 elements"</span>)
}}}}}}
</div></code></pre>
<p>Looks much worse than <code>FOLD &lt;N&gt;</code>. The <code>N</code> parameter must always be an integer greater than 0 and is required. That is, the developer must know the maximum size of the list that will be processed with <code>FOLD</code>.</p>
<p>If in <code>FOLD &lt;N&gt;</code> you pass an array with dimensions greater than <code>N</code>, then an exception will be thrown.</p>
<p>Not all operations possible with other loops can be done with <code>FOLD</code>.</p>
<h2 id="development-process">Development process</h2>
<p>The development of any application starts with an idea, and decentralized applications are no exception here, however, when it comes to code, it would be good to have a clear sequence of steps, how to launch the idea implemented in the code and make it public. In the case of decentralized apps on Ride, the full lifecycle looks like this:</p>
<ol>
<li>The written code on Ride is compiled into base64 representation. The compiled version of the script can contain meta information about the script (for example, the argument types of <code>@ Callable</code> functions are erased at compile time, but can be saved as meta information). There are 2 compilers for Ride - JavaScript and Scala. You can compile the code using different tools - online IDE, REST API nodes, <code>surfboard</code> or<code> ride-js</code> libraries, an extension for Visual Studio Code. We'll talk about these tools a little later in this section.</li>
<li>The compiled script is sent to the blockchain as part of a transaction - SetAssetScript or Issue for smart assets, SetScript for smart accounts and decentralized applications. All these transactions have a <code>script</code> field that accepts the compiled code in<code> base64</code> representation.</li>
<li>After a transaction with a script enters the block, the behavior of the account or asset changes in accordance with what is written in the code.</li>
<li>In the case of smart assets, smart accounts and <code>@ Verifier</code> functions, the contract code will be executed every time a script account sends a transaction or a transaction with a scripted token is made.</li>
<li>In the case of <code>@ Callable</code> functions, their execution starts at the moment when any user calls the function using the<code> InvokeScript</code> transaction.</li>
<li>Updating the script to a new one is possible for both tokens and accounts, if it is not prohibited by the code of the installed script.</li>
</ol>
<h1 id="language-runtime">Language runtime</h1>
<p>Smart contracts and decentralized applications in Waves are different from those in Ethereum and many other blockchains. Let's take a look at the main differences and their reasons.</p>
<h2 id="calculating-difficulty">Calculating difficulty</h2>
<p>All functions and operations in Ride, including operations of addition, subtraction, division, branching, as well as functions of the standard library have complexity. The complexity of each operation is expressed in arbitrary units (let's call it <code>complexity</code>, otherwise we will have to call it<code> parrots</code>). For example, the addition operation has a complexity of 1, and the signature verification function <code>sigVerify ()</code> has a complexity of 200.</p>
<p>Since each script has many execution options due to branches, the <code>complexity</code> of a script is considered the complexity of the most complex branch. If you use, for example, an online IDE, then it will show the complexity of the script in real time.</p>
<p>Ride has a limit on the maximum complexity of the script, and it is different for different types of functions. For <code>@ Verifier</code> functions, smart accounts and smart assets, the maximum script complexity is 3000 units, and for<code> @ Callable</code> functions, the most complex branch can have 4000 units. Unlike other smart contract languages, such as Ethereum's Solidity, the complexity of a script in Ride is always known in advance, since there is no Turing completeness. In the case of Ethereum, it quite often happens that we use a loop in the code, but do not know how many iterations this loop will have at the time of execution (the code can read a collection of arbitrary length and iterate over it). Another possible scenario in Ethereum is the use of recursion. In Ride and Waves, this is impossible, since there are no full-fledged loops - the <code>FOLD</code> macro limits the maximum number of executions in advance, and there are simply no recursions as such.</p>
<p>The well-known complexity eliminates Ethereum's <code>Out of gas</code> problem. Everyone who wrote smart contracts and made decentralized applications on Solidity faced such a situation when the transaction became invalid due to the &quot;out of gas&quot;. In Waves, this situation is simply impossible.</p>
<p>In addition to the limitation on the maximum complexity of the contract, there is also a limitation on the maximum contract size, at the time of writing it is 32 kb. That is, the code of a decentralized application cannot be more than 32 kb.</p>
<h2 id="lack-of-turing-completeness">Lack of Turing completeness</h2>
<p>Ride is * not * Turing complete, not because it is difficult or time-consuming to make Turing complete, but because this approach has its advantages. The blockchain is not the most high-performing system, because all transactions are performed on each node, and a large amount of resources are spent on network communications. There are various approaches to scaling, for example, sharding, creating sidechains, etc., but they are all compromises - when the bandwidth increases, the level of decentralization or security always suffers. This is exactly what the blockchain trilemma claims. Of the 3 characteristics of the blockchain - decentralization, speed and security, only 2 can be fully ensured. Or in other words, you need to choose one side of the triangle:</p>
<p><img src="../../assets/6-2-1-the-blockchain-trilemma.png" alt="The blockchain trilemma" title="The blockchain trilemma"></p>
<p>As you may remember, Waves values ​​always be the most friendly platform for developers and users, so the speed of work should not be a bottleneck, but at the same time, the Waves blockchain will not allow tens of thousands of transactions per second, since the blockchain must remain secure and decentralized.</p>
<p>The lack of Turing completeness allows Waves to offer the optimal combination of these 3 characteristics:</p>
<ol>
<li>Due to the lack of complex scripts, the Waves node can be run on a virtual machine for $ 40 in any public cloud, which contributes to decentralization</li>
<li>The simplicity of scripts also allows the blockchain to have sufficient bandwidth so that even with an average daily number of transactions of <a href="http://dev.pywaves.org/txs/">100,000</a>, there is no competition for getting into the block and, accordingly, high commissions.</li>
<li>Lack of Turing completeness makes smart contracts safer. Ride is to some extent a DSL (domain specific language) or domain-specific language, not a general-purpose language, and DSLs are used in areas where maximum security is required. I talked about this in more detail at one of the conferences in San Francisco, you can see the recording of the speech <a href="https://www.youtube.com/watch?v=gMcif_ADWak">here</a>.</li>
</ol>
<p>Thus, the lack of Turing completeness carries a lot of advantages, however, it affects the development experience, let's look at exactly how.</p>
<h2 id="consequences-of-lack-of-turing-completeness">Consequences of Lack of Turing Completeness</h2>
<p>The lack of Turing completeness sometimes does not allow implementing all the necessary functionality within one function, so often in Waves you have to split the logic of a decentralized application into several functions and call them sequentially using several <code>InvokeScript</code> transactions. For example, one of the most complex applications on the Waves network - stablecoin <a href="https://neutrino.at">Neutrino</a> consists of 5 contracts.</p>
<p>Contracts cannot call each other directly (as in Ethereum), but they can communicate with each other by storing data and intermediate states in the key-value store. Any contract can read the storage of any other contract or account, so the logic for processing complex computations is often the following:</p>
<ol>
<li>Function 1 of decentralized application A is called using the <code>InvokeScript</code> transaction, the result of execution is written to the storage of account A.</li>
<li>Function 1 of decentralized application B, called with the <code>InvokeScript</code> transaction, reads the data written to the storage of application A and uses it to calculate its result.</li>
</ol>
<p>The ability to read the storage state of another account in Waves is a powerful tool that allows you to compose logic, build applications that rely on other existing ones.</p>
<h2 id="utx-processing-features">UTX Processing Features</h2>
<p>In Section 5, we discussed how transactions are sorted in the UTX pool, but at that moment we omitted some details. Now that you are familiar with the concept of script complexity, let's go into all the details.</p>
<p>As we have already said, the sorting of transactions in the queue for hitting the block occurs according to the size of the commission per 1 byte of the transaction, but there is a second parameter that must be taken into account - the complexity of the script execution. The miner's task is to maximize the profit received from commissions, so it may not be profitable for the miner to validate transactions with a script and waste precious time on them, when you can put many transactions in a block without a script, just by checking the signature. At the moment, <code>complexity</code> is not taken into account in any way when sorting transactions in UTX, however, in the future, such a parameter must appear.</p>
<p>There are several parameters in the Waves blockchain that limit block sizes, that is, indirectly limit the maximum bandwidth:</p>
<ul>
<li>up to 1 megabyte of transactions in a block (about 6000 transactions)</li>
<li>the limitation on the maximum total complexity of scripts in a block is 1,000,000 (no more than 250 script call transactions with maximum complexity). When this limit is reached, only transactions that are not related to the execution of scripts will fit into the block, and exactly until the size limit of 1 megabyte is reached.</li>
</ul>
<p>It is important to understand that these parameters may be revised in the future if necessary to serve all users. However, this will lead to an increase in system requirements for nodes.</p>
<h2 id="transactions-with-errors">Transactions with errors</h2>
<p>Execution of scripts when sending transactions (smart asset, smart account or decentralized application) can be successful or fail. If the script ends with an error or the result is <code>false</code> for smart accounts and smart assets, scenarios are possible when the transaction enters the blockchain and the commission is debited from the sender, but the opposite is also possible. Let's take a look at the peculiarities of transactions with errors.</p>
<p>Scripts for decentralized applications and smart assets are not executed when they are added to UTX, but are executed only when they are added to the block. Therefore, such scripts, ending with an exception, will enter the blockchain if they successfully hit UTX. In other words, the transaction will not complete successfully, but the sender will still pay the fee. The Waves node API has a special POST <code>/ debug / validate</code> method that helps pre-check transactions to minimize potential financial losses.</p>
<p>Thus, adding a transaction to the blockchain does not guarantee that it has completed and performed any actions. You can check the status of the script call using the REST API node, which, when requesting a transaction by ID, returns the <code>applicationStatus</code> field.</p>
<p>Scripts executed for smart accounts and the <code>@ Verifier</code> functions work differently - they are validated at the moment of adding to UTX, and even if they returned an error at the time of adding to the block, the transaction will not fall into the block and the sender will not pay the commission.</p>
<h2 id="number-of-executable-scripts">Number of executable scripts</h2>
<p>Many Waves app developers do not fully understand the load on the blockchain their apps can create. Let's count how many scripts can be executed when sending one <code>InvokeScript</code> transaction (in the order in which it actually happens):</p>
<ul>
<li>Asset scripts that are attached as <code>payment</code> to the call - up to 2</li>
<li>Script of the most decentralized application - 1</li>
<li>Script on the account that calls the application function - 1</li>
<li>Asset scripts that are translated as a result of calling an application function - up to 10</li>
</ul>
<blockquote>
<p>It turns out that one call to the application function can lead to the execution of 14 scripts, each of which can have a complexity of 4000 units.</p>
</blockquote>
<p>A similar situation occurs when sending an <code>Exchange</code> transaction, where 2 scripts of the accounts of order senders, 2 scripts of assets, 2 scripts of assets in the commission, 1 script on the matcher's account can be executed, up to 7 scripts in total.</p>
<h1 id="standard-library">Standard library</h1>
<p>The Ride standard library includes a relatively small set of functions, many of which are related to cryptography (hash functions, signature verification functions, etc.). Let's take a look at the most commonly used and what features these functions have.</p>
<p>The first versions of Ride were designed for such simple smart accounts as multisignature, freezing of funds and work with escrow, so the standard library was minimal. Let's take a look at a basic example of a smart contract - multisignature.</p>
<h2 id="multi-signature-2-of-3">Multi-signature 2 of 3</h2>
<p>The main idea of ​​multisignature 2 of 3 is that on one account we accumulate funds that are managed by 3 other accounts. The decision to transfer funds from an account with funds can be made subject to the consent of at least 2 manager accounts. Consent in terms of blockchain and cryptography means the presence of a signature from the given public keys. Let's say Alice, Bob and Cooper manage a multi-signature account and only if at least 2 of them are signed, funds from the account can be transferred.</p>
<p>The first thing we need to do is to define in advance 3 public keys that can sign transactions from an account with funds. Public keys are byte arrays that can be represented in Ride by three types of primitives <code>base16 '',</code> base58 '' and <code>base64 ''. The default representation for keys is </code>base58 ''.</p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

<span class="hljs-meta">@Verifier</span> (tx)
func verify () = {
    #define public keys
    let alicePubKey = base58<span class="hljs-symbol">'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM</span> '
    let bobPubKey = base58<span class="hljs-symbol">'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF</span> '
    let cooperPubKey = base58<span class="hljs-symbol">'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD</span> '
    <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>Note that the function will return the value <code>true</code>, which will allow all transactions from this account, without any signature checks. But don't be alarmed, this is an intermediate state of our script, and <code>true</code> (or<code> false</code>) as a return value is necessary so that the online IDE does not show us a script compilation error. Let's continue with the implementation of our multisignature script.</p>
<p>The Ride standard library has a <code>sigVerify</code> function that verifies the signature of a message. It takes 3 arguments:</p>
<ul>
<li>message</li>
<li>signature</li>
<li>public key</li>
</ul>
<p>And it returns a boolean value (<code>true</code> if the signature matches the public key and message,<code> false</code> otherwise).</p>
<p>The public keys in our example have already been declared, it remains to find 2 more arguments - the message and transaction signatures. The object of the current outgoing transaction <code>tx</code> has a field<code> bodyBytes</code> that contains the message to be signed. Also, the <code>tx</code> object has a<code> proofs</code> field that contains the transaction signatures in a list. The simplest verification of the message signature looks like this:</p>
<pre class="hljs"><code><div>    sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], base58<span class="hljs-symbol">'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM</span> ')
</div></code></pre>
<p>Signature verification for Alice, Bob and Cooper might look like this:</p>
<pre class="hljs"><code><div>    (sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], alicePubKey) &amp;&amp; sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">1</span>], bobPubKey)) # alice &amp; bob
    ||
    (sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], alicePubKey) &amp;&amp; sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">2</span>], cooperPubKey)) # alice &amp; cooper
    ||
    (sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">1</span>], bobPubKey) &amp;&amp; sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">2</span>], cooperPubKey)) # bob &amp; cooper
</div></code></pre>
<p>However, a more elegant way is to verify the signature and write to the variable 1 or 0, depending on the result. By adding these 3 variables and making sure that the sum is greater than 2, we can be sure that at least 2 signatures were correct.</p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

<span class="hljs-meta">@Verifier</span> (tx)
func verify () = {
    #define public keys
    let alicePubKey = base58<span class="hljs-symbol">'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM</span> '
    let bobPubKey = base58<span class="hljs-symbol">'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VDF</span> '
    let cooperPubKey = base58<span class="hljs-symbol">'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5cD</span> '

    #check whoever provided the valid proof
    let aliceSigned = <span class="hljs-keyword">if</span> (sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], alicePubKey)) then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
    let bobSigned = <span class="hljs-keyword">if</span> (sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">1</span>], bobPubKey)) then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
    let cooperSigned = <span class="hljs-keyword">if</span> (sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">2</span>], cooperPubKey)) then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>

    #sum up every valid proof to get at least <span class="hljs-number">2</span>
    aliceSigned + bobSigned + cooperSigned&gt; = <span class="hljs-number">2</span>

}
</div></code></pre>
<p>The proofs array is always 8, however, values ​​may not be present anywhere in this array. That is, when sending a transaction, signatures can lie both in the first 3 fields of the array, and in the last three, or under indices 1, 4 and 5. In the next section, we will consider how to use <code>FOLD &lt;N&gt;</code> so as not to imply the presence of keys in some fields, but check all the options.</p>
<blockquote>
<p>Important: the list of <code>proofs</code> in transaction fields always has a dimension of 8, regardless of how many elements it actually contains.</p>
</blockquote>
<p>In addition to the <code>sigVerify</code> signature verification function, there is a<code> RSA</code> verification function - <code>rsaVerify</code>. <code>sigVerify</code>, which works with the signature for the Curve25519 curve (ED25519 with X25519 keys, hereinafter for simplicity we will call&quot; Waves signature &quot;) is not deterministic, that is, there can be an unlimited number of signatures for the same key-message pair. The RSA signature is deterministic, in other words, there can be only one valid RSA signature for the same message and private key.</p>
<h2 id="zk-snarks">zk-SNARKs</h2>
<p>There is one more data verification function in Ride - <code>groth16Verify</code>. This function is intended for verification [zero-expansion proofs] (https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof).</p>
<blockquote>
<p>The purpose of zero knowledge proofs is for the verifier to verify that the verifier possesses knowledge of a secret parameter called evidence that satisfies some relationship without disclosing the evidence to the verifier or anyone else.</p>
</blockquote>
<p>The <code>groth16Verify</code> function is similar to the crypto primitives used in the Zcash blockchain. An example of using <code>groth16Verify</code> for a prototype decentralized application that anonymizes a sender of funds can be found in the <a href="https://github.com/wavesplatform/anonymous-transactions-prototype">Anonymous transactions prototype</a> repository.</p>
<h2 id="working-with-primitives">Working with primitives</h2>
<p>There are 4 main primitive data types in Ride:</p>
<ul>
<li>numbers (only integer)</li>
<li>boolean values ​​(boolean)</li>
<li>strings</li>
<li>arrays of bytes (byte vector)</li>
</ul>
<p>For the last 2 types (string and byte vector) there are functions that make it easier to work with them. For example, the function <code>drop (data: ByteVector | String, n: Integer)</code> can remove the first N bytes or characters from a byte array or string. The <code>take (data: ByteVector | String, n: Integer)</code> function can, on the contrary, leave only the first N bytes. If you need to take bytes or characters not from the beginning, but from the end, then there are the functions <code>dropRight</code> and<code> takeRight</code>. And for even more convenience there is a <code>size ()</code> function.</p>
<p>Working with strings in Ride has become more convenient with the release of the standard library version 3, which introduced the following features:</p>
<ul>
<li><code>contains (substring: String)</code> - check if the substring is included in the string</li>
<li><code>indexOf (substring: String)</code> - returns the index of the first occurrence of a substring</li>
<li><code>lastIndexOf (substring: String)</code> - returns the index of the last occurrence of a substring</li>
<li><code>split (delimiter: String)</code> - splits the string by delimiter and returns an array of strings</li>
<li><code>size ()</code> - returns the number of characters in the string</li>
</ul>
<h2 id="type-conversions">Type conversions</h2>
<p>A common need for programming in strongly typed languages ​​is type conversions. To do this, Ride has a huge number of functions that allow you to do <code>toBytes</code>,<code> toInt</code>, <code>toString</code>,<code> toUtf8String</code> (for an arbitrary byte array). There are also more specific functions like <code>toBase16String</code>,<code> toBase58String</code>, <code>toBase64String</code>, which convert an array of bytes to a string in one of the representations -<code> HEX</code>, <code>base58</code> or<code> base64</code>.</p>
<p>One of the most commonly used types in Ride code is <code>Address</code>, and there is a function<code> addressFromString</code> for convenience of working with it.</p>
<h2 id="getting-data-from-the-blockchain">Getting data from the blockchain</h2>
<p>In Ride scripts, it is quite often necessary to work not only with the parameters of the called function or the transaction being sent, but also with data from the blockchain, which can be divided into 2 categories:</p>
<ol>
<li>Data about entities in the blockchain (account balances, information about tokens or blocks)</li>
<li>Data from the account storage</li>
</ol>
<p>The most commonly used functions from the first category are <code>assetInfo (assetId: ByteVector)</code> and <code>blockInfoByHeight (N: Integer)</code>. The first returns information about the token with the specified <code>assetId</code>. This includes parameters such as the public key of the asset creator or the title and description. The second function returns information about the block with the specified number. To get information about the current (last) block, you can use the global variable <code>lastBlock</code>, which also contains a structure with information about the block. The most useful block parameter can definitely be called <code>timestamp</code>, which contains the block generation time and is the best field to orient to the time in the code of your decentralized application (not the transaction timestamp).</p>
<p>The second category of functions allows you to read data from the storage of any account (not only the current one on which the script is running). As you might have guessed, there are 4 functions for reading different data types - <code>getInteger</code>,<code> getBinary</code>, <code>getBoolean</code>,<code> getString</code>. Each function takes an address and a key as an argument - <code>address: Address, key: String</code>. To read from the account on which the script is executed, it is enough to pass <code>this</code> as the first argument. All functions return <code>Union (T | Unit)</code> since the specified key may not exist. If you are sure that the function will exist, then you can use the functions <code>getIntegerValue</code>,<code> getBinaryValue</code>, <code>getBooleanValue</code> and<code> getStringValue</code>. The difference between the latter is that in the absence of a key, they will return an exception and the function will terminate.</p>
<p>If you do use <code>getInteger</code>,<code> getBinary</code>, <code>getBoolean</code> or<code> getString</code>, then Ride has functions that allow you to extract data from <code>Union</code> or return a default value or an error:</p>
<ul>
<li><code>value ()</code> and <code>extract ()</code> - get data from a variable or return an error without a description</li>
<li><code>valueOrElse (a: T | Unit, b: T)</code> - return data from a variable, if there is not <code>Unit</code>, otherwise return the second argument</li>
<li><code>valueOrErrorMessage (a: T | Unit, b: String)</code> - return data from a variable, if there is not <code>Unit</code>, otherwise throw an error with the message<code> b</code></li>
</ul>
<p>The <code>isDefined ()</code> function may also be useful, which checks that its argument is not <code>Unit</code> (remember that<code> Unit</code> can be considered an analogue of <code>null</code>).</p>
<h2 id="working-with-lists">Working with lists</h2>
<p>Ride lists can be declared with square brackets <code>[]</code> and contain any data type. Some functions in the standard library (for example, <code>split</code> for strings) return lists as the result of execution. For the convenience of working with them, the standard library has functions:</p>
<ul>
<li><code>containsElement (list: List [T], element: T): Boolean</code> - checks if there is an element in the list</li>
<li><code>indexOf (list: List [T], element: T): Int | Unit</code> - returns the first index of the element or<code> Unit</code> if the element is not found</li>
<li><code>lastIndexOf (list: List [T], element: T): Int | Unit</code> - - returns the last index of the element or<code> Unit</code> if the element is not found</li>
<li><code>min</code> - returns the minimum value in the list</li>
<li><code>max (List [Int]): Int</code> - returns the maximum value in the list</li>
<li><code>median (List [Int]): Int</code> - returns the median value in the list</li>
<li><code>makeString (List [String], separator: String): String</code> - return a string with all elements of the delimited list</li>
<li><code>cons (T, List [T]): List [T]</code> - adds a new element to the beginning of the array</li>
<li><code>size (List [T]): Int</code> - returns the number of elements in the array</li>
<li><code>getElement (List [T], Int): T</code> - returns the element of the array at the given index</li>
</ul>
<p>In addition to the functions of the standard library, Ride also has operators for working with lists:</p>
<ul>
<li><code>: +</code> - operator for adding an item to the end of the list</li>
<li><code>++</code> - operator for concatenating lists</li>
</ul>
<h2 id="other-features">Other features</h2>
<p>In this book, we will not consider all the available functions, but I consider it necessary to mention 2 more categories of functions. Much of the blockchain is related to hashing functions, and Ride also has such functions - <code>keccak256</code>,<code> blake2b256</code> and <code>sha256</code>.</p>
<p>The second category of functions that are very often useful are the mathematical functions <code>pow</code> for exponentiation,<code> log</code> for calculating the logarithm and <code>fraction (value: Int, numerator: Int, denominator: Int)</code>, which multiplies the first 2 arguments and divides to the third, avoiding integer variable overflow.</p>
<h2 id="function-families">Function families</h2>
<p>Remember, every feature in Ride has a <code>complexity</code> that determines its complexity. For some functions in Ride there are analogues that have less <code>complexity</code> due to the fact that they have a limit on the size of the argument. For example, the <code>sigVerify</code> function has a complexity of 200 and the maximum size of the first argument is 150 kb, but the standard library contains the functions<code> sigVerify_16kb</code>, <code>sigVerify_32kb</code>,<code> sigVerify_32kb</code>, <code>sigVerify_128kb</code>, with the values<code> complexity</code> 100, 110, 125 and 150, respectively. If you are sure that your argument cannot be larger than the values ​​specified in the function name, then you can use them and your script will have less complexity.</p>
<p>Not only is sigVeriry a family of functions, but also hashing functions, rsaVerify and groth16Verify, for example. You can always find a complete list of function families in the documentation.</p>
<h1 id="tools-for-developing-decentralized-applications">Tools for developing decentralized applications</h1>
<p>For the convenience of developing decentralized applications on Waves, there are a large number of different tools. It is worth starting, first of all, with the blockchain explorer, which is located at <a href="https://wavesexplorer.com">wavesexplorer.com</a> and allows you to analyze data in blocks, all transactions and UTX both in the main network and in stagenet and testnet.</p>
<p>However, if we are talking about the development of decentralized applications, and not just use, then several basic questions arise:</p>
<ol>
<li>In what environment should I write code for smart accounts, smart assets and decentralized applications?</li>
<li>How to test the written code? What are the options for automatic and manual testing?</li>
<li>How to debug the code?</li>
<li>How to deploy?</li>
</ol>
<p>Let's take a look at what tools are available for this.</p>
<h2 id="development-environment">Development environment</h2>
<p>The easiest way to get started writing code, testing and working with accounts is to use the online IDE, which is available at <a href="https://waves-ide.com/">https://waves-ide.com</a>. It has Ride syntax highlighting, smart hints, type inference, a compiler, a console for working with the <code>waves-transactions</code> library, and even a REPL (read-eval-print loop) for Ride, which allows Ride expressions to be executed right in the browser. There are also examples of code on Ride, examples of integration tests in JavaScript, the ability to manage accounts and send transactions using the web interface. The online IDE is great for testing contracts in stagenet and testnet. Waves tokens for these networks can be obtained for free using the faucet in wavesexplorer at the addresses <code>https: // wavesexplorer.com / stagenet / faucet</code> and<code> https: // wavesexplorer.com / testnet / faucet</code>, but no more than 10 Waves every 10 minutes.</p>
<p>However, for a more professional contract development, I recommend using other tools.</p>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=wavesplatform.waves-ride">Ride for Visual Studio Code</a> extension is the first essential tool for professional development using the Waves blockchain. Installing this extension allows you to get syntax highlighting and hints for files with the <code>.ride</code> extension.</p>
<p><img src="../../assets/6-4-0-vs-code-ext-in-store.png" alt="Visual Studio Code Extention for Ride" title="Visual Studio Code Extention for Ride"></p>
<p>In addition to syntax highlighting, the extension adds an interactive console to VS Code (just like in an online IDE), which allows you to run functions from <code>waves-transactions</code>,<code> waves-crypto</code> and several other specialized ones.</p>
<p><img src="../../assets/6-4-1-vc-code-ext.png" alt="Visual Studio Code Extention for Ride" title="Visual Studio Code Extention for Ride"></p>
<h2 id="local-environment">Local environment</h2>
<p>During development, you can interact with nodes from stagenet or testnet, which are available at the addresses <code>http: // nodes-stagenet.wavesnodes.com /</code> and <code>https: // nodes-testnet.wavesnodes.com /</code>, but the most convenient option is the use of a private blockchain from one single node.
You can run such a blockchain if you have Docker installed. The launch is carried out with a simple command:</p>
<pre class="hljs"><code><div>docker run -d -p 6869: 6869 wavesplatform / waves-private-node
</div></code></pre>
<p>After launching the command, the local blockchain will be launched as a Docker container, the node's API will be available at <code>http: // localhost: 6869 /</code>, and all 100 million tokens will be on the account balance with the seed phrase <code>waves private node seed with waves tokens </code>.</p>
<p><img src="../../assets/6-4-2-local-node.png" alt="Local node with API" title="Local node with API"></p>
<p>You can find detailed information about the Docker image with this node in <a href="https://github.com/wavesplatform/private-node-docker-image">this repository</a>.</p>
<p>The advantages of this approach are:</p>
<ul>
<li>Reduced block time: in testnet and stagenet, blocks are generated once a minute, while in your private network there will be every 10 seconds. This saves time when running integration tests.</li>
<li>Control over all tokens and no need to request tokens using a faucet</li>
<li>Full control over the node and API performance. The Waves Protocol team tries to ensure maximum availability of public nodes, but this is not always possible and in some cases APIs for stagenet or testnet may not be available.</li>
<li>API responses from public nodes are cached, which can cause unexpected errors.</li>
</ul>
<p>After starting the node, you can also launch a local blockchain explorer that will work with your node. This is done in the same way by deploying a Docker image:</p>
<pre class="hljs"><code><div>docker run -d -e API_NODE_URL = http: // localhost: 6869 -e NODE_LIST = http: // localhost: 6869 -p 3000: 80 wavesplatform / explorer
</div></code></pre>
<p>Please note that when expanding, the API address of our node with a private blockchain is indicated.</p>
<p>After deploying the image, the browser will be available at the address <code>http: // localhost: 3000</code>:</p>
<p><img src="../../assets/6-4-3-local-explorer.png" alt="Local explorer" title="Local explorer"></p>
<h2 id="testing-the-code">Testing the code</h2>
<p>At the time of this writing, it is possible to write only integration tests for decentralized applications on Ride. There are no tools for Unit tests yet. Integration testing in the case of Ride means that the written code is compiled, deployed using <code>SetScript</code>,<code> SetAssetScript</code> or <code>Issue</code> transactions on an asset or account, and transactions are executed that check the correctness of the script behavior. In other words, there is direct work with the blockchain (not emulation!) And real transactions are sent.</p>
<p>Integration tests can be written in Java using the <a href="https://github.com/msmolyakov/paddle">Paddle</a> library or in [JavaScript] using the online IDE or the <code>surfboard</code> library.</p>
<p>Surfboard can be installed from npm (provided you have node.js and npm) with the following command:</p>
<pre class="hljs"><code><div>npm install -g @ waves / surfboard
</div></code></pre>
<p>After that, you will have access to the <code>surfboard</code> utility right in the console. The <code>surfboard init</code> command will initialize a new project, which will contain a configuration file and directories for tests (<code>. / Test</code>) and scripts for Ride (<code>. / Ride</code>). The configuration file allows you to configure settings for working with different types of networks, account parameters, etc.</p>
<p><img src="../../assets/6-4-4-surfboard.png" alt="Surfboard" title="Surfboard"></p>
<p>In the <code>. / Test</code> directory, you can create any files with the<code> .js</code> extension and write integration tests in them using the <code>Mocha</code> test framework. In addition to the <code>Mocha</code> itself, functions from<code> waves-transactions</code> and several additional functions and variables are available in the test file:</p>
<ul>
<li><code>setupAccounts ({[key: string]: number})</code> - allows you to create new accounts at the beginning of the script and transfer tokens to them from the master seed</li>
<li><code>compile (file: File): String</code> - allows you to compile the contents of the file</li>
<li><code>file (path: String): File</code> - allows you to get the contents of a file</li>
<li><code>accounts</code> - an object that stores the seeds of accounts created by the<code> setupAccounts</code> function</li>
</ul>
<p>Descriptions of these and other functions are available <a href="https://wavesplatform.github.io/js-test-env/globals.html">in the documentation</a>. You can find test examples in the online IDE or in the <a href="https://github.com/wavesplatform/ride-examples">ride-examples</a> repository.</p>
<p>Running tests in the directory can be done using the command <code>surfboard test</code>, but if you want to run a specific file, and not all files in the directory<code>. / Test</code>, then you can execute <code>surfboard test my-scenario.js</code>.</p>
<h2 id="debugging-ride-scripts">Debugging Ride Scripts</h2>
<p>For debugging Ride scripts, it is customary to use 2 main techniques.</p>
<p>The online IDE and Surfboard have a REPL that allows you to enter the code and immediately get the result of the execution. The REPL allows not only performing basic operations, but also declaring variables, working with a real blockchain (for example, reading the state of accounts), calling functions of the standard library</p>
<p><img src="../../assets/6-4-5-surfboard-repl.png" alt="Surfboard REPL" title="Surfboard REPL"></p>
<p>In more complex situations, when you already have a full-fledged script that needs to be debugged, the <code>throw ()</code> function from the Ride standard library comes to the rescue, which allows you to throw an error and a text description to it. In the error text, you can also return the values ​​of variables, however, at the moment of exception, the node will return the contents of the stack, the values ​​of variables in the function, etc.</p>
<h2 id="manual-application-testing">Manual Application Testing</h2>
<p>If you prefer manual testing or want to play around with applications already deployed on the web, you can use the <a href="https://waves-dapp.com/">https://waves-dapp.com</a> website. You can simply specify the account address of the desired decentralized application and Waves-Dapp will show all available functions, what parameters they accept and allow you to call any of them. The tool can be useful for testing your application when you do not have an interface or tests for some functions, or you need to change the settings of your application.</p>
<p><img src="../../assets/6-4-6-waves-dapp.png" alt="Waves Dapp" title="Waves dapp"></p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-7-workshop-writing-web3-applications">Chapter 7. Workshop: Writing Web3 Applications</h1>
<h2 id="oraculus">Oraculus</h2>
<p>The best way to learn a language is to start writing in it. I cannot force you to write, so I will offer you the second coolest option - to read as you write the code! We'll go over a few examples of contracts, starting with the relatively simple ones, and ending up with the rather complex and fluffy ones.</p>
<h2 id="blockchain-and-data-from-the-real-world">Blockchain and data from the real world</h2>
<p>The blockchain works great with the data placed in it, but has no idea of ​​what is happening in the real world. The blockchain cannot, for example, access an external API and get data from it, because the determinism of operations will be violated. If each node accesses the external API at a different time, they can all get different results, and as a result, the blockchain nodes will never come to a consensus, because it is not clear which one should be trusted.
To solve this problem, instead of the “pull” model (when data is transferred to the real world), it is customary to use the “push” model, in which suppliers save data on the blockchain, and any decentralized applications can use it.
The entities that store data on the blockchain are called oracles. But the problem with oracles is that they are centralized, that is, we trust one entity that supplies the data. In general, a system is as centralized as the “worst” part of it is centralized. That is, a decentralized application that uses data from one oracle to make important decisions is in fact centralized. Why? The logic is simple: by influencing the behavior of one entity - the oracle - you can achieve the desired behavior from the entire application.
The idea of ​​decentralized oracles is on the surface, but there is no easy solution here, and therefore often talk about the &quot;problem of oracles&quot;. Let's see how you can solve it.</p>
<blockquote>
<p>If a decentralized application relies on the data of one oracle, then such an application is not decentralized.</p>
</blockquote>
<h2 id="the-simplest-version-of-decentralized-oracles">The simplest version of decentralized oracles</h2>
<p>The simplest solution is multisignature: several users come to a consensus and sign the same data. For example, we want to receive data on the USD / EUR rate, and we have five oracles that must agree on a consensus value (outside the blockchain), sign the transaction and send it to the network to a special account, which will only accept it if there is at least three signatures out of five. The simplest contract in this case would look like this:</p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">3</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

# array of <span class="hljs-number">5</span> public keys
let pks = [base58 '', base58 '', base58 '', base58 '', base58 '']

# inner fold step <span class="hljs-keyword">for</span> each signature
func signedBy (pk: <span class="hljs-type">ByteVector</span>) = {
   # is signed by the public key or not
   func f (acc: <span class="hljs-type">Boolean</span>, sig: <span class="hljs-type">ByteVector</span>)
      = acc || sigVerify (tx.bodyBytes, sig, pk)
   <span class="hljs-type">FOLD</span> &lt;<span class="hljs-number">8</span>&gt; (tx.proofs, <span class="hljs-literal">false</span>, f)
}

# outer fold step <span class="hljs-keyword">for</span> each public key
func signedFoldStep (acc: <span class="hljs-type">Int</span>, pk: <span class="hljs-type">ByteVector</span>)
   = acc + (<span class="hljs-keyword">if</span> (signedBy (pk)) then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)

# comparing total number of correct signatures
# to required number of correct signatures
<span class="hljs-type">FOLD</span> &lt;<span class="hljs-number">5</span>&gt; (pks, <span class="hljs-number">0</span>, signedFoldStep)&gt; = <span class="hljs-number">3</span>
</div></code></pre>
<blockquote>
<p>Note that this function is a multisignature 3 out of 5. In the previous chapter we looked at 2 out of 3. In contrast to the example above, the script above does not make assumptions about which signature is where in the <code>proofs</code> array, but checks each field from<code> proofs</code> relative to each public key.</p>
</blockquote>
<p>But this approach has several problems:</p>
<ul>
<li>In the absence of consensus among the oracles, the data simply will not enter the blockchain</li>
<li>Data providers have no economic motivation</li>
<li>Predefined limited list of oracles.</li>
</ul>
<p>To solve these problems, you can make a full-fledged decentralized application, which is a marketplace where two sides meet:</p>
<ol>
<li>Applications that need data</li>
<li>Oracles willing to supply this data for a fee</li>
</ol>
<p>Let's formulate the basic functional requirements for such an application and implement it using Ride and the Waves blockchain.</p>
<h2 id="decentralized-oracle-as-dapp">Decentralized oracle as dApp</h2>
<p>The basic principles of decentralized oracles will be as follows:</p>
<ul>
<li>The owner of any decentralized application should be able to request data in a specific format and with a specific reward for oracles</li>
<li>Anyone should be able to register their oracle and answer inquiries, receiving a reward for this</li>
<li>All actions of oracles must be auditable.</li>
</ul>
<h3 id="request-data">Request data</h3>
<p>Any account on the blockchain can send a question to the oracles. When submitting a question, you must attach a reward for oracles for providing correct data (in WAVES tokens). The following parameters must be specified in the question:</p>
<ul>
<li><code>id</code> - unique identifier of each question, generated by its sender. Requirements: no dApp has the same key, no more than 64 characters.</li>
<li><code>question</code> - the actual question. It is generated in a special format for each data type. At the beginning of the question, you need to specify the data type, after the separator // there is metadata in JSON format. For example, for the Temperature data type, the question looks like this: <code>Temperature // {&quot; lat &quot;:&quot; 55.7558 &quot;,&quot; lon &quot;:&quot; 37.6173 &quot;,&quot; timestamp &quot;: 150000000000,&quot; responseFormat &quot;:&quot; NN.NN &quot;}</code></li>
<li><code>consensusType</code> - data aggregation rule. For string data types, the contract provides only consensus (complete coincidence of answers), and for numeric data types, <code>median</code> and<code> average</code> are also possible</li>
<li><code>minOraclesCount</code> - the minimum number of oracles that must provide data to obtain the final consensus result. The value cannot be less than 3</li>
<li><code>maxOraclesCount</code> - the maximum number of oracles that can answer the question. Not more than 6</li>
<li><code>oraclesWhiteList</code> - a list of oracles (public keys separated by commas) that should provide data. If the parameter value is equal to an empty string, then any oracle can answer the data request</li>
<li><code>tillHeight</code> - deadline for reaching consensus. If by this time the consensus between the oracles has not been reached (the number of responses&gt; <code>minOraclesCount</code> has not been reached), then the requestor can collect the reward.</li>
</ul>
<p>The format of the data request type will be left to the discretion of the request senders and oracles, but as an example I suggest the following:</p>
<ul>
<li><code>Temperature // {&quot; lat &quot;:&quot; 55.7558 &quot;,&quot; lon &quot;:&quot; 37.6173 &quot;,&quot; timestamp &quot;: 150000000000,&quot; responseFormat &quot;:&quot; NN.NN &quot;}</code></li>
<li><code>Pricefeed // {&quot; pair &quot;:&quot; WAVES / USDN &quot;,&quot; timestamp &quot;: 150000000000,&quot; responseFormat &quot;:&quot; NN.NNNN &quot;}</code></li>
<li><code>Sports // {&quot; event &quot;:&quot; WC2020 &quot;,&quot; timestamp &quot;: 150000000000,&quot; responseFormat &quot;:&quot;% s &quot;}</code></li>
<li><code>Random // {&quot; round &quot;: 100,&quot; responseFormat &quot;:&quot;% s &quot;}</code></li>
</ul>
<h3 id="collecting-oracle-responses">Collecting oracle responses</h3>
<p>Any Waves account can register as an oracle of a certain type of data. To do this, it is enough to call the method of the decentralized application and pass the supplied data type as an argument. An example call might look like this - <code>registerAsOracle (&quot; Temperature &quot;)</code>. At this moment, the dApp state will record at what moment the oracle was registered as a provider of a certain data type, and the following will be written: <code>{oraclePublicKey} _Temperature = {current_height}</code>.</p>
<p>The oracle responds with the <code>response (id: String, data: String)</code> and <code>responseNumber (id: String, data: Integer)</code> methods.</p>
<h3 id="counting-results">Counting Results</h3>
<p>To count the results, call the <code>getResult (id: String)</code> method. Counting of results is possible only if more oracles answered than specified in minOraclesCount. When choosing the correct answer, it is not the simple majority that is used, but the ratings of the oracles. The rating is formed according to the following logic:</p>
<ul>
<li>upon registration, each oracle has a rating of 100</li>
<li>for each answer, which eventually became the result of the request, +1 rating is added to the oracle's rating, for each wrong answer - -1.</li>
</ul>
<p>Let's imagine that 5 oracles with the following ratings and responses responded to the request <code>Sports // {&quot; event &quot;:&quot; WorldCup2020 &quot;,&quot; timestamp &quot;: 150000000000,&quot; responseFormat &quot;:&quot;% s &quot;}</code>:</p>
<ol>
<li>Oracle0, rating = 102, answer = &quot;France&quot;</li>
<li>Oracle1, rating = 200, answer = &quot;Croatia</li>
<li>Oracle2, rating = 63, answer = &quot;France&quot;</li>
<li>Oracle3, rating = 194, answer = &quot;France&quot;</li>
<li>Oracle4, rating = 94, answer = &quot;Croatia&quot;</li>
</ol>
<p>The final result will be <code>France</code>, since the total rating of oracles with this answer is 359, and the rating of oracles that answered Croatia is 294.</p>
<p>As a result of the vote counting procedure, the ratings of the oracles <code>Oracle0</code>,<code> Oracle2</code> and <code>Oracle3</code> will be increased by 1, and they will be able to collect the reward, while the ratings of<code> Oracle1</code> and <code>Oracle4</code> will be decreased by one, and they will not receive rewards.</p>
<h2 id="implementation">Implementation</h2>
<p>Let's take a step-by-step implementation of such a decentralized application. The most logical place to start is with the oracle registration method, which will take as an argument the type of data provided by the oracle. If a single oracle with one public key provides multiple data types, it must register multiple times.</p>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Callable</span> (i)
func registerAsOracle (dataType: <span class="hljs-type">String</span>) = {
    let neededKey = i.callerPublicKey.toBase58String () + <span class="hljs-string">"_"</span> + dataType
    let ratingKey = i.callerPublicKey.toBase58String () + <span class="hljs-string">"_rating"</span>

    let currentRating = <span class="hljs-keyword">match</span> getInteger (<span class="hljs-keyword">this</span>, ratingKey) {
        <span class="hljs-keyword">case</span> v: <span class="hljs-type">Int</span> =&gt; v
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">100</span>
    }
    <span class="hljs-keyword">match</span> (getString (i.caller, neededKey)) {
        <span class="hljs-keyword">case</span> data: <span class="hljs-type">String</span> =&gt; <span class="hljs-keyword">throw</span> (<span class="hljs-string">"This oracle is registered already"</span>)
        <span class="hljs-keyword">case</span> _ =&gt; {
            [
                <span class="hljs-type">StringEntry</span> (neededKey, toString (height)),
                <span class="hljs-type">IntegerEntry</span> (ratingKey, currentRating)
            ]
        }
    }
}
</div></code></pre>
<p>The next logical step would be to implement functionality for sending requests for data. As described above, a request to submit data must include the following arguments:</p>
<ul>
<li><code>id</code> - unique identifier of each question</li>
<li><code>question</code> - the actual question in a predetermined format</li>
<li><code>consensusType</code> - data aggregation rule:<code> consensus</code>, <code>median</code> or<code> average</code>.</li>
<li><code>minOraclesCount</code> - the minimum number of oracles.</li>
<li><code>maxOraclesCount</code> - the maximum number of oracles.</li>
<li><code>oraclesWhiteList</code> - a list of oracles (public keys separated by commas or empty string)</li>
<li><code>tillHeight</code> - deadline for reaching consensus.</li>
</ul>
<p>The function should write the request parameters, the amount of the reward, as well as the public key of the requestor and the keys, by which we will record the number of responses, the responses themselves, the public keys of the responding oracles and the request completion flag, to the contract state.</p>
<p>At the time of requesting data, it is necessary to check the arguments for the following conditions:</p>
<ul>
<li>If the &quot;white list&quot; of oracles is specified, then the length of the line with their public addresses should not exceed 1000 characters (function <code>checkOraclesWhiteListLengthLt1000</code>)</li>
<li>Unique request identifier must not exceed 32 characters (function <code>checkRequestIdLt32</code>)</li>
<li>Request identifier must not have been used previously (function <code>checkIdIsNotUsed</code>)</li>
<li>Each request must have a reward in WAVES tokens (function <code>checkPaymentInWavesGt0</code>)</li>
<li>The minimum number of oracles is 3, and the maximum is 6 (function <code>checkOraclesCountGt3Lt6</code>)</li>
<li>The value of the minimum number must be less than or equal to the maximum (function <code>checkOraclesWhiteListCountGtMinCount</code>).</li>
</ul>
<p>All code listingb below includes calls to helper functions that are not shown in this book, but you can find them in the <a href="https://github.com/wavesplatform/ride-examples">Ride examples</a> repository</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func request (id: <span class="hljs-type">String</span>, question: <span class="hljs-type">String</span>, minResponsesCount: <span class="hljs-type">Int</span>, maxResponsesCount: <span class="hljs-type">Int</span>, oraclesWhiteList: <span class="hljs-type">String</span>, tillHeight: <span class="hljs-type">Int</span>) = {
        let whiteList = checkOraclesWhiteListLengthLt1000 (oraclesWhiteList)
        let checkedRequestIdLt64 = checkRequestIdLt32 (id)
        let requestId = checkIdIsNotUsed (checkedRequestIdLt64)
        let paymentAmount = checkPaymentInWavesGt0 (i.payments [<span class="hljs-number">0</span>] .extract ())
        let minCount = checkOraclesCountGt3Lt6 (minResponsesCount, maxResponsesCount)
        let maxCount = checkOraclesWhiteListCountGtMinCount (oraclesWhiteList, minCount, maxResponsesCount)
        let callerPubKey = toBase58String (i.callerPublicKey)
        [
            <span class="hljs-type">StringEntry</span> (keyQuestion (requestId), question),
            <span class="hljs-type">StringEntry</span> (keyOraclesWhiteList (requestId), whiteList),
            <span class="hljs-type">StringEntry</span> (keyRequesterPk (requestId), callerPubKey),
            <span class="hljs-type">StringEntry</span> (keyResponders (requestId), <span class="hljs-string">""</span>),
            <span class="hljs-type">StringEntry</span> (requestId, question),
            <span class="hljs-type">IntegerEntry</span> (keyMinResponsesCount (requestId), minCount),
            <span class="hljs-type">IntegerEntry</span> (keyMaxResponsesCount (requestId), maxCount),
            <span class="hljs-type">IntegerEntry</span> (keyResponsesCount (requestId), <span class="hljs-number">0</span>),
            <span class="hljs-type">IntegerEntry</span> (keyTillHeight (requestId), tillHeight),
            <span class="hljs-type">IntegerEntry</span> (keyRequestHeight (requestId), height),
            <span class="hljs-type">IntegerEntry</span> (keyPayment (requestId), paymentAmount),
            <span class="hljs-type">BooleanEntry</span> (keyRequestIsDone (id), <span class="hljs-literal">false</span>)
        ]
}

</div></code></pre>
<p>Fine! We already have functions for registering oracles and sending requests from users. Now let's implement the functionality of sending a response from a single oracle.</p>
<h3 id="response-to-data-request">Response to data request</h3>
<p>Each oracle can respond to a request if there is no whitelist limit and the request is not completed (by the number of responses or duration). At the moment of response to the request, the public key of the oracle and its response are recorded in the storage of the decentralized application; for this, at the moment of sending the request, the keys <code>{id} _responders</code> and<code> {id} _responses</code> were created. The data in these keys is stored as strings separated by <code>;</code>.</p>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Callable</span> (i)
func response (id: <span class="hljs-type">String</span>, data: <span class="hljs-type">String</span>) = {

    # <span class="hljs-type">Step</span> <span class="hljs-number">0</span> - checking the validity of the provided data
    let requestId = checkIdExists (id)
    let checkedData = checkDataIllegalCharacters (data)

    # <span class="hljs-type">Step</span> <span class="hljs-number">1</span> - check the status of the request (the number of responses already)
    let currentResponsesCount = getResponsesCount (id)
    let newResponsesCount = checkNewResponsesCount (currentResponsesCount, id)

    # <span class="hljs-type">Step</span> <span class="hljs-number">2</span> - checking <span class="hljs-keyword">if</span> the oracle is included in the white list and whether it has already answered the request
    let oraclePubKey = i.callerPublicKey.toBase58String ()
    let oracleIsAllowed = checkOracleInWhiteList (oraclePubKey, id) == <span class="hljs-literal">true</span> || checkOracleResponded (oraclePubKey, id) == <span class="hljs-literal">false</span>
    let maxHeight = getIntegerValue (<span class="hljs-keyword">this</span>, keyTillHeight (id))
    let isDone = getBooleanValue (<span class="hljs-keyword">this</span>, keyRequestIsDone (id)) == <span class="hljs-literal">true</span>
    let requestIsActive = maxHeight&gt; height || isDone

    <span class="hljs-keyword">if</span> (oracleIsAllowed == <span class="hljs-literal">false</span>) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Oracle is not in the white list or already responded"</span>) <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">if</span> (requestIsActive == <span class="hljs-literal">false</span>) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Request is not active anymore due to max height ("</span> + maxHeight.toString () + <span class="hljs-string">"/"</span> + height.toString () + <span class="hljs-string">") or it is just done ("</span> + isDone .toString () + <span class="hljs-string">")"</span>)
    <span class="hljs-keyword">else</span> {

        let currentResponders = getResponders (id)
        let currentResponses = getResponses (id)

        let newResponders = <span class="hljs-keyword">if</span> currentResponders == <span class="hljs-string">""</span> then oraclePubKey
            <span class="hljs-keyword">else</span> currentResponders + <span class="hljs-string">";"</span> + oraclePubKey
        let newResponses = <span class="hljs-keyword">if</span> currentResponses == <span class="hljs-string">""</span> then checkedData
            <span class="hljs-keyword">else</span> currentResponses + <span class="hljs-string">";"</span> + checkedData


        let currentResponsePoints = getCurrentResponsePoints (id, checkedData)

        let oracleRating = getOracleRating (oraclePubKey)

        let newResponsePoint = currentResponsePoints + <span class="hljs-keyword">if</span> oracleRating &lt;<span class="hljs-number">200</span> then oracleRating / <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> log (oracleRating, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-type">HALFEVEN</span>)


        [
            <span class="hljs-type">IntegerEntry</span> (keyCurrentResponsePoints (requestId, checkedData), newResponsePoint),
            <span class="hljs-type">IntegerEntry</span> (keyResponsesCount (requestId), newResponsesCount),
            <span class="hljs-type">StringEntry</span> (keyResponseFromOracle (requestId, oraclePubKey), checkedData),
            <span class="hljs-type">StringEntry</span> (keyResponders (requestId), newResponders),
            <span class="hljs-type">StringEntry</span> (keyResponses (requestId), newResponses),
            <span class="hljs-type">BooleanEntry</span> (keyTookPayment (requestId, oraclePubKey), <span class="hljs-literal">false</span>),
            # <span class="hljs-type">StringEntry</span> (keyOneResponse (requestId, i, checkedData), newResponders), newResponsePoint)
        ]
    }
}
</div></code></pre>
<p>Also, during the response, we increase the counter of the number of respondents to the request and the amount of points scored by this response (points are equal to the sum of the oracle ratings).</p>
<h3 id="collecting-results">Collecting Results</h3>
<p>After the data is sent by the oracles, the results are summed up in the form of a result (consensus, mean or median) and the change in the ratings of the oracles. In this function, we could also pay immediately a part of the remuneration to the oracles who answered correctly, but in view of the limitation on the complexity of the contract at 4000, it will not be possible to do this within the framework of one function. However, we can record in the account storage who has the right to take part of the reward and allow the oracles themselves to call a special function for receiving the reward. Let me remind you that only oracles whose answer coincided with the final one (or all oracles with an answer within 10% of the result, if the average value or median was requested) have the right to take part of the reward.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func getResult (id: <span class="hljs-type">String</span>) = {
    <span class="hljs-keyword">if</span> (keyIsDefined (id) == <span class="hljs-literal">false</span>) then throwIdError (id) <span class="hljs-keyword">else</span> {
        let responsesCount = getResponsesCount (id)
        let minResponsesCount = getMinResponsesCount (id)
        <span class="hljs-keyword">if</span> (responsesCount &lt;minResponsesCount) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Minimum oracles count not reached yet"</span>) <span class="hljs-keyword">else</span> {
            let result = calculateResult (id)
            let ratingsDiff = getOracleRatingsDiff (id, result)
            let resultKey = keyResult (id)
            let resultDataEntry = <span class="hljs-type">StringEntry</span> (resultKey, result)
            let dataToWrite = cons (resultDataEntry, ratingsDiff)

            dataToWrite
        }
    }
}
</div></code></pre>
<h3 id="receiving-a-reward">Receiving a reward</h3>
<p>The function of receiving a reward for an oracle should allow withdrawing funds only once and after confirming that this oracle really answered the request and its answer is considered correct.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func takeReward (id: <span class="hljs-type">String</span>) = {
    <span class="hljs-keyword">if</span> (keyIsDefined (id) == <span class="hljs-literal">false</span>) then throwIdError (id) <span class="hljs-keyword">else</span> {
        let paymentValue = getIntegerValue (<span class="hljs-keyword">this</span>, keyPayment (id))
        let oraclePubKey = i.callerPublicKey.toBase58String ()
        let oracleResponseKey = keyResponseFromOracle (id, oraclePubKey)
        let oracleResponse = getStringValue (<span class="hljs-keyword">this</span>, oracleResponseKey)

        let resultKey = keyResult (id)
        let resultDataEntry = getStringValue (<span class="hljs-keyword">this</span>, resultKey)

        let alreadyTookKey = keyTookPayment (id, oraclePubKey)
        let alreadyTookPayment = getBooleanValue (<span class="hljs-keyword">this</span>, alreadyTookKey)

        let responsesCount = getResponsesCount (id)

        <span class="hljs-keyword">if</span> (oracleResponse == resultDataEntry &amp;&amp; alreadyTookPayment == <span class="hljs-literal">false</span>) then {
            let paymentAmount = paymentValue / responsesCount
            [
              <span class="hljs-type">BooleanEntry</span> (alreadyTookKey, <span class="hljs-literal">true</span>),
              <span class="hljs-type">ScriptTransfer</span> (i.caller, paymentAmount, unit)
          ]
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Already took payment or provided data was not valid"</span>)
        }

    }
}
</div></code></pre>
<p>This completes the basic functionality of the oracle consensus contract. Examples of how to work with such a contract can be found in the form of tests in the <a href="https://github.com/wavesplatform/ride-examples/branch/refactor">Ride examples</a> repository</p>
<h2 id="opportunities-for-development">Opportunities for development</h2>
<p>The implemented functionality is the simplest way of working for decentralized oracles. We have solved the problems outlined at the beginning of the article:</p>
<ul>
<li>There will always be data in the blockchain, even if not all oracles reach consensus</li>
<li>Participants in the process have an economic and reputational motivation to participate in the provision of data</li>
<li>The list of oracles can be as wide as possible, but at the same time, it can be limited for your request, if, for example, we want to receive data not from any oracles, but only from those we trust.</li>
</ul>
<p>Due to the fact that the request formats are typed, the provision of responses can be automated, for example, in the form of a browser extension that monitors requests to the address of the decentralized application and responds to data if the type of requested data is supported by the extension. A scenario is also possible when users with an open browser can make money by providing data without doing anything with their own hands.</p>
<p>In many cases, the data is not needed one-time, but in the form of a constant stream. In our decentralized application, the data subscription functionality is not implemented, but we would be happy to get the community to contribute to this example.</p>
<h1 id="billy">Billy</h1>
<p>The second project that we will consider as part of our introduction to Ride is the Billy application.</p>
<p>Billy is a decentralized application (dApp) in the form of a bot for the corporate messenger Slack. You can read more about how Billy works on the official website of the project - <a href="https://iambilly.app">https://iambilly.app</a>. And here I will briefly tell you what parts Billy is made of and how exactly the blockchain is used in it.</p>
<p>Billy is a project to motivate company employees. In the course of work, situations often arise when we help colleagues or they help us. And it is far from always that such assistance is the direct responsibility of colleagues. To encourage colleagues to help each other, you can add Billy to Slack with one button on the project site.</p>
<p>Billy generates a unique address for each employee and stores it in the database. Every month the bot credits 500 “Thank you” tokens to the generated addresses, which can be spent using the same bot. To send tokens, company employees can use special commands (<code>10 thanks @ username</code>) or simply respond to messages using special emoji.</p>
<p><img src="../../assets/7-2-1-emoji.png" alt="Emoji reaction" title="Emoji reaction"></p>
<p>The unused balance of 500 automatically accrued “Thank you” tokens expires at the end of the month. The tokens received from colleagues do not burn out and can be used in three ways:</p>
<ul>
<li><strong>Transfer to other users as a thank you.</strong> Received tokens can be transferred to colleagues at any time</li>
<li><strong>Purchase of goods in the internal store.</strong> The internal store of the company allows its employees (and / or other authorized persons) to offer goods and services in exchange for thank you tokens</li>
<li><strong>Participation in polls and crowdfunding campaigns.</strong> Any user can indicate the purpose for which he collects tokens (for example, holding an internal meetup). Also, the company's management can initiate voting, in which each token will be considered one vote, which means that a more &quot;useful&quot; and active employee will have a greater impact on the voting results. In addition to the required number of tokens, each crowdfunding campaign has an expiration date and implementation period. The voting mechanism is similar to the DAO - a decentralized autonomous organization.</li>
</ul>
<p>A video demonstration of the bot's work can be found on the <a href="https://iambilly.app">project website</a>. The system hides everything related to the blockchain for users as much as possible. If necessary, the user can request his seed phrase and use tokens outside of Slack, however, by default, in order not to create unnecessary barriers, all implementation details are hidden from him.</p>
<blockquote>
<p><strong>Billy is free for all companies, so it's best to understand its mechanics very quickly and simply: add to Slack and start using.</strong></p>
</blockquote>
<h2 id="whats-%22under-the-hood%22">What's &quot;under the hood&quot;?</h2>
<p>Before moving on to the implementation of the idea, let's describe all the requirements for entities in the blockchain in a more formal way:</p>
<ol>
<li>A unique token is issued for each team in Slack, which will be the team's internal currency</li>
<li>A separate account is created for each team member, where only the tokens of this team are stored</li>
<li>Team tokens can only be transferred between team members, so the list of team members' addresses must be stored somewhere</li>
<li>Any team member can &quot;burn&quot; their tokens</li>
<li>Participation in the vote is carried out through calls to dApp functions with attached team tokens</li>
<li>In each vote, the user receives a unique NFT token, which confirms his vote.</li>
</ol>
<p>The system is complex and must include several scripts. The first step - issuing a token to the team - is a fairly straightforward operation of sending the <code>Issue</code> of a transaction (we looked at the example in Chapter 5). We do not want users of the system to buy WAVES to pay commission for transfers. Therefore, we use the sponsorship function. This will allow users to pay for transactions in Thank You tokens, and WAVES fees will be deducted from the team admin account.</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> adminSeed = <span class="hljs-string">'...'</span>;
    <span class="hljs-keyword">const</span> issueTx = issue ({
        <span class="hljs-attr">name</span>: <span class="hljs-string">`Thanks`</span>,
        <span class="hljs-attr">description</span>: <span class="hljs-string">'Say thank you to all of your teammates in Slack. By Billy. '</span>,
        <span class="hljs-attr">decimals</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">quantity</span>: <span class="hljs-number">100000000</span>,
        <span class="hljs-attr">reissuable</span>: <span class="hljs-literal">false</span>
    }, adminSeed);

    <span class="hljs-keyword">await</span> broadcast (issueTx);
    <span class="hljs-keyword">await</span> waitForTx (issueTx.id);
    <span class="hljs-keyword">const</span> sponsorshipTx = sponsorship ({
        <span class="hljs-attr">assetId</span>: issueTx.id,
        <span class="hljs-attr">minSponsoredAssetFee</span>: <span class="hljs-number">1</span>
    }, adminSeed);
    <span class="hljs-keyword">await</span> broadcast (sponsorshipTx);
</div></code></pre>
<p>We use the <code>waitForTx</code> function from the<code> waves-transactions</code> library to make sure that the token issuance transaction hits the blockchain, and only then send the sponsoring transaction.</p>
<p>To some extent, the use of sponsorship limits the fulfillment of other requirements: sponsorship cannot be used in conjunction with smart assets. That is, at the token level, we cannot impose a restriction on the transfer of tokens only to other team members. In the future, with the implementation of the proposal <a href="https://forum.wavesplatform.com/t/wep-2-customizable-sponsorship/15880">WEP-2 Customizable sponsorship</a> it will become possible to enable sponsorship for smart assets. Until then, we can find another solution. For example, a script can be placed on the account of each team member (making it a smart account) that will check if the recipient of tokens is in the list of colleagues and, accordingly, approve or deny the transaction.</p>
<p>The list of team members' addresses must also be stored on the blockchain. Since we have a decentralized app for shopping and voting, we can add a feature to manage the list of team members.</p>
<p>Let's create a decentralized application that allows you to add or remove a person from the list. The add to list function will take an address as an argument and add a key-value pair to the store, where the key is the address and the value is <code>true</code>. The delete function will update the record in the repository and translate the value for the specified address to <code>false</code>.</p>
<pre class="hljs"><code><div>
{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">DAPP</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

let adminPublicKey = base58 '...'

func addToWhiteList (address: <span class="hljs-type">String</span>) = {
    let userInTheList = getBoolean (<span class="hljs-keyword">this</span>, address)
    let newValue = <span class="hljs-keyword">match</span> userInTheList {
        <span class="hljs-keyword">case</span> b: <span class="hljs-type">Boolean</span> =&gt; {
            <span class="hljs-keyword">if</span> b then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"User is already in the list and enabled"</span>)
            <span class="hljs-keyword">else</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">if</span> i.callerPublicKey! = adminPublicKey then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Only admin can call this function"</span>) <span class="hljs-keyword">else</span>
    [
        [<span class="hljs-type">BooleanEntry</span> (address, newValue)]
    ]
}

<span class="hljs-meta">@Callable</span> (i)
func removeFromWhiteList (address: <span class="hljs-type">String</span>) = {
    <span class="hljs-keyword">if</span> i.callerPublicKey! = adminPublicKey then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Only admin can call this function"</span>)
    <span class="hljs-keyword">else</span> [<span class="hljs-type">BooleanEntry</span> (address, <span class="hljs-literal">false</span>)]
}
</div></code></pre>
<p>Let's write the smart account code that will be installed for each team member:</p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

# specify the id of the token that we issued <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> command
let assetId = base58 '...'
# address of the account that will host the decentralized application and a list of team members' accounts
let whiteListAddress = <span class="hljs-string">"..."</span>

<span class="hljs-keyword">match</span> tx {
    # <span class="hljs-type">Any</span> team member can burn their tokens
    <span class="hljs-keyword">case</span> b: <span class="hljs-type">BurnTransaction</span> =&gt; {
        sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], tx.senderPublicKey)
    }

    # <span class="hljs-type">Updating</span> <span class="hljs-keyword">this</span> script is possible <span class="hljs-keyword">if</span> there are <span class="hljs-number">2</span> signatures - a team member
    # and the team administrator, from whose account the token <span class="hljs-keyword">for</span> the team is issued
    <span class="hljs-keyword">case</span> s: <span class="hljs-type">SetScriptTransaction</span> =&gt; {
        let assetIssuerPublicKey = assetInfo (assetId) .extract (). issuerPublicKey
        sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], tx.senderPublicKey) &amp;&amp;
        sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">1</span>], assetIssuerPublicKey)
    }

    # <span class="hljs-type">Team</span> tokens can only be transferred between team members, other tokens can
    # translated <span class="hljs-keyword">if</span> there is an account signature
    <span class="hljs-keyword">case</span> t: <span class="hljs-type">TransferTransaction</span> =&gt; {
        # <span class="hljs-type">If</span> the transferred token is <span class="hljs-type">NOT</span> a command token, then check the signature
        <span class="hljs-keyword">if</span> t.assetId! = assetId then sigVerify (t.bodyBytes, t.proofs [<span class="hljs-number">0</span>], t.senderPublicKey) <span class="hljs-keyword">else</span>
        {
            # get the address of the recipient of tokens as a string
            let recipientAddress = addressFromRecipient (t.recipient) .toString ()

            # translate the address of the decentralized application of the command into the <span class="hljs-type">Address</span> <span class="hljs-class"><span class="hljs-keyword">type</span></span>
            let whiteListAddressValue = addressFromStringValue (whiteListAddress)

            # read the value from the repository of the command decentralized application by key
            # equal to the textual representation of the recipient address of the current transaction
            let addressIsAllowed = getBoolean (whiteListAddressValue, recipientAddress)

            # check that the value received from the storage is == <span class="hljs-literal">true</span>
            # otherwise (<span class="hljs-keyword">if</span> <span class="hljs-literal">false</span> or <span class="hljs-type">Unit</span>) then write <span class="hljs-literal">false</span> to the variable
            let addressInWhiteList = <span class="hljs-keyword">match</span> addressIsAllowed {
                <span class="hljs-keyword">case</span> b: <span class="hljs-type">Boolean</span> =&gt; b == <span class="hljs-literal">true</span>
                <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>
            }

            # <span class="hljs-keyword">if</span> the recipient<span class="hljs-symbol">'s</span> address is in the list of employees
            # or tokens are transferred to the command<span class="hljs-symbol">'s</span> decentralized application, then
            # check the transaction signature (must be signed <span class="hljs-keyword">with</span> the account key)
            <span class="hljs-keyword">if</span> ((addressInWhiteList || recipientAddress == whiteListAddress)) then {
                <span class="hljs-keyword">if</span> (sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], tx.senderPublicKey))
                then <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Signature is required"</span>)
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You can send this token only to white-listed addresses"</span>)
            }
        }
    }

    # <span class="hljs-type">If</span> a function of a decentralized application is called
    # then we only allow the command application to be called
    <span class="hljs-keyword">case</span> i: <span class="hljs-type">InvokeScriptTransaction</span> =&gt; {
        # get the address of the called application as a string
        let dappCalledAddress = addressFromRecipient (i.dApp) .toString ()

        # <span class="hljs-keyword">if</span> the address of the called application is equal to the address of the command application, then
        # require user signature
        # otherwise we prohibit the call
        <span class="hljs-keyword">if</span> (dappCalledAddress! = whiteListAddress) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You can call only dApp with address"</span> + whiteListAddress + <span class="hljs-string">", but you're trying to call"</span> + dappCalledAddress) <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">if</span> (sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], tx.senderPublicKey) == <span class="hljs-literal">false</span>) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Transaction should be signed with users key"</span>) <span class="hljs-keyword">else</span>
        <span class="hljs-literal">true</span>
    }

    # <span class="hljs-type">We</span> prohibit all other types of transactions, including exchange, token issuance, etc.
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Bad transaction type"</span>)
}

</div></code></pre>
<p>The scripts described above will satisfy the following requirements:</p>
<ol>
<li>A unique token is issued for each team in Slack, which will be the team's internal currency</li>
<li>For each team member, a separate account is created, which stores the tokens of this team</li>
<li>Team tokens can only be transferred between team members, so the list of team members' addresses must be stored somewhere</li>
<li>Any team member can &quot;burn&quot; their tokens</li>
</ol>
<p>However, two more requirements must be met:</p>
<ol>
<li>Participation in the vote is carried out through calls to dApp functions with attached team tokens</li>
<li>For each vote, the user receives a unique NFT token, which confirms his vote</li>
</ol>
<p>Any member of the team can initiate voting and fundraising for any purpose (hereinafter referred to as a fundraising campaign). To do this, you need to call the function of the decentralized application, specifying:</p>
<ul>
<li>unique identificator</li>
<li>end time of fundraising / voting</li>
<li>project implementation period</li>
<li>the amount of fees at which the campaign is considered successful</li>
</ul>
<p>In order not to disclose inside information, we will not provide a title or description in the decentralized application. Campaign data (title, description) can be stored in a centralized database available to company employees.</p>
<p>If the campaign was successful, that is, the amount collected is greater than the amount declared at the time of the campaign creation, then the tokens must be locked on the contract until the due date. After that, investors start voting on the implementation of the project. If the project, in the opinion of most investors, has been implemented, then the tokens on the contract are unlocked and the campaign creator receives them. Otherwise, the tokens remain on the contract forever. This scheme allows you to avoid situations when tokens are collected, and the stated goal is not realized.</p>
<p>Now let's implement the application step by step.</p>
<p>The function to start a fundraising and voting campaign can be as follows:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func startFunding (id: <span class="hljs-type">Int</span>, fundraisingEndTimestamp: <span class="hljs-type">Int</span>, implmenetationEndTimestamp: <span class="hljs-type">Int</span>, targetSum: <span class="hljs-type">Int</span>) = {
    # current time
    let lastBlockTimestamp = lastBlock.timestamp

    # <span class="hljs-type">Campaign</span> end time cannot be less than <span class="hljs-number">60</span> seconds
    <span class="hljs-keyword">if</span> (fundraisingEndTimestamp - lastBlockTimestamp - <span class="hljs-number">60</span> &lt;<span class="hljs-number">0</span>) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"End time should at least 60 seconds more than the last block time"</span>) <span class="hljs-keyword">else</span>

    # <span class="hljs-type">The</span> end time of fundraising cannot be less than the project release date
    <span class="hljs-keyword">if</span> (implmenetationEndTimestamp &lt;fundraisingEndTimestamp) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Implementation end time should more or equal to endTimestamp"</span>) <span class="hljs-keyword">else</span>

    # <span class="hljs-type">Campaign</span> <span class="hljs-type">ID</span> must be unique
    <span class="hljs-keyword">if</span> (isDefined (getInteger (<span class="hljs-keyword">this</span>, keyFunding (id)))) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Funding with the same ID already exists"</span>) <span class="hljs-keyword">else</span>

    # <span class="hljs-type">The</span> minimum amount of tokens to collect is <span class="hljs-number">1000</span>
    <span class="hljs-keyword">if</span> (targetSum &lt;<span class="hljs-number">1000</span>) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You cannot fundraise less than 1000 tokens"</span>)
    <span class="hljs-keyword">else</span> {
        let fundingPrefix = <span class="hljs-string">"funding_"</span> + id.toString ()
        [
            # save at what height the campaign was started
            <span class="hljs-type">IntegerEntry</span> (fundingPrefix, height),
            # save the end time of the campaign
            <span class="hljs-type">IntegerEntry</span> (fundingPrefix + <span class="hljs-string">"_timestamp"</span>, fundraisingEndTimestamp),
            # save the project execution date
            <span class="hljs-type">IntegerEntry</span> (fundingPrefix + <span class="hljs-string">"_impl_timestamp"</span>, implmenetationEndTimestamp),
            # save the value of the goal (the number of collected tokens), at which the campaign is considered successful
            <span class="hljs-type">IntegerEntry</span> (fundingPrefix + <span class="hljs-string">"_targetSum"</span>, targetSum),
            # create a key in which we will constantly store the actual number of tokens received by the target, and write <span class="hljs-number">0</span> as the initial value
            <span class="hljs-type">IntegerEntry</span> (fundingPrefix + <span class="hljs-string">"_raised"</span>, <span class="hljs-number">0</span>),
            # create a key in which we will store the number of votes <span class="hljs-keyword">for</span> the project was implemented, and write <span class="hljs-number">0</span> as the initial value
            <span class="hljs-type">IntegerEntry</span> (fundingPrefix + <span class="hljs-string">"_release_votes"</span>, <span class="hljs-number">0</span>),
            # save the public key of the campaign creator (as a string <span class="hljs-keyword">for</span> readability in the browser)
            <span class="hljs-type">StringEntry</span> (fundingPrefix + <span class="hljs-string">"_owner"</span>, i.callerPublicKey.toBase58String (),
            # create a key in which we will store whether the creator of the target received his tokens after voting, and write <span class="hljs-literal">false</span> as the initial value
            <span class="hljs-type">BooleanEntry</span> (keyReleasedTokens (id), <span class="hljs-literal">false</span>)
        ]
    }
}

</div></code></pre>
<p>We create many keys that we will use in other functions as well. Therefore, in order not to repeat ourselves and avoid typos, it makes sense to separate them into separate functions:</p>
<pre class="hljs"><code><div>func keyFunding (id: <span class="hljs-type">Int</span>) = <span class="hljs-string">"funding_"</span> + id.toString ()
func keyEndTimestamp (id: <span class="hljs-type">Int</span>) = keyFunding (id) + <span class="hljs-string">"_timestamp"</span>
func keyImplEndTimestamp (id: <span class="hljs-type">Int</span>) = keyFunding (id) + <span class="hljs-string">"_impl_timestamp"</span>
func keyTargetSum (id: <span class="hljs-type">Int</span>) = keyFunding (id) + <span class="hljs-string">"_targetSum"</span>
func keyOwner (id: <span class="hljs-type">Int</span>) = keyFunding (id) + <span class="hljs-string">"_owner"</span>
func keyRaised (id: <span class="hljs-type">Int</span>) = keyFunding (id) + <span class="hljs-string">"_raised"</span>
func keyReleaseVotes (id: <span class="hljs-type">Int</span>) = keyFunding (id) + <span class="hljs-string">"_release_votes"</span>
func keyReleasedTokens (id: <span class="hljs-type">Int</span>) = keyFunding (id) + <span class="hljs-string">"_released"</span>
</div></code></pre>
<p>All team members, except for the campaign creator, can give their tokens for project implementation or as votes. But the contribution of one user cannot exceed 33% of the required amount. To support a campaign, you need to call an application method, pass a unique campaign ID and attach tokens as a payment.</p>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Callable</span> (i)
func fund (id: <span class="hljs-type">Int</span>) = {
    # get a riveted payment, <span class="hljs-keyword">if</span> it doesn<span class="hljs-symbol">'t</span> exist, an exception will be thrown
    let pmt = i.payments [<span class="hljs-number">0</span>] .extract ()

    # get campaign parameters
    let targetSum = getIntegerValue (<span class="hljs-keyword">this</span>, keyTargetSum (id))
    let endTimestamp = getIntegerValue (<span class="hljs-keyword">this</span>, keyEndTimestamp (id))
    let owner = getStringValue (<span class="hljs-keyword">this</span>, keyOwner (id))

    # get the number of collected tokens at the current moment
    let raised = getIntegerValue (<span class="hljs-keyword">this</span>, keyRaised (id))

    # get the number of tokens that the current user has already sent to <span class="hljs-keyword">this</span> target
    # <span class="hljs-keyword">if</span> absent, we get <span class="hljs-number">0</span>
    let alreadyFundedByUser = <span class="hljs-keyword">match</span> getInteger (<span class="hljs-keyword">this</span>, keyUserFunded (id, i.callerPublicKey.toBase58String ())) {
        <span class="hljs-keyword">case</span> v: <span class="hljs-type">Int</span> =&gt; v
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">0</span>
    }

    # check that the attached tokens are indeed organization tokens
    <span class="hljs-keyword">if</span> (pmt.assetId! = thanksTokenId) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You have to attach proper tokens with id:"</span> + thanksTokenId.toBase58String ()) <span class="hljs-keyword">else</span>

    # check that the campaign creator is not trying to fund the campaign himself
    <span class="hljs-keyword">if</span> (owner == i.callerPublicKey.toBase58String ()) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You cannot fund your own target"</span>) <span class="hljs-keyword">else</span>

    # check that the end of fundraising has not yet arrived
    <span class="hljs-keyword">if</span> (endTimestamp&gt; lastBlock.timestamp) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"This target is finished already"</span>) <span class="hljs-keyword">else</span>

    # check that the user<span class="hljs-symbol">'s</span> contribution to the goal is less than <span class="hljs-number">33</span>% after <span class="hljs-keyword">this</span> transaction
    <span class="hljs-keyword">if</span> (((alreadyFundedByUser + pmt.amount)&gt; targetSum / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You cannot fund more than 33% of the whole sum which is"</span> + ((targetSum / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>) - alreadyFundedByUser) .toString ())
    <span class="hljs-keyword">else</span> {
        [
            # save the <span class="hljs-keyword">new</span> number of tokens received from the current calling account <span class="hljs-keyword">for</span> <span class="hljs-keyword">this</span> campaign
            <span class="hljs-type">IntegerEntry</span> (keyUserFunded (id, i.callerPublicKey.toBase58String ()), alreadyFundedByUser + pmt.amount),
            # update the amount of collected tokens at the current moment
            <span class="hljs-type">IntegerEntry</span> (keyRaised (id), raised + pmt.amount)
        ]
    }
}
</div></code></pre>
<p>We have already implemented the functionality of creating a campaign and funding it, but if the fundraising was successful (the amount collected is greater than the amount specified at the time of creating the campaign), then the tokens should be locked for contracts until the due date.</p>
<p>After the due date, investors start voting on the fact of the project. If, in the opinion of most investors, the project was implemented, then the tokens are unlocked on the contract and the creator of the campaign receives them, otherwise the tokens remain on the contract forever.</p>
<p>Let's implement a function that campaign investors can call and confirm that the project has been completed. The absence of a vote will be considered a &quot;Against&quot; vote.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func voteForRelease (id: <span class="hljs-type">Int</span>) = {

    # get campaign parameters
    let endTimestamp = getIntegerValue (<span class="hljs-keyword">this</span>, keyEndTimestamp (id))
    let implEndTimestamp = getIntegerValue (<span class="hljs-keyword">this</span>, keyImplEndTimestamp (id))
    let votePower = getIntegerValue (<span class="hljs-keyword">this</span>, keyUserFunded (id, i.callerPublicKey.toBase58String ()))
    let targetSum = getIntegerValue (<span class="hljs-keyword">this</span>, keyTargetSum (id))
    let raised = getIntegerValue (<span class="hljs-keyword">this</span>, keyRaised (id))
    let released = getBooleanValue (<span class="hljs-keyword">this</span>, keyReleasedTokens (id))
    let owner = keyOwner (id)

    # get the number of tokens of investors who have already voted <span class="hljs-string">"For"</span>
    let votedPower = getIntegerValue (<span class="hljs-keyword">this</span>, keyReleaseVotes (id))


    # check that the campaign deadline has already passed
    <span class="hljs-keyword">if</span> (implEndTimestamp&gt; lastBlock.timestamp) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"This target is not finished yet"</span>) <span class="hljs-keyword">else</span>

    # check that the campaign was successful and raised the required amount
    <span class="hljs-keyword">if</span> (raised &lt;targetSum) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"This target didn't reach target"</span>) <span class="hljs-keyword">else</span>

    # check that voting on <span class="hljs-keyword">this</span> campaign is not over yet
    <span class="hljs-keyword">if</span> (released) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"This target was released already"</span>) <span class="hljs-keyword">else</span>

    # check that the current investor has not already voted <span class="hljs-keyword">for</span> the campaign
    <span class="hljs-keyword">if</span> (isDefined (getBoolean (<span class="hljs-keyword">this</span>, keyUserVoted (id, i.callerPublicKey.toBase58String ())))) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You already voted for the target"</span>) <span class="hljs-keyword">else</span>

    # <span class="hljs-keyword">if</span> the number of those who have already voted <span class="hljs-string">"For"</span> and the vote of the current investor in total
    # more than <span class="hljs-number">50</span>%, we transfer tokens to the creator of the campaign and record the fact of completion
    # otherwise we increase the number of tokens of investors who have already voted <span class="hljs-string">"For"</span>
    <span class="hljs-keyword">if</span> ((votedPower + votePower)&gt; (raised / <span class="hljs-number">2</span>)) then {
        # campaign creator gets <span class="hljs-number">80</span>% of the collected amount
        # the remaining <span class="hljs-number">20</span>% ​​is held by the application as a commission
        let ownerPrize = raised - (raised / <span class="hljs-number">1</span>/<span class="hljs-number">5</span>)
        [
            <span class="hljs-type">IntegerEntry</span> (keyReleaseVotes (id), votedPower + votePower),
            <span class="hljs-type">BooleanEntry</span> (keyReleasedTokens (id), <span class="hljs-literal">true</span>),
            <span class="hljs-type">ScriptTransfer</span> (addressFromPublicKey (owner.toBytes ()), ownerPrize, thanksTokenId)
        ]
    } <span class="hljs-keyword">else</span> {
        [
            <span class="hljs-type">IntegerEntry</span> (keyReleaseVotes (id), votedPower + votePower)
        ]
    }
}
</div></code></pre>
<p>If the campaign was still not successful and did not collect the required number of tokens, investors should be able to withdraw their funds:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func refundUser (id: <span class="hljs-type">Int</span>) = {
    # get campaign parameters
    let endTimestamp = getIntegerValue (<span class="hljs-keyword">this</span>, keyEndTimestamp (id))
    let targetSum = getIntegerValue (<span class="hljs-keyword">this</span>, keyTargetSum (id))
    let raised = getIntegerValue (<span class="hljs-keyword">this</span>, keyRaised (id))

    # get the number of tokens that were sent by the current investor
    let fundedAmount = getIntegerValue (<span class="hljs-keyword">this</span>, keyUserFunded (id, i.callerPublicKey.toBase58String ()))

    # check that the campaign fundraising period has already ended
    <span class="hljs-keyword">if</span> (endTimestamp&gt; lastBlock.timestamp) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"This target time is not finished yet"</span>) <span class="hljs-keyword">else</span>

    # check that the campaign has <span class="hljs-type">NOT</span> raised the required amount of funds
    <span class="hljs-keyword">if</span> (raised&gt; targetSum) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"This target raised enough tokens"</span>) <span class="hljs-keyword">else</span>

    # check that the current investor really supported the campaign
    <span class="hljs-keyword">if</span> (fundedAmount == <span class="hljs-number">0</span>) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You have no power here"</span>) <span class="hljs-keyword">else</span>
        [
            # reset the number of tokens from the current investor
            <span class="hljs-type">IntegerEntry</span> (keyUserFunded (id, i.callerPublicKey.toBase58String ()), <span class="hljs-number">0</span>)
            # <span class="hljs-keyword">return</span> tokens to the investor
            <span class="hljs-type">ScriptTransfer</span> (i.caller, fundedAmount, thanksTokenId)
        ]
}

</div></code></pre>
<h2 id="user-interface">User interface</h2>
<p>We have implemented the main code in Ride, but the final application must also be able to interact with the user, messenger API, database, and so on. These questions are beyond the scope of this article. To understand how the application works for the end user, watch a video demo on the project website - <a href="https://iambilly.app">https://iambilly.app</a>. Better yet, install Billy for free on Slack and start using it.</p>
<h1 id="smart-assets-and-where-does-the-hot-potato-come-in">Smart assets and where does the hot potato come in?</h1>
<p>Smart assets are extremely powerful tools that, if used correctly, can allow you to quickly and easily implement restrictions on working with a token. Let's develop a token game called hot potato.</p>
<h2 id="what-are-potatoes-and-why-are-they-hot">What are potatoes and why are they hot?</h2>
<p>You may have heard about the game <a href="https://en.wikipedia.org/wiki/Hot_potato">hot potato</a>, which appeared already in 1888, but if suddenly you haven't heard, I will briefly explain the rules. The participants of the game gather in a small circle and throw a small object to each other, in parallel with this some kind of music is played. At some point, the music stops playing and the player holding the item at that moment is out of the game. In the next round, everything starts over until there is only 1 player left.</p>
<h2 id="hotpotatotoken">HotPotatoToken</h2>
<p>Let's implement a token with similar mechanics:</p>
<ul>
<li>When a user receives a token, they have 5000 minutes to transfer it to someone else. After this period, the token can still be sent to someone, but only if the transaction fee is greater than 1 Waves. Or the token can be burned, but 5 Waves will have to be paid in the form of a commission.</li>
<li>Since the generation of a new account does not cost anything, let's add a condition that you can send a &quot;hot potato&quot; only to an account that has more than 10 Waves on its balance</li>
<li>User can only have one hot potato at a time</li>
<li>All of the above restrictions do not apply to the account that issued the token</li>
</ul>
<p>Let's declare the main variables for our script. Unlike a smart account, which can be implemented using the <code>@ Verifier</code> function, a smart asset must have an<code> EXPRESSION</code> code:</p>
<pre class="hljs"><code><div>
{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ASSET</span> # -}

# on the account receiving hot potatoes cannot be less than <span class="hljs-keyword">this</span> amount
let minimumWavesBalance = <span class="hljs-number">10</span>_00_000_000

# <span class="hljs-type">The</span> number of milliseconds during which the minimum commission will be standard (<span class="hljs-number">0.005</span> <span class="hljs-type">Waves</span> from a regular account)
let moveTimeInMs = <span class="hljs-number">5000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>

# <span class="hljs-type">Commission</span> <span class="hljs-keyword">for</span> sending after the expiration of moveTimeInMs
let minimalFeeToMove = <span class="hljs-number">1</span>_00_000_000

# <span class="hljs-type">Commission</span> <span class="hljs-keyword">for</span> burning token
let minimalFeeToBurn = <span class="hljs-number">5</span>_00_000_000
</div></code></pre>
<p>You may have noticed the underscore in the numbers <code>_</code>, which is supported in Ride to make it easier to read. Eight zeros are separated from the rest of the digits, since Waves has 8 decimal places and it is easier to see the number of whole Waves tokens this way.</p>
<p>In the global scope, the variable <code>tx</code> is available, which stores information about the current transaction being processed. Since <code>tx</code> is<code> Union</code> from all possible transaction types, we need to use pattern matching in our code. We will have different conditions for <code>Tranfer</code>,<code> Burn</code> and all other types of transactions.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">match</span> (tx) {
    # temporarily leave the check of <span class="hljs-type">Tranfer</span> transactions in <span class="hljs-keyword">this</span> form
    <span class="hljs-keyword">case</span> t: <span class="hljs-type">TransferTransaction</span> =&gt; {
        <span class="hljs-literal">false</span>
    }
    # <span class="hljs-type">We</span> only allow burning <span class="hljs-keyword">if</span> the commission is more than <span class="hljs-number">5</span> <span class="hljs-type">Waves</span>
    # or the sender is the account that issued the token
    <span class="hljs-keyword">case</span> b: <span class="hljs-type">BurnTransaction</span> =&gt; {
        <span class="hljs-keyword">if</span> (b.fee&gt; = minimalFeeToBurn || tx.senderPublicKey == <span class="hljs-keyword">this</span>.issuerPublicKey) then <span class="hljs-literal">true</span>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You have to pay 5 WAVES to burn this token"</span>)
        }
    }
    # all other types of transactions are allowed <span class="hljs-keyword">for</span> the creator tokens and prohibited <span class="hljs-keyword">for</span> all others
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">if</span> tx.senderPublicKey == <span class="hljs-keyword">this</span>.issuerPublicKey then <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You only can transfer this token"</span>)
  }
</div></code></pre>
<p>In the code above, we have implemented a check that if the transaction performed with the token is <code>Burn</code>, then one of the conditions must be met - the sender is the account that issued this token or the commission is greater than the minimum value for burning (in our case, 5 Waves). We used the keyword <code>this</code>, which in the context of a smart asset denotes the type<code> Asset</code> and contains information about the current token.</p>
<blockquote>
<p>Please note that when verifying the sender of a transaction, we only check if the public keys match and do not verify that the correct signature from the given public key is provided, since ** the <code>proofs</code> array is not available in the smart asset script **. Signature verification is the responsibility of the account, not the asset.</p>
</blockquote>
<p>In the script above, we have prohibited all <code>Transfer</code> transactions, but the logic of the&quot; hot potato &quot;implies that we should allow them if the token was received less than 5000 minutes ago or the commission is higher than 1 Waves.</p>
<p>Before we start writing the code, we need to understand how we will verify the fact that the token was received less than 5000 minutes ago. Unfortunately, there is no function in Ride that would allow us to find the moment of receiving the token. Moreover, there are practically no functions in Ride that allow you to look at the transaction history. We could require to provide the id of the transaction for receiving the potatoes in the <code>proofs</code> array, because as you remember, up to 8 arguments can be passed in<code> proofs</code>, but <code>proofs</code> is not available in the smart asset code.</p>
<p>The solution would be to require the id of the potato receipt transaction as an attachment to the Tranfer transaction.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">match</span> (tx) {
    <span class="hljs-keyword">case</span> t: <span class="hljs-type">TransferTransaction</span> =&gt; {

        # <span class="hljs-type">If</span> the sender of the token is the account that issued it, then no checks are needed
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.issuerPublicKey == t.senderPublicKey) then <span class="hljs-literal">true</span>
        <span class="hljs-keyword">else</span> {
            # to calculate how much time has passed since the token was received
            # attachment must contain the id of the receive transaction
            let txId = t.attachment

            # get the balance <span class="hljs-keyword">for</span> the <span class="hljs-type">HotPotato</span> token to check that the recipient no longer has a hot potato
            let currentRecipientHasPotato = assetBalance (t.recipient, t.assetId)&gt; <span class="hljs-number">0</span>

            # get the balance of <span class="hljs-type">Waves</span> tokens to make sure that the recipient<span class="hljs-symbol">'s</span> account has at least <span class="hljs-number">10</span> <span class="hljs-type">Waves</span>
            let currentRecipientWavesBalance = wavesBalance (t.recipient)

            # <span class="hljs-type">If</span> the recipient already has a hot potato, then <span class="hljs-keyword">throw</span> an exception
            <span class="hljs-keyword">if</span> (currentRecipientHasPotato) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"The recipient already has a hot potator"</span>)
            # <span class="hljs-type">If</span> the user has less than <span class="hljs-number">10</span> <span class="hljs-type">Waves</span>, then <span class="hljs-keyword">throw</span> an exception
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentRecipientWavesBalance &lt;minimumWavesBalance) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"Recipient is too poor"</span>) <span class="hljs-keyword">else</span> {

                # <span class="hljs-type">Get</span> information about the transaction from which the current sender received his potato
                let transaction = transferTransactionById (t.assetId.value ()). valueOrErrorMessage (<span class="hljs-string">"Can't find incoming transaction"</span>)

                # <span class="hljs-type">Get</span> the block number in which the current sender received his potato
                let receivedBlockNumber = transactionHeightById (transaction.id) .valueOrErrorMessage (<span class="hljs-string">"Can't find incoming tx block number"</span>)

                # <span class="hljs-type">We</span> get all the information about the block in which the current sender received his potato
                let receivedBlockTimestamp = blockInfoByHeight (receivedBlockNumber) .value (). timestamp

                # <span class="hljs-type">Verify</span> that the user received their hot potatoes less than <span class="hljs-number">5000</span> minutes ago
                let receivedAssetInLastNMs = (lastBlock.timestamp - receivedBlockTimestamp) &lt;= moveTimeInMs &amp;&amp; t.assetId == transaction.assetId

                # <span class="hljs-type">Check</span> <span class="hljs-keyword">if</span> the commission is more than <span class="hljs-number">1</span> <span class="hljs-type">Waves</span>
                let feeMore1Waves = t.fee&gt; = minimalFeeToMove

                # <span class="hljs-type">If</span> the transaction is received more than <span class="hljs-number">5000</span> blocks ago <span class="hljs-type">AND</span> the commission is less than <span class="hljs-number">1</span> <span class="hljs-type">Waves</span>
                # <span class="hljs-type">Throw</span> an exception
                # <span class="hljs-type">Otherwise</span>, allow the transaction
                <span class="hljs-keyword">if</span> (! receivedAssetInLastNMs &amp;&amp;! feeMore1Waves) then {
                    <span class="hljs-keyword">throw</span> (<span class="hljs-string">"You got potato long time ago, now you have to pay 1 WAVES fee"</span>)
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-literal">true</span>
                }
            }
        }
    <span class="hljs-keyword">case</span> burn: <span class="hljs-type">BurnTransaction</span> =&gt; {...}
    <span class="hljs-keyword">case</span> _ =&gt; ...
  }
</div></code></pre>
<p>We have implemented all the necessary functionality using several functions and variables of the standard library:</p>
<ul>
<li><code>transferTransactionById (txId: ByteVector)</code> allows you to get information about the <code>Transfer</code> transaction by its Id. Anticipating questions, I must say right away that the same function does not exist for other types of transactions.</li>
<li><code>blockInfoByHeight (n: Int)</code> allows you to get information about the block by its number</li>
<li><code>lastBlock</code> - contains all information about the current (last) block</li>
</ul>
<p>Smart assets can have much more interesting and florid mechanics and terms of use, but the hot potato example sufficiently describes what types of restrictions can be and how tokens can be used in your application.</p>
<p>One such application that harnesses the power of smart assets is the <a href="https://tokenomica.com/">Tokenomica</a> project, which allows the issuance and investment of tokenized securities.</p>
<h1 id="development-best-practices">Development best practices</h1>
<p>As you may have already noticed, developing decentralized Web3 applications can be sometimes non-trivial, which differs from regular application development in many respects:</p>
<ul>
<li><strong>Error cost</strong>. A bug in decentralized applications can often lead to loss of funds, sometimes loss of user funds</li>
<li><strong>Open source</strong>. Even if you do not want your code to be available to other users and developers, it will lie in the blockchain and there is always an opportunity to decompile it (in Waves, for example, this is done very simply even in the blockchain explorer)</li>
<li><strong>A large number of interconnected elements</strong>. Some decentralized applications can rely on the logic of others</li>
<li><strong>Possible protocol updates</strong>. For example, updating the Waves protocol to 1.2 and activating feature 14 (if adopted in the mainnet) completely change the logic of working with script call transactions. In fact, the environment of the application can change. It's hard to imagine this in a typical development.</li>
</ul>
<p>Let's see what mistakes developers make most often and what needs to be done to avoid them.</p>
<h2 id="always-check-the-signature">Always check the signature</h2>
<p>One of the most common mistakes developers make is to use the <code>case _ =&gt; true</code> check construct in smart account scripts or the<code> @ Verifier</code> functions of decentralized applications. For example, you might think that the following script only forbids <code>Transfer</code> transactions and allows all others:</p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">3</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

<span class="hljs-keyword">match</span> (tx) {
    <span class="hljs-keyword">case</span> t: <span class="hljs-type">TransferTransaction</span> =&gt; <span class="hljs-literal">false</span>
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>But the devil is in the details. Such a script completely prohibits making transactions from the <code>Transfer</code> account and allows all other types of transactions ** to any user **. Any person or even just a script can make a transaction from this account by specifying the public account key in the <code>senderPublicKey</code> field of the transaction and ** without specifying a single signature. **</p>
<p><strong>Always check</strong> for signature and correctness:</p>
<pre class="hljs"><code><div>{- # <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">3</span> # -}
{- # <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> # -}
{- # <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> # -}

<span class="hljs-keyword">match</span> (tx) {
    <span class="hljs-keyword">case</span> t: <span class="hljs-type">TransferTransaction</span> =&gt; <span class="hljs-literal">false</span>
    <span class="hljs-keyword">case</span> _ =&gt; sigVerify (tx.bodyBytes, tx.proofs [<span class="hljs-number">0</span>], tx.senderPublikey)
}
</div></code></pre>
<p>You need to be careful not only in mainnet, but also in testnet, because both there and there there are scripts that watch all transactions in the blockchain and if they find accounts with such a vulnerability, withdraw all tokens from the account.</p>
<h2 id="understand-the-difference-between-verifier-and-callable">Understand the difference between @Verifier and @Callable</h2>
<p>Some decentralized application developers make a mistake when designing their dApp by mistakenly saying that <code>@ Verifier</code> checks <strong>incoming</strong> transactions against the dApp's address. For example, there are such scripts:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span> (i)
func foo () = {
    [<span class="hljs-type">StringEntry</span> (<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>)]
}

<span class="hljs-meta">@Verifier</span> (tx)
func verify = {
    <span class="hljs-keyword">match</span> (tx) {
        <span class="hljs-keyword">case</span> i: <span class="hljs-type">InvokeScriptTransaction</span> =&gt; <span class="hljs-literal">true</span>
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>
    }
}
</div></code></pre>
<p>But such a script is not engaged in the fact that it allows you to call the methods of this dApp, but <strong>allows you to call other dApps from the account of this decentralized application even without providing a signature.</strong> That is, any user can call another account and transfer all tokens from the account of this application. Do not forget that the account of the decentralized application remains an account that can also do some actions and send transactions, and these actions are controlled by the <code>@ Verifier</code> function.</p>
<h2 id="verify-transactions-before-submitting">Verify transactions before submitting</h2>
<p>Script call transactions can end with an error, but earlier such transactions simply did not get into the blockchain, with the release of Waves 1.2 (at the time of this writing, only in stagenet) this situation has changed. Now <code>InvokeScript</code> transactions and transactions related to the use of smart assets get into the blockchain even if they return an error, and the user pays a commission for them.</p>
<p>It is impossible to make sure by 146% that the transaction will be fully completed and get into the blockchain, since the state of the blockchain changes quickly enough, new transactions appear in UTX, get into blocks and can change the branch that the script will follow. You can maximize the likelihood that a transaction will succeed using pre-validation. The REST API of the node has a method <a href="https://nodes.wavesplatform.com/api-docs/index.html#/debug/validate"><code>debug / validate</code></a>, which accepts a transaction and validates it. The method returns what the result of the transaction script would be if it was added to the block right now.</p>
<p>Use this method for pre-validation before sending the transaction using the <code>broadcast</code> method.</p>
<blockquote>
<p>Important: this API method requires a key that cannot be obtained for public nodes, so use a node whose API Key you know.</p>
</blockquote>
<h2 id="be-careful-with-keys">Be careful with keys</h2>
<p>In the development of decentralized applications, many operations are performed with the account's key-value storage. Keys in the vault are often composite, for example, <code>voting_12_vote_3MEEsWQtsS5WV2SczdEvipY3Ch5LuSHuLWa</code>, which can store the vote of the account` 3MEEsWQtsS5WV2SczdEvipY3Ch5LuSHuLWa 'in voting with id. Formation of a key for such a record in the storage can be implemented in Ride as follows:</p>
<pre class="hljs"><code><div>func keyVoteByAddress (votingId: <span class="hljs-type">Int</span>, address: <span class="hljs-type">String</span>) = <span class="hljs-string">"voting_"</span> + votingId + <span class="hljs-string">"_vote_"</span> + address
</div></code></pre>
<p>A common mistake is that they make a mistake in forming a key: they write to one key, and try to read from another key. For example, forget the <code>_</code> character in one of the places. To avoid this mistake, always use separate key generation functions instead of our favorite copy &amp; paste behavior. And of course, write tests for your applications.</p>
<h2 id="use-default-values">Use default values</h2>
<p>Another common mistake, including with keys in storage, is trying to read values ​​from variables of type <code>Union (T | Unit)</code> using <code>value ()</code> or <code>extract ()</code> in places where one could use default values. For example, if a function tries to read the user's voice from the storage, but there may be a situation that there is no voice yet, use the <code>valueOrElse</code> function or pattern matching:</p>
<pre class="hljs"><code><div>
let <span class="hljs-type">NONE</span> = <span class="hljs-string">"NONE"</span>

func keyVoteByAddress (votingId: <span class="hljs-type">Int</span>, address: <span class="hljs-type">String</span>) = <span class="hljs-string">"voting_"</span> + votingId + <span class="hljs-string">"_vote_"</span> + address


<span class="hljs-meta">@Callable</span> (i)
func vote (id: <span class="hljs-type">Int</span>) =&gt; {
    let voteKey = keyVoteByAddress (id, i.caller.toBase58String ())
    let vote = getString (<span class="hljs-keyword">this</span>, voteKey) .valueOrElse (<span class="hljs-type">NONE</span>)

    # <span class="hljs-type">Alternative</span> option

    let vote = <span class="hljs-keyword">match</span> getString (<span class="hljs-keyword">this</span>, voteKey) {
        <span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> =&gt; s
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">NONE</span>
    }

    <span class="hljs-keyword">if</span> (vote == <span class="hljs-type">NONE</span>) then ...
    <span class="hljs-keyword">else</span> ...
}
</div></code></pre>
<p>It is also worth considering that the functions of your application can be called not only from your user interface, but by anyone and in any way, so the default values ​​can help them too.</p>
<h2 id="control-your-transactions">Control your transactions</h2>
<p>In the work of real decentralized applications, there are relatively often cases when it is necessary to execute several dependent transactions sequentially. For example, if you use the <a href="https://en.wikipedia.org/wiki/Commitment_scheme">commit-disclosure</a> scheme, then the disclosure phase can only be after the commit phase. If you send a disclosure transaction before the commit transaction hits the blockchain, then your script will return an error, the user will pay a fee and not get the expected result.</p>
<p>In the Waves blockchain, there may be rare situations when a fork occurs in the blockchain and the last block or microblock is rolled back, which can lead to disruption of the sequence of dependent transactions. For example, if you send a transaction for the commit phase, wait until it gets into the last (liquid) block and immediately send the disclosure transaction, then there may be a situation when the last block or microblock rolls back, the commit transaction &quot;falls out&quot; of the blockchain. This will make the transaction invalid for the disclosure phase.</p>
<p>If you use the <code>waitForTx</code> function from the<code> waves-transactions</code> library, then it waits only to hit the last fluid block, which can lead to problems. If you have dependent transactions, it is safer to use the <code>waitForTxWithNConfirmations</code> function, waiting for 1-2 confirmations after the first transaction hits the block.</p>
<h1 id="5-things-i-would-like-to-know-before-i-started-developing-decentralized-apps">5 things I would like to know before I started developing decentralized apps</h1>
<p>In conclusion of the chapter on decentralized applications, I would like to share my development experience and tell 5 things that I would like to know many years ago, when I just started making products using blockchain.</p>
<h2 id="1-blockchain---still-as-spectrum">1. Blockchain - still as Spectrum</h2>
<p>Many developers have heard about the problems of blockchain scalability, that blockchain is not about high load at all (by high I mean tens and hundreds of thousands of requests). But when I first got carried away with blockchain, I did not fully realize what awaited me. Sasha Ivanov once wrote in the article <a href="https://medium.com/wavesprotocol/you-cant-calculate-on-the-blockchain-906f9b110829">&quot;You can't calculate on the blockchain&quot;</a> that the current level of the blockchain is Sinclair ZX Spectrum 8-bit computers.</p>
<p>These computers have played a very important role in the advancement of technology, but compared to modern personal computers and smartphones, they seem to be nothing more than a programmable calculator. In terms of the level of computing power for each individual application, the blockchain resembles the ZX Spectrum. But there is nothing to worry about: blockchain is not for computing speed, but for removing intermediaries.
The limitations of blockchain affect not only the complexity of programs (for example, there are very few decentralized applications - dApps - with hundreds of thousands of lines of code), but also how developers think. This picture illustrates well the problems of today's blockchain developers, very similar to those of game developers in 1996.</p>
<p><img src="../../assets/7-6-5-1-devs.png" alt="Developers" title="Developers"></p>
<p>Common application developers may not think about many of the problems dApp developers face:</p>
<ul>
<li>The need to fight for every byte and for every computing operation</li>
<li>The inability to easily update your application and deliver the update to customers (in this regard, the Waves blockchain compares favorably with competitors, as it provides such an opportunity)</li>
<li>The high cost of a mistake.</li>
</ul>
<p>Of course, there are advantages to all of these restrictions. For example, not being able to write whatever you want in code reduces security concerns. I talked about some other benefits at the [San Francisco Blockchain Week 2019] conference (https://www.youtube.com/watch?v=gMcif_ADWak).</p>
<h2 id="different-user-experience">Different user experience</h2>
<p>Back in 2014, when I started to be interested in the development of applications for the blockchain, I did not realize that along with the change in the principles of describing the business logic of applications, the user experience was changing.</p>
<p>For example, a user is accustomed to authorization in the application using a username and password, and to perform an operation with a dApp, a signature with a private key is required.</p>
<p>The private key is most often stored in a browser extension (see Waves Keeper), which becomes an additional barrier for PC users and a big headache on mobile devices.</p>
<p>Also, for each new user action - an additional step is added, which can completely &quot;kill&quot; the user experience and create big problems for the business.</p>
<p>Recently, products have appeared in which users are offered familiar algorithms, but at the same time decentralization and security are not sacrificed, for example, Waves Signer. But this segment is still at a very early stage of development.</p>
<p>In such conditions, it is extremely important to convey to the user why blockchain is needed in a particular application, what advantages it provides, and why it is worth putting up with a possible deterioration in user experience.</p>
<h2 id="decentralization-is-not-the-default-value">Decentralization is not the default value</h2>
<p>At the beginning of their journey, many dApp developers think that any product can be made better simply by adding blockchain and decentralization. In fact, this is not the case, because the blockchain, in addition to decentralization, leads to a change in user experience, and, most often, for the worse.</p>
<p>Understanding why you need blockchain will save you months and years of developing a product that will only get worse with blockchain. According to the famous investor and businessman Peter Thiel, in order to win customers and the market, your product must be 10 times better than competitors. And blockchain products are no exception.</p>
<p>Decentralization is very cool, but adding it to a process should increase its value in the eyes of the user at least several times. You don't say, &quot;Our product is built on Postgres, so it is better than the competition.&quot; This also applies to blockchain.</p>
<p>There is no universal formula for determining the value of a blockchain in a specific solution. But it's worth starting with the question: &quot;Which parties are involved in the process that I am trying to improve, and why do they not trust each other?&quot; If only one party is involved, or there is no trust issue, chances are good that you don't need blockchain.</p>
<h2 id="power-in-composition-composability">Power in composition (composability)</h2>
<p>Typical for many startups and companies is the <a href="https://en.wikipedia.org/wiki/Not_invented_here#:~:text=Not%20invented%20here%20(NIH)%20is,and%20costs%2C%20such%20as%20royalties.">NIH</a>  <a href="https://en.wikipedia.org/wiki/Not_invented_here#:~:text=Not%20invented%20here%20(NIH)%20is,and%20costs%2C%20such%20as%20royalties.">Not invented here</a> syndrome. The desire to &quot;do it all&quot; in the blockchain space can lead to very undesirable consequences.</p>
<p>An important value of the blockchain is that it is a unified interface for communication between different decentralized applications. If you are familiar with the concept of <a href="https://en.wikipedia.org/wiki/Enterprise_service_bus">&quot;data bus&quot;</a>, then you can draw a parallel with the blockchain. Imagine having access to data from a large number of other applications right in your code runtime.</p>
<p>Another analogy that will help you understand what composition is - Lego bricks, from which you can assemble something unique.</p>
<p>For example, the Waves protocol uses the LPoS consensus algorithm, which allows you to receive income from leasing (staking). The Neutrino Protocol from the Ventuary Lab team uses this algorithm in their stablecoin to enable the user to stake their tokens. Any other application can accept Neutrino stablecoins as a means of payment. This is composition: some applications build on others, using and complementing them.</p>
<p>Many Web 2.0 services have APIs that also allow you to integrate with them. But there are several important differences:</p>
<ul>
<li>In Web 2.0 applications, users are often required to register and obtain special API keys that give access to data and can be revoked by providers at any time. Access keys are not required to receive data or call methods of decentralized applications, since all applications run in a common space</li>
<li>For classic Web 2.0 applications, there are a huge number of different API protocols (authorization, data encoding, etc.). This problem does not exist for dApps. You just need to know what arguments what functions take. Even if the application has no documentation, you can see it yourself on the blockchain.</li>
</ul>
<h2 id="its-only-the-beginning">It's only the beginning</h2>
<p>Bitcoin is more than 10 years old, and it may seem that all applications have already been created, all fresh ideas have been implemented and the era of interesting startups in the blockchain world is over. This is far from the case. Every few years new trends, opportunities, technologies appear in the blockchain. We can say that every few years, or even more often, the market offers new players a chance. The most interesting projects are ahead of us!</p>
<p>I talked about the fact that the blockchain is developing extremely quickly in my <a href="https://medium.com/@ikardanov/2019-in-the-blockchain-world-through-the-eyes-of-developer-advocate-e329aee5aa1">2019 Results</a>, which I recommend you read if you haven't already. New products like Gravity open up opportunities for a lot of innovation. For example, with the advent of Gravity, it will be possible to create decentralized applications that work in several networks at once. Whoever will be the first to take advantage of these opportunities and in one application will combine, for example, the best aspects of Bitcoin, Waves, Ethereum, will definitely be able to do something innovative.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-8-developers-best-friends">Chapter 8. Developer's best friends</h1>
<p>As my girlfriend says, developers have no friends, but we know that they are not, because a developer's best friends are development tools.</p>
<p>During the development of Web3 applications, it is necessary to constantly interact with the nodes of the blockchain, both to receive information and to send data as a transaction. On the other hand, building Web3 applications implies user interaction, including requests for transaction signatures to take actions or check the status of accounts, etc.</p>
<p>There are several resources and tools in the Waves ecosystem that can be useful for these purposes, let's take a look at them.</p>
<h2 id="node-rest-api">Node REST API</h2>
<p>As you may recall from Chapter 2 about configuring the node (in fact, you probably forgot about these 100+ pages), the Waves node has a built-in REST API for receiving and sending data. Many other blockchains use JSON RPC rather than REST, but it is the presence of REST that makes communication with the node as easy as possible. By default, the REST API nodes are disabled in the configuration, but there are public nodes that allow making requests to receive data and send transactions:</p>
<ul>
<li><code>nodes.wavesplatform.com</code> for mainnet</li>
<li><code>nodes-testnet.wavesplatform.com</code> for testnet</li>
<li><code>nodes-stagenet.wavesplatform.com</code> for stagenet</li>
</ul>
<p>The REST API node is divided into 2 large parts - the public part, which is accessible without a key, and the private part, which is available only when the API Key is passed. API Key of public Waves nodes cannot be obtained (in the vast majority of cases this is not required), but if you still need methods that require a key, then you need to deploy your node.</p>
<blockquote>
<p>Note that the API Key hash is specified in the config file (how to get the hash correctly is described <a href="https://docs.wavesprotocol.org/en/waves-node/node-configuration#how-to-generate-hash-of-the-api-key">in the documentation</a>), and when calling methods, the API Key itself is passed in cleartext.</p>
</blockquote>
<p>Many libraries for Waves in different programming languages ​​(we will talk about them below) support methods for communicating with the API of the node. All of them support the <code>broadcast</code> method, which sends the signed transaction to the network via the REST API. But some libraries have other useful functions, for example, in <code>waves-transactions</code> there are functions for requesting the state of the storage of any account as a whole or for a specific key (<code> accountData</code> and <code>accountDataByKey</code>), a function for requesting balance or information about the script of a specific account by its address (<code>balance</code>,<code> assetBalance</code> and <code>scriptInfo</code>), functions of waiting for some blockchain height and waiting for the transaction to enter the block (<code> waitForHeight</code>, <code>waitForTx</code>,<code> waitForTxWithNConfirmations</code>), etc.</p>
<p>The REST API of a node is quite limited in terms of filters and searching for transactions by fields, but for such operations it is better to use data services.</p>
<h2 id="data-service-api">Data service API</h2>
<p>Data services are available at <code>https://api.wavesplatform.com/ v0/docs/</code> for use in mainnet or <code>https://api-test.wavesplatform.com/v0/docs/</code> for testnet, but also you can use it on your servers by deploying from the project repository on Github - <code>https://github.com/wavesplatform/data-service</code>.</p>
<p>Data services constantly download information about transactions and blocks on the blockchain and store it in a relational database (Postgresql) to provide a ** o ** greater search flexibility (thanks to indexing). If you still want to use data services on your servers, keep in mind that the Waves blockchain relational database is over 250 gigabytes.</p>
<p>Date services can also save information on trading on the DEX, for example, information about the history of transactions in various pairs, exchange candles, etc.</p>
<h2 id="libraries-for-programming-languages">Libraries for programming languages</h2>
<p>Within the framework of this book, all examples were using JavaScript and the <code>waves-transactions</code> and<code> waves-crypto</code> libraries, but besides them there are libraries for other programming languages:</p>
<ul>
<li>JavaScript / TypeScript - <a href="https://github.com/wavesplatform/waves-transactions">waves-transactions</a></li>
<li>Python - <a href="https://github.com/PyWaves/PyWaves/">PyWaves</a></li>
<li>PHP - <a href="https://github.com/deemru/WavesKit">WavesKit</a></li>
<li>C # - <a href="https://github.com/wavesplatform/WavesCS">WavesCS</a></li>
<li>Go - <a href="https://github.com/wavesplatform/gowaves">GoWaves</a></li>
<li>Java - <a href="https://github.com/wavesplatform/WavesJ">WavesJ</a></li>
<li>Kotlin - <a href="https://github.com/wavesplatform/WavesSDK-android">WavesSDK</a></li>
<li>Swift - <a href="https://github.com/wavesplatform/WavesSDK-iOS">WavesSDK</a></li>
</ul>
<p>The libraries support the latest protocol updates and have many similar primitives. Only the <code>PyWaves</code> library is relatively different.</p>
<p>In addition to those listed above, there are libraries for C, Rust and Elixir, but they do not support signing all types of transactions (or their latest versions) and are actively looking for maintainers.</p>
<h2 id="node-extensions---grpc-and-matcher">Node extensions - gRPC and Matcher</h2>
<p>The Scala version of the Waves node (remember that there is also a Go version) allows you to expand your functionality. Extensions have the ability to subscribe to various events in the blockchain and implement any functionality based on this. For example, <a href="https://github.com/wavesplatform/dex">Matcher</a>, which is the heart of the decentralized exchange, uses the extension functionality to communicate with the node and get the current state of balances and blockchain. Another example of an extension is <a href="https://docs.wavesprotocol.org/en/waves-node/extensions/grpc-server/">gRPC server</a>, which allows you to communicate with a node not via text REST, but via binary <a href="https://en.wikipedia.org/wiki/GRPC">gRPC</a>, which in some cases can be many times faster.</p>
<p>Another example of an extension for a node is <a href="https://github.com/msmolyakov/waves-node-tools-extension">Waves Node Tools Extension</a> by Maxim Smolyakov, which automates the payment of remuneration to the node's leasers. If you have a leasing pool and people are leasing tokens to you with the expectation of receiving a share from the earned node, then you can use this extension. The extension records lease receipts, the moments of block mining by a given node and the contribution of each leaser to the generating balance at the time of block creation. In the future, the script distributes the earned tokens to the leasers, keeping the node owner's commission. The extension can even notify the owner of the node about events such as the generated block or the moment of payments by calling a webhook.</p>
<p>Installing an extension for a node usually consists of 2 steps:</p>
<ul>
<li>installing a <code>.deb</code> package or downloading a<code> .jar</code> file with extension logic</li>
<li>updating the node configuration with the name of the extension package</li>
</ul>
<p>In the configuration file of the node, extension parameters can also be set. For example, installing the Waves Node Tools Extension means installing the <code>.deb</code> package and adding the following lines to the configuration file:</p>
<pre class="hljs"><code><div># add an extension to the list of node extensions
waves.extensions + = &quot;im.mak.nodetools.NodeToolsExtension&quot;

# Waves Node Tools Extension settings

node-tools {
  webhook {
    url = &quot;SPECIFY YOUR ENDPOINT&quot; # example: &quot;https://example.com/webhook/1234567890&quot;
    method = &quot;POST&quot;
    headers = [] # example: [&quot;Content-Type: application / json; charset = utf-8&quot;, &quot;Authorization: Basic dXNlcjpwYXNzd29yZA ==&quot;]
    body = &quot;% s&quot; # example for Integram: &quot;&quot; &quot;{&quot; text &quot;:&quot;% s &quot;}&quot; &quot;&quot;
  }
}
</div></code></pre>
<h1 id="user-interactions">User interactions</h1>
<p>In all the examples before, we considered either static seed phrases right in the code, or generated seed phrases for users, but in real Web3 application development we often need to interact with the user to get a signature. At the same time, we cannot request a seed phrase or a private key from him, since this is completely unsafe. Having a private key or a user's seed phrase, you can do any action with his account, so decentralized applications request a signature for each specific action.</p>
<p>Let's compare the logic of a regular application and a Web3 application to better understand the difference in logic. Let's start with a regular web application, the logic of which boils down to the following steps:</p>
<ol>
<li>The web browser requests a certain URL</li>
<li>The web server sends HTML, CSS, JavaScript and data as a response</li>
<li>The user sees the rendered page with data</li>
<li>The user takes any action (clicks on buttons, submitting forms), after which the application logic (JavaScript) makes XHR (AJAX) requests to the server</li>
<li>The web server responds with a new batch of HTML, CSS, JavaScript and data</li>
</ol>
<p><img src="../../assets/8-1-0-web2-app.png" alt="Web2 app" title="Web2 app"></p>
<p>The logic of the Web3 application is different:</p>
<ol>
<li>The web browser requests a certain URL</li>
<li>The web server sends HTML, CSS, JavaScript and data as a response</li>
<li>JavaScript code requests additional data from the blockchain node</li>
<li>The user sees the rendered page with data</li>
<li>The user takes any read actions (clicks on buttons, submitting forms), after which the application logic (JavaScript) makes XHR (AJAX) requests to the server ** and / or to the blockchain node **</li>
<li>The web server responds with a new batch of HTML, CSS, JavaScript and data</li>
<li>For cases ** recording and updating data **, before sending a request to a blockchain node, the client code in JavaScript ** requests a user signature **</li>
</ol>
<p><img src="../../assets/8-1-0-web3-app.png" alt="Web3 app" title="Web3 app"></p>
<p>There are several ways to work with user keys, and the most common is using browser extensions. The Waves ecosystem has adopted the Waves Keeper extension, which stores seed phrases and allows signing user actions.</p>
<h2 id="waves-keeper">Waves Keeper</h2>
<p>Waves Keeper allows users to manage their accounts:</p>
<ol>
<li>Create new accounts with a random seed phrase or add already created ones</li>
<li>Display the balances of the Waves token on each account</li>
<li>Sign transactions and other data</li>
<li>Work with different networks (mainnet, stagenet, testnet or private).</li>
</ol>
<p>Waves Keeper is available for Google Chrome, Firefox, Edge, Opera, Brave users. You can find download links <a href="https://wavesprotocol.org/protocol/keeper">on the product page on the protocol website</a>.</p>
<p>Unlike extensions for other protocols, for example, Metamask for Ethereum, Waves Keeper is not a full-fledged wallet, since it does not allow you to view transaction history or create a transaction (only sign it).</p>
<div style = "text-align: center">
<img src = "../../assets/8-1-0-keeper.png" style = "max-width: 60%; max-height: 400px">
</div>
<blockquote>
<p>Waves Keeper - a secure way to manage keys and interact with decentralized apps</p>
</blockquote>
<p>Seed phrases in Waves Keeper are stored in the local storage of the extension, encrypted with a password, and are not available for websites. They have access to the <code>WavesKeeper</code> object in the global scope, which provides an API for working with keys. Let's take a look at the basic techniques that can be helpful when integrating Waves Keeper into your user interface.</p>
<p>The WavesKeeper object contains the following methods:</p>
<pre class="hljs"><code><div>WavesKeeper = {
  <span class="hljs-attr">auth</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">publicState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signAndPublishCancelOrder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signAndPublishOrder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signAndPublishTransaction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signCancelOrder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signOrder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signTransaction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signRequest</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signTransactionPackage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">signCustomData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">verifyCustomData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">notification</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">encryptMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">decryptMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">resourceIsApproved</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">resourceIsBlocked</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{},
  <span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
}
</div></code></pre>
<p>Most of the methods are asynchronous and return <code>Promise</code>. Examples of using some of the methods are available on the demo page <a href="https://kardanovir.github.io/WavesKeeper/">in my Github repository</a>.</p>
<p>The auth method is one of the most commonly used and allows you to ask the user for information about his account, which is active at the time of the call. The <code>auth</code> function needs to be passed information about the application and data for signing. Waves Keeper will return us not only account information, but also signed data from the <code>data</code> field, which will allow us to validate the signature in our application code and make sure that the user has an account key with the specified public key and address, and he does not try to break our logic, for example, replacing the global <code>WavesKeeper</code> object.</p>
<pre class="hljs"><code><div>WavesKeeper.auth ({<span class="hljs-attr">name</span>: <span class="hljs-string">'MyApp'</span>, <span class="hljs-attr">data</span>: <span class="hljs-string">'Custom data to Sign'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'https://docs.wavesplatform.com/_theme/brand-logo/waves-docs-logo.png'</span>})
  .then (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
    <span class="hljs-comment">// res will contain information about the account</span>
  })
  .catch (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{<span class="hljs-built_in">console</span>.log (err)});

</div></code></pre>
<p>After calling the method, a <code>Promise</code> will be returned, which will resolve successfully if the user gives permission to grant access, or will fail if access is denied.</p>
<p>The <code>res</code> variable will contain an object:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"data"</span>: <span class="hljs-string">"Custom data to Sign"</span>,
    <span class="hljs-attr">"prefix"</span>: <span class="hljs-string">"WavesWalletAuthentication"</span>,
    <span class="hljs-attr">"host"</span>: <span class="hljs-string">"localhost"</span>,
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"MyApp"</span>,
    <span class="hljs-attr">"icon"</span>: <span class="hljs-string">"https://docs.wavesplatform.com/_theme/brand-logo/waves-docs-logo.png"</span>,
    <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1543175910353</span>,
    <span class="hljs-attr">"address"</span>: <span class="hljs-string">"3PKqkMWvjjwjqbVSu8eL48dNfzWc3ifaaWi"</span>,
    <span class="hljs-attr">"publicKey"</span>: <span class="hljs-string">"4WLcUznGiQXCoy2TnCohGKzDR8c14LFUGezvLNu7CVPA"</span>,
    <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"4s2nz8RxT29UwbJoNjPWxYwjsXYeoaMWK4dDM5eQN5gRmeZWGrN1HbpsirhTzWMJFAGtzzw4U78RNRKeEtwficwR"</span>
}
</div></code></pre>
<p>Keeper returns the public account key, prefix and signature along with the account address. To finally make sure that the user has this account, it is necessary to check the signature from the <code>prefix + data</code> for this public key and make sure that this public key is converted to such an address.</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">import</span> {address, stringToBytes, verifySignature} <span class="hljs-keyword">from</span> <span class="hljs-string">'@ waves / ts-lib-crypto'</span>

<span class="hljs-keyword">const</span> res = {
    <span class="hljs-string">"data"</span>: <span class="hljs-string">"Custom data to Sign"</span>,
    <span class="hljs-string">"prefix"</span>: <span class="hljs-string">"WavesWalletAuthentication"</span>,
    ...,
    <span class="hljs-string">"address"</span>: <span class="hljs-string">"3PKqkMWvjjwjqbVSu8eL48dNfzWc3ifaaWi"</span>,
    <span class="hljs-string">"publicKey"</span>: <span class="hljs-string">"4WLcUznGiQXCoy2TnCohGKzDR8c14LFUGezvLNu7CVPA"</span>,
    <span class="hljs-string">"signature"</span>: <span class="hljs-string">"4s2nz8RxT29UwbJoNjPWxYwjsXYeoaMWK4dDM5eQN5gRmeZWGrN1HbpsirhTzWMJFAGtzzw4U78RNRKeEtwficwR"</span>
}

<span class="hljs-keyword">const</span> signedBytes = stringToBytes (res.prefix + res.data)

verifySignature (res.publicKey, signedBytes, res.signature) &amp;&amp; address ({<span class="hljs-attr">public</span>: res.publicKey}) === res.address

</div></code></pre>
<p>Waves Keeper can also sign transactions, orders for a matcher, requests for a matcher (and send them directly to the network if necessary) and a random set of bytes. To sign a transaction without sending, use the <code>sign</code> function:</p>
<pre class="hljs"><code><div>WavesKeeper.sign ({
  <span class="hljs-attr">type</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">// 4 - transfer transaction</span>
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">amount</span>: {
      <span class="hljs-attr">assetId</span>: <span class="hljs-string">'WAVES'</span>,
      <span class="hljs-attr">tokens</span>: <span class="hljs-string">"0.00100000"</span>
    },
    <span class="hljs-attr">fee</span>: {
      <span class="hljs-attr">assetId</span>: <span class="hljs-string">'WAVES'</span>,
      <span class="hljs-attr">tokens</span>: <span class="hljs-string">"0.00100000"</span>
    },
    <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3P9E5QeGSF4As6kNtBi8j476gsM8mqnX12f'</span>
  }
})
.then (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
  <span class="hljs-comment">// res variable will contain:</span>
  <span class="hljs-comment">// {</span>
  <span class="hljs-comment">// "type": 4,</span>
  <span class="hljs-comment">// "id": "2p8zC1riEZpC19PHuqndyaBnr9ndS6jGvFKyTbX2Qpyq",</span>
  <span class="hljs-comment">// "sender": "3PGiGn5K5zRgU7o3EfvqFeTR91shNAPyFaa",</span>
  <span class="hljs-comment">// "senderPublicKey": "DoQ87i3F9yAX21LrMijEszqMKAHuR867ZFfeXN7UCLe3",</span>
  <span class="hljs-comment">// "fee": 100000,</span>
  <span class="hljs-comment">// "timestamp": 1543228114324,</span>
  <span class="hljs-comment">// "proofs": ["58U8fr9hUKir9WJkJtHV3eUNV7giCnFX42uDHwtdWW6Rq34P9BMXWEWuVLct1qgp1jhwvAJnvmPqGYZYknSQfW1o"],</span>
  <span class="hljs-comment">// "version": 2,</span>
  <span class="hljs-comment">// "recipient": "3P9E5QeGSF4As6kNtBi8j476gsM8mqnX12f",</span>
  <span class="hljs-comment">// "assetId": null,</span>
  <span class="hljs-comment">// "feeAssetId": null,</span>
  <span class="hljs-comment">// "feeAsset": null,</span>
  <span class="hljs-comment">// "amount": 100000,</span>
  <span class="hljs-comment">// "attachment": ""</span>
  <span class="hljs-comment">//}</span>
})
.catch (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
    <span class="hljs-built_in">console</span>.log (err);
});

</div></code></pre>
<p>Please note that Waves Keeper accepts a different object than <code>waves-transactions</code>. More information about the Waves Keeper API can be found in the documentation on the <a href="https://github.com/wavesplatform/waveskeeper">Github project repository</a> page.</p>
<h2 id="waves-signer">Waves Signer</h2>
<p>The user experience is one of the hardest parts of developing a decentralized application. In my opinion, one of the key reasons for the lack of mass popularity of the technology is the rather large number of barriers for users. It is sometimes very difficult to start using blockchain. Waves Keeper, although it is an extremely safe tool, is also a barrier that requires downloading the extension. Waves Signer aims to solve this problem.</p>
<p>Waves Signer is a wrapper over various providers that directly store keys and sign transactions. One provider for Waves Signer is currently available - Waves.Exchange provider, but in the future providers for Waves Keeper, Ledger crypto wallet and Waves.Exchange desktop client will be available.</p>
<p><img src="../../assets/8-1-1-signer.png" alt="Waves Signer scheme" title="Waves Signer scheme"></p>
<p>The existing provider from Waves.Exchange offers a completely new user experience. Unlike Waves Keeper, where the keys are stored in an extension, the Waves.Exchange provider stores encrypted keys in the <code>localStorage</code> of the site<code> https: // waves.exchange</code> and provides the user with an interface in the form of an <code>ifаme</code> window where he can agree to sign the transaction or reject it.</p>
<p><img src="../../assets/8-1-2-signer-example.png" alt="Waves Signer example" title="Waves Signer example"></p>
<p>This signature option is less secure because:</p>
<ul>
<li>The user trusts his keys to the page <code>https://waves.exchange</code>. It is important to understand that the page does not send it anywhere and stores it locally on the user's device, but in theory, at any time in the future it may start sending it to the server</li>
<li>At the moment of confirmation of the transaction signature, other malicious scripts can block the provider's window and allow the user to sign other data, not the one he sees on the screen</li>
</ul>
<p>But these risks are trade-offs in order not to force users to download the browser extension.</p>
<p>Let's take a look at how to integrate Waves Signer with Waves.Exchange provider into your page. First, we will create buttons in which we will bind user actions and include a script where we will describe the logic:</p>
<pre class="hljs"><code><div>&lt;main&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span> = <span class="hljs-string">"js-login"</span>&gt;</span> Authorization <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span> &lt;br&gt; &lt;br&gt;
    &lt;button class = "js-invoke"&gt; Invoke Script &lt;/button&gt; &lt;br&gt;
&lt;/main&gt;
&lt;script src = "../ dist / example.js"&gt; &lt;/script&gt;
</div></code></pre>
<p>In the file <code>example.js</code>, connect the Signer itself and the provider for Waves.exchange:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> Waves <span class="hljs-keyword">from</span> <span class="hljs-string">"@ waves / signer"</span>;
<span class="hljs-keyword">import</span> Provider <span class="hljs-keyword">from</span> <span class="hljs-string">"@ waves.exchange / provider-web"</span>;

<span class="hljs-comment">// settings for testnet</span>
<span class="hljs-keyword">const</span> waves = <span class="hljs-keyword">new</span> Waves ({<span class="hljs-attr">NODE_URL</span>: <span class="hljs-string">'https://pool.testnet.wavesnodes.com'</span>});
<span class="hljs-comment">// Settings for the Waves.exchange provider</span>
<span class="hljs-keyword">const</span> provider = <span class="hljs-keyword">new</span> Provider (<span class="hljs-string">'https://testnet.waves.exchange/signer/'</span>);
waves.setProvider (provider);

</div></code></pre>
<p>In order for the Waves Signer window to appear at the moment of pressing the button, we will bind the callback to the click event:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">document</span>.querySelector (<span class="hljs-string">". js-login"</span>). addEventListener (<span class="hljs-string">"click"</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> userData = <span class="hljs-keyword">await</span> waves.login (); <span class="hljs-comment">// Call Waves Signer</span>
        event.target.classList.add (<span class="hljs-string">"clicked"</span>);
        event.target.innerHTML = <span class="hljs-string">`
            authorized as &lt;br&gt;
            $ {userData.address} `</span>; <span class="hljs-comment">// Get the user's address</span>
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-built_in">console</span>.error (<span class="hljs-string">'login rejected'</span>) <span class="hljs-comment">// user rejected the authorization request</span>
    }
});
</div></code></pre>
<p>After pressing the button and allowing authorization, the user's address will appear on the button itself.</p>
<p>Let's look at an example of creating and sending a transaction by clicking on a button:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">document</span>.querySelector (<span class="hljs-string">". js-invoke"</span>). addEventListener (<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    waves.invoke ({
        <span class="hljs-attr">dApp</span>: <span class="hljs-string">"3MuN7D8r19zdvSpAd1L91Gs88bcgwUFy2mn"</span>,
        <span class="hljs-attr">call</span>: {
            <span class="hljs-attr">function</span>: <span class="hljs-string">"faucet"</span>
        }
    }). broadcast (). then (<span class="hljs-built_in">console</span>.log)
});
</div></code></pre>
<p>The API for generating transactions is the same as what is passed in <code>waves-transaction</code>, which can be extremely convenient during development.</p>
<p>More information about Waves Signer and an example of integration can be found in the article <a href="https://medium.com/@izhur27/getting-started-with-waves-signer-893017c9b7ae">by Vladimir Zhuravlev on medium</a>.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="chapter-9-looking-to-the-future">Chapter 9. Looking to the future</h1>
<p>The Waves protocol is constantly evolving, with new projects, new users, and blockchain applications emerging regularly. Let's talk about what is &quot;on the wave of the hype&quot; now and what to expect in the future.</p>
<p>In addition, it is worth answering the question &quot;when is blockchain needed&quot;, and not abstractly and in theory, but as concrete as possible with examples. Blockchain is just a technology that needs application, and without application and users, it costs nothing.</p>
<h2 id="when-is-blockchain-needed">When is blockchain needed?</h2>
<p>There are 3 main principles to keep in mind when trying to use blockchain:</p>
<ul>
<li><strong>Blockchain is a solution to common problems.</strong> Blockchain is best suited in situations where there are multiple parties sharing the same problem, not necessarily facing the same problem.</li>
<li><strong>Blockchain is a technology for creating ecosystems.</strong> Open or closed ecosystems are ideal for blockchain. In the case of open ecosystems, the ability to quickly join a common protocol for exchanging data and performing transactions is a key characteristic, while in the case of closed ecosystems, the most important thing is not having to transfer control to one side.</li>
<li><strong>Tokens are a way of organizing and ordering relationships.</strong> If tokens create new kinds of relationships or put existing communications in order, then using a token makes sense.</li>
</ul>
<p>At the moment, there are 2 areas in which the new Web3 decentralized applications have maximum prospects - decentralized finance and corporate applications.</p>
<h2 id="decentralized-finance">Decentralized finance</h2>
<p>Blockchain and financial services are inseparable from each other, but if earlier blockchain performed the function of preserving wealth or was a speculative asset, now it is actively developing towards building a full-fledged financial system based on tokens. The decentralized financial services market is most often referred to as DeFi.</p>
<p>Decentralized platforms and applications currently offer token trading and exchange services, lending services, algorithmic stablecoins, derivatives, payment systems and options. Almost all services are based on the principle of cryptocurrency collateral, and at the moment the volume of collateral on smart contracts in the main blockchains (Ethereum, Waves, Bitcoin, etc.) is more than $ 1.5 billion according to <a href="https://defipulse.com/">https://defipulse.com </a>.</p>
<p><img src="../../assets/9-0-1.png" alt="DeFi pulse" title="Billy dashboard"></p>
<p>Waves ecosystem has long existed the waves.exchange decentralized exchange, which was and is the pioneer of decentralized financial services on the blockchain. Now waves.exchange provides access to the following financial instruments:</p>
<ol>
<li>https: //waves.exchange is a hybrid exchange with matcher at its heart. The volume of transactions on the exchange is about $ 500 thousand per day.</li>
<li>https: //lombardini.io is a crypto pawnshop that can issue Waves tokens in exchange for Bitcoin as collateral (and vice versa). The service will charge a small percentage for using tokens.</li>
<li>https://waveflow.xyz is a decentralized application with constant liquidity. The app stores various tokens issued on Waves and allows you to exchange them. The price is calculated depending on the amount of a particular token on the balance of the application. The fewer tokens left on the account, the more expensive they will be and vice versa.</li>
<li>https://neutrino.at - algorithmic stablecoin, accustomed to the US dollar. Each Neutrino token is equal to $ 1, since the corresponding number of Waves tokens is in the backing of the token. Neutrino code takes into account the market price of Waves token on centralized exchanges and balances collateral with bonds. How Neutrino works is described in the <a href="https://neutrino.at/whitepaper">white paper</a>, and the source code is <a href="https://github.com/ventuary-lab/neutrino-contract">posted on Github</a>.</li>
</ol>
<p>Neutrino is the most successful DeFi app in the Waves ecosystem, with over 8.1M Waves locked and over $ 13M issued on the contract.</p>
<p>A feature of DeFi applications is <em>composability</em>. It means the ability to link applications to each other, to use the capabilities of one application in another. For example, you can make a DeFi application that uses Neutrino tokens or data from the Neutrino contract and WaveFlow at the same time. This does not require special APIs or permissions, since the protocol is a blockchain in which all data and function parameters are open, and your decentralized application can read data from the storage of any other DeFi application.</p>
<h2 id="enterprise-applications">Enterprise applications</h2>
<p>All the advantages of the blockchain are revealed in an environment where there are several parties that do not trust each other or do not want to trust. Such conditions are often encountered in a corporate environment, when several companies or divisions in one organization want to exchange data, but are not ready to give control over it to any of the participants in the process.</p>
<p>An example of a successful application of blockchain in a corporate environment is the <a href="https://iambilly.app">Billy</a> project, which solves a common problem for company employees and management, using tokens as a way to organize the employee reward process. For example, Company A uses Billy to distribute benefits more equitably and personalize benefits.</p>
<p>The company allocates an annual budget to reward employees with vouchers, additional vacations and services (extended health insurance programs, souvenirs, etc.). Using the Billy token, Company A selects the most valuable employees. Thanks to the openness of the blockchain, all employees see their performance and can evaluate the objectivity of the choice of people for reward. This transparency further motivates staff.</p>
<p>Tokens create an entire ecosystem where employees can motivate their colleagues to help them in exchange for tokens.</p>
<p><img src="../../assets/9-0-0.png" alt="Billy dashboard" title="Billy dashboard"></p>
<p>An additional opportunity appears for the company's management to analyze the effectiveness of employees, not only qualitatively (regular transparent assessment processes by colleagues with whom they interact most), but also quantitatively (drawing up an overall rating of employees and departments).</p>
<h1 id="gravity">Gravity</h1>
<p>At the end of 2019 in Berlin, Alexander Ivanov, the founder of the Waves protocol, announced the creation of Gravity, a new product of the team, which is designed to solve several problems at once.</p>
<p>We are now seeing a rapid development in the development of a variety of blockchain protocols, platforms and experimental developments, almost the same rapid growth of the Internet we saw 20 years ago. The diversity of technologies generates progress, at the same time it leads to a weakening of the adoption of technology by the masses (mass adoption). Product developers and organizations are now forced to choose a specific technology or protocol on which to build their applications. In turn, users and audiences of other protocols lose access to such applications. All this makes the ecosystem as a whole very fragmented, fragmented and economically ineffective.</p>
<p>Each decentralized system with an internal token economy is closed in terms of the exchange of information both with other networks and with the outside world. To transfer data from the outside world to the blockchain network, as well as communication between different blockchain networks, it is necessary to trust the so-called oracles. The paradox of the need to trust individual elements in systems designed to remove elements of trust arises. The search and development of solutions that create conditions for increased reliability and security of the use of blockchain networks with oracles, as well as communication between networks, is a key task in the industry at the moment.</p>
<p>Finally, an effective solution to the problem of cross-blockchain communication and data oracles opens up opportunities for horizontal scaling of products that are built on blockchain protocols through the mechanism of so-called sidechains.</p>
<p>To date, there are already projects that solve the problems described above: Chainlink, CosmosHub, Polkadot and others. However, most of the existing solutions have three common disadvantages:</p>
<ul>
<li>Focused on developing their own, complementary blockchain, instead of really being a blockchain agnostic solution.</li>
<li>Introduce a new level of complexity into the system in the form of a token with special economic properties and a floating, highly volatile exchange rate.</li>
<li>In reality, they are not a complex blockchain-agnostic system of oracles that supports communication of blockchain networks with the outside world, cross-blockchain communication and funds transfers, as well as sidechains within one coherent structure.</li>
</ul>
<p><a href="https://gravity.tech/">Gravity</a> is designed to solve the indicated problems and is a solution to the following problems, sorted in order of priority:</p>
<ul>
<li>Blockchain agnostic decentralized cross-blockchain communication: Decentralized applications across different blockchains must be able to exchange data or values. For example, a Waves account holder should be able to work with the Uniswap app on the Ethereum network, without having to create an Ethereum account and buy Eth tokens. Or any Ethereum account holder should be able to use the Neutrino dApp and stake without having to create a Waves account and buy Waves on exchanges. All this will be automatically provided by the Gravity system.</li>
<li>Economic motivation of agents to provide data from the real world and other blockchains: Gravity provides data providers with the opportunity to monetize their services, expressed in native tokens of Gravity-supported blockchain platforms</li>
<li>Having the ability to receive data from the real world and from other blockchains without the need to trust a centralized entity opens up opportunities for scaling networks using sidechains</li>
<li>Providing developers with a technical variety so that they can choose the most suitable tools: virtual machines or non-Turing-complete programming languages; fixed or variable fees; consensus algorithms (Proof of Work, Proof of Stake, Leased Proof Of Stake, BFT, etc.).</li>
</ul>
<blockquote>
<p>Simply put, Gravity solves 2 problems:
1.problem of oracles - through their decentralization (we looked at problems in chapter 7 on the example of Oraculus)
2. the problem of incompatibility of blockchain protocols - through the ability to transfer data and funds from one blockchain to another</p>
</blockquote>
<p><strong>Unlike other similar platforms, Gravity does not use its own token, which compares favorably with competitors.</strong></p>
<p>The scheme of work of Gravity is shown in the diagram below:</p>
<p><img src="../../assets/9-1-0.png" alt="Gravity" title="Gravity"></p>
<p>Development of Gravity is currently in active phase, research work is underway and discussions on the best solution architecture are underway, so if you are interested in participating, you can do it in <a href="https://github.com/orgs/Gravity-Tech">Github Gravity</a> ...</p>
<p>The full technical description and principles on which Gravity is built can be found in the <a href="https://gravity.tech/docs/whitepaper.pdf">White Paper</a>.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="conclusion">Conclusion</h1>
<p>The world of Web3 applications, blockchains and decentralized systems is actively developing, more and more new interesting solutions and ideas appear in the community, so it is not possible to cover all the features of Web3 applications or the Waves platform within one book (or even three). At the same time, the knowledge gained in this book will help you to start developing applications on the Waves protocol as quickly as possible, design the architecture correctly, and find the right resources for further immersion.</p>
<p>I wish you to enjoy creating your first (or maybe not the first) working decentralized app on Waves. Blockchain platforms lack applications that can attract a large number of users, so I want your application to be just that and be able to change user habits and ultimately make people's lives better.</p>
<p>If you would like to continue exploring the Waves Protocol or would like to be directly involved in its development, I invite you to visit the <a href="https://github.com/wavesplatform">Waves Protocol</a> Github page and take the course <a href="https://www.coursera.org/learn/mastering-web3-waves">Mastering Web3 With Waves on Coursera</a></p>
<p>If you want to chat with the same developers like you or ask a question to the author of the book, then join the group on Telegram - https://t.me/waves_ride_dapps_dev</p>

</body>
</html>
