<!DOCTYPE html>
<html>
<head>
<title>all-in-one.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 align="center">Web3 приложения на Waves</h1>
<h3 align="center">пособие для начинающих</h3>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h5 align="center">Inal Kardanov<br>2020</h5>
</div>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%BE%D0%B3%D0%BB%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">Оглавление</h1>
<p><a href="../../sections/0-intro.md">Введение</a></p>
<p><a href="../../sections/1-Waves-Introduction/1-0-intro-web3.md">Глава 1. Краткая история веба и протокола Waves</a></p>
<p><a href="../../sections/2-Network-Features/2-1-node-configuration.md">Глава 2. Нода Waves и как она работает, ее конфигурация</a></p>
<p><a href="../../sections/3-Accounts/3-1-keys.md">Глава 3. Аккаунты и ключи</a></p>
<p><a href="../../sections/4-Tokens/4-1-tokens-and-how-to-work.md">Глава 4. Токены</a></p>
<p><a href="../../sections/5-Transactions/5-1-transactions-intro.md">Глава 5. Транзакции</a></p>
<p><a href="../../sections/6-Ride/6-1-introduction.md">Глава 6. Язык программирования Ride</a></p>
<p><a href="../../sections/7-dApp-Examples-and-Recipes/7-2-Billy.md">Глава 7. Практикум: пишем Web3 приложения</a></p>
<p><a href="../../sections/8-important-aspects/8-0-important-aspects.md">Глава 8. Лучшие друзья разработчика</a></p>
<p><a href="../../sections/9-next-big-things/9-0-gravity-hub.md">Глава 9. Смотрим в будущее</a></p>
<p><a href="../../sections/10-outro.md">Заключение</a></p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5">Введение</h1>
<p>Данная книга может вам помочь максимально быстро сделать свое первое Web3 приложение на блокчейне Waves не допуская фатальных ошибок. Эта книга акцентирована на примеры, разбор реальных кейсов, конкретные рецепты, которые вы можете применять в своих приложениях. Но, как и во многих аспектах жизни, переход к реальным задачам требует фундаментальных знаний о протоколе. Поэтому в первых трех главах рассказывается об особенностях Web3 и блокчейна Waves, чем он отличается от других блокчейнов, наряду с разбором что и как может влиять на архитектуру вашего приложения и какие могут быть ограничения. Книга сфокусирована на особенностях работы с Web3 приложениями на Waves, но не на базовых понятиях вроде &quot;что такое блокчейн?&quot; и &quot;как работает алгоритм консенсуса?&quot;, так как материалов о том, как работает блокчейн, огромное количество, в то время как найти особенности отдельных протоколов, примеры и рецепты достаточно проблематично.</p>
<p>Важно понимать, что книга так же не является &quot;полным справочником&quot; по Waves, так как делает акцент на прикладные аспекты протокола. Она не пытается конкурировать с <a href="https://docs.wavesplatform.com">документацией протокола</a>, которая уже есть достаточно давно и покрывает многие аспекты работы с Waves.</p>
<p>После прочтения этой книги вы будете в состоянии писать смарт-контракты на языке Ride, понимать особенности платформы Waves, сможете сделать свое первое децентрализованное Web 3 приложение.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-1-%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%B0%D1%8F-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D0%B2%D0%B5%D0%B1%D0%B0-%D0%B8%D0%BB%D0%B8-%D0%BE%D1%82-web-10-%D0%BA-web-30">Глава 1. Краткая история веба или от Web 1.0 к Web 3.0</h1>
<p>Вы держите в руках книгу, которая посвящена Web3, но, возможно, вы сперва хотите узнать, что такое Web3, чем это отличается от Web2 и причем тут волны (Waves). В этой главе мы разберемся во всех этих вопросах.</p>
<p>Наверняка вы слышали, что интернет, как технология передачи сигналов, появился более 50 лет назад, а если быть точнее, то 2 сентября 1969 года. Именно в этот день 2 компьютера впервые передали друг другу данные. Но всемирная паутина в нашем текущем понимании, была изобретена сэром Тимом Бернерсом Ли 20 лет спустя, в 1989. Фактически, он придумал Интернет, который мы знаем сегодня, состоящий из миллионов связанных друг с другом с помощью ссылок документов с гипертекстовой разметкой. Интернет в 1989 году был совершенно другим, в нем не было социальных сетей вроде Facebook, интернет-магазинов вроде Amazon и даже поисковых систем и сайтов с мемасиками.</p>
<p>Интернет в те времена был &quot;только для чтения&quot;. Сайты были только у научных центров, крупных университетов и компаний, и именно они создавали весь контент и распространяли в виде статичных веб-страниц, единственной формой взаимодействия с которыми был переход по ссылке на другую страницу. Это был прекрасный мир Web 1.0.</p>
<p><strong>Другими словами, Web 1.0 - Интернет &quot;только для чтения&quot; для большинства его пользователей.</strong></p>
<p>Шло время и скорость распространения технологии только увеличивалась, в 90-х Интернет пережил бум и &quot;крах доткомов&quot;, но именно этот крах дал возможность появиться следующей эволюции веб-страниц в интернете. Эти веб-страницы отличались тем, что предлагали пользователям инструменты для взаимодействия друг с другом. Одними из первых таких форм взаимодейтсвия были форумы, которые сейчас почти канули в небытие, но когда-то были очень популярны. Кроме форумов, начали появляться и другие платформы с контентом от пользователей, а не только владельцев сайта (user generated content). Интернет стал не только для чтения, но и для создания и созидания, страницы стали интерактивными, технологии позволили взаимодействовать пользователям без перезагрузок страниц (появился AJAX). Мы до сих пор живем в мире Web 2.0.</p>
<p><strong>Web 2.0 - Интернет с контентом от пользователей и возможностью взаимодействовать с другими пользователями</strong></p>
<p>Но что же такое Web 3.0? Какое дать ему определение? Возможно, вы достаточно стары, чтобы помнить такую идею как &quot;семантический веб&quot;. Семантический веб - семейство стандартов, которые были нацелены на создание протоколов обмена данными в Сети. Пару лет назад именно это понимали под Web 3.0, но сейчас видение будущего изменилось.</p>
<p>Всемирная сеть становится все более сложной, связной, и даже умной. Растет количество пользователей, количество и качество их взаимодействий. Растет и количество вызовов и проблем, с которыми сталкивается всемирная паутина, в особенности в связи со взломами, утечками данных, манипулированиями, продажами персональной информации и т.д. Во многом это вызвано историей веба, ведь с самого начала в Интернете практически не было моделей монетизации кроме рекламы, которая ведет к слежке за пользователем. А самой естественной формой развития интерне-платформ стали монополии, ведь в интернете нет границ, физических ограничений, поэтому захватывать рынки гораздо проще. Одним из ответов на эти проблемы является <strong>децентрализация</strong>. Веб будущего должен быть нацелен в первую очередь на безопасность, приватность и должен ставить в центре внимания пользователя, а не корпорации. Для этого Web 3.0 может использовать такие технологии как Blockchain, но, очевидно, что в вебе будущего будет много и Artificial Intelligence, Big Data, VR/AR.</p>
<p>Переход к Web 3.0 отличается от перехода Web1.0 -&gt; Web2.0. Web 3.0 не про скорость, производительность или удобство, а про <strong>власть</strong>. Власть пользователей над своими данными, а не корпораций над пользователями.</p>
<p>Один из пионеров Web 3.0 и со-основатель блокчейн платформы Ethereum Гэвин Вуд еще в 2014 в своем <a href="http://gavwood.com/dappsweb3.html">блог-посте</a> описал Web 3.0 следующими словами:</p>
<blockquote>
<p>«Переосмысление вещей, для которых мы уже используем Web, но с принципиально другой моделью взаимодействия между сторонами. Информацию, которую мы считаем общедоступной, мы публикуем. Информацию, относительно которой мы хотим договариваться, мы помещаем в распределенный реестр. Информацию, которая является приватной, мы держим в секрете и никогда не раскрываем. Связь всегда происходит по зашифрованным каналам и только с псевдонимами в качестве конечных точек; но никогда с отслеживаемым псевдонимами (например, IP-адресами). Короче говоря, мы проектируем систему, которая <strong>математически</strong> принуждает соблюдать наши предположения о доступности информации, ведь никакому правительству или организации нельзя доверять».</p>
</blockquote>
<p>Математическим принуждением соблюдения наших допущений является использование криптографии, а избавиться от доверия нам позволяет блокчейн. В этой книге мы практически не будем затрагивать вопросы криптографии, так как нас больше интересует практическая применимость идей Web3 и как уже сегодня можно начать делать приложения веба будущего.</p>
<h2 id="%D0%B8%D0%B7-%D1%87%D0%B5%D0%B3%D0%BE-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D1%82-web-30">Из чего состоит Web 3.0</h2>
<p>Web3 сейчас находится в своем зачаточном состоянии как в плане количества приложений, так и в плане количества пользователей этих приложений. И именно поэтому сейчас самое время начать делать такие приложения, которые помогут привлечь больше пользователей. В то же время, никто не исключает сценария, что наше текущее понимание Web 3.0 изменится в будущем и, описанные в этой книге принципы, станут так же не актуальны, как не актуален &quot;семантический веб&quot;.</p>
<p>Давайте разберемся, из чего состоит Web 3.0 в текущем понимании. В этом нам поможет описание слоев технологий Web 3.0, которое можно найти на сайте <a href="https://web3.foundation/about/">Web3 Foundation</a>. В данный момент Web3 стэк описывает все, что связано с блокчейном, не затрагивая другие возможные технологии. Стэк состоит из 5 слоев, от уровня 0 до уровня 4.</p>
<p>Уровень 0 является основой технологического стека Web3, состоящего из того, как узлы сети взаимодействуют и как их можно программировать на самом низком уровне. В рамках этой книги мы будем рассматриваем Waves Blockchain и его протокол общения узлов. Во многих случаях уровень 0 является черным ящиком для разработчиков приложений, который никак не влияет на пользовательский опыт или процесс разработки.</p>
<p>Следующий уровень - это уровень 1, который распространяет данные и взаимодействует с ними. Уровень также может называться &quot;протоколом взаимодействия с нулевым доверием&quot;. По сути, это протокол, который описывает, как различные узлы в сети блокчейна взаимодействуют друг с другом, он позволяет им обмениваться и проверять друг друга. Этот уровень в основном касается протоколов распространения данных и временных / промежуточных сообщений. Уровень 1 необходим для правильной работы самого блокчейна. Этот уровень может влиять на пользоватский опыт, например, в плане задержек попадания информации в блокчейн, поэтому важно понимать как на этом уровне работает система.</p>
<p>При разработке Web3 приложений вы определенно будете работать с протоколами второго уровня. Это серия протоколов, которые включают в себя множество интересных технических решений, таких как State Channels, Plasma Protocols, оракулы и так далее. Этот уровень расширяет возможности уровня 1, обеспечивая масштабирование, зашифрованный обмен сообщениями и распределенные вычисления. В этой книге мы будем описывать работу с оракулами. Оракулы - это способ получать данные из реального мира в рамках блокчейн системы (например, погоду или цены на акции). Web3 приложения очень часто завязаны на данные, которые находятся за рамками блокчейна, поэтому работа с такими данными и оракулами крайне важна. В главе 7 мы подробнее рассмотрим проблемы оракулов.</p>
<p>Уровень 3 посвящен языкам программирования и библиотекам, которые позволяют разработчикам создавать программы на должном уровне абстрации, без лишних низкоуровненвых деталей. Этот уровень также известен как &quot;расширяемые протоколы, API-интерфейсы и языки для разработчиков&quot;. Существует множество языков, которые можно использовать для разработки приложений без использования реального байт-кода, такие как Solidity для Ethereum, Plutus для Cardano и Ride для Waves. Кроме того, существует множество платформ и библиотек, которые облегчают разработку приложений, взаимодействующих с блокчейном. Мы будем использовать Ride и библиотеку JavaScript для Waves Blockchain. Существует множество библиотек для разных языков, для PHP, Java, Python, Kotlin, Swift и многих других, но мы рассмотрим только библиотеку JavaScript/Typescript.</p>
<p>Наконец, мы переходим к верхнему уровню стека, уровню 4, который является уровнем пользовательского интерфейса. Он содержит технологии, которые позволяют обычному пользователю, не разработчику, взаимодействовать с Web3 приложениями. Некоторые распространенные браузеры (например, Opera) позволяют пользователям напрямую взаимодействовать с блокчейнами, но некоторые из самых популярных браузеров: Chrome, Firefox и Microsoft Edge требуют дополнительных инструментов от пользователей, наиболее распространенным инструментом являются браузерные расширения. В главе 8 мы рассмотрим пример такого браузерного расширения и разберемся как с ним работать.</p>
<p>Общая схема Web3 стэка выглядит следующим образом:</p>
<p><img src="../../assets/1-0-1-1-web3-stack.png" alt="Web3 Stack" title="Web3 Stack"></p>
<h2 id="%D1%81%D1%82%D1%8D%D0%BA-%D1%82%D0%B5%D1%85%D0%BD%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D0%B9-waves">Стэк технологий Waves</h2>
<p>В этой книге мы будем рассматривать все слои стэка Web3 на примере протокола Waves.</p>
<p><img src="../../assets/1-0-1-2-waves-web3-stack.png" alt="Waves Web3 Stack" title="Waves Web3 Stack"></p>
<p>Наше рассмотрение начнем с самых базовых слоев, далее поговорим про язык программирования Ride, инструменты для разработки, оракулы и способы взаимодействия с пользователем. В ходе рассмотрения технологий, мы так же будем говорить о философии и о причинах тех или иных технических решениях.</p>
<h1 id="11-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-waves">1.1 История создания Waves</h1>
<h2 id="%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-waves">Что такое Waves?</h2>
<p>Waves это Proof-of-Stake permissionless блокчейн-платформа общего назначения, создаваемая с 2016 года и призванная помочь найти массовое применение технологии блокчейн. Блокчейн платформа Waves является одной из наиболее зрелых (как в виду возраста, так и в виду большого числа проектов) и легких для начинающих разработчиков, которые хотят использовать преимущества блокчейна с максимальной пользой. В рамках этой книги мы разберем основные технические особенности, поговорим о преимуществах и рассмотрим много реального кода, но прежде чем заняться этим, немного поговорим про историю Waves, чтобы лучше понимать истоки тех или иных особенностей.</p>
<h2 id="%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D0%BE-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0">Начало проекта</h2>
<p>Waves как блокчейн начался в 2016 году, когда основатель платформы <a href="https://twitter.com/sasha35625">Александр Иванов</a> инициировал сбор средств в рамках ICO. Платформа с самого начала позиционировала себя как блокчейн общего назначения, без фокуса на отдельных специфических сферах применения. Основной задачей, которую собиралась решать платформа (и во многом успешно решала) является пропускная способность. На начало 2016 года существовало очень мало блокчейнов, которые могли обрабатывать сотни транзакций в секунду. Фактически, на рынке полноценно работали только Bitcoin (и его форки вроде Litecoin) с 7 транзакциями в секунду и Ethereum с 15 транзакций/сек. Так что проблема пропускной способности блокчейна была крайне актуальной.</p>
<h3 id="%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5-%D0%B2%D0%B5%D1%85%D0%B8-%D1%80%D0%B0%D0%B7%D0%B2%D0%B8%D1%82%D0%B8%D1%8F-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0">Основные вехи развития проекта</h3>
<p>Успешный сбор средств на ICO был только началом проекта, дальше предстояло реализовать все обещанное максимально хорошо. Изначально была выбрана технологическая база фреймворка <a href="https://github.com/ScorexFoundation/Scorex">Scorex</a>. От самого фреймворка в кодовой базе проекта сейчас почти ничего не осталось, но Scorex написан на языке Scala, что и определило надолго технологический стэк разработки протокола. До недавнего времени реализация ноды (то есть протокола) на Scala была единственной, только относительно недавно появилась так же реализация на Go. Cтоит отметить, что на момент написания этих строк, версия на Go отставала от версии на Scala по возможностям, об этом мы поговорим в следующих разделах. Запуск основной сети (в дальнейшем будем называть mainnet) Waves произошел в декабре 2016 года. Проект с самого начала имел особенности: легкий выпуск своих токенов/ассетов (с помощью отправки одной транзакции) и PoS c моделью лизинга (стейкинга). Данные особенности мы разберем в дальнейших разделах.</p>
<p>Другими примечательными вехами в истории протокола можно назвать следующие даты:</p>
<ul>
<li>Выпуск DEX (гибридной биржи) в 2017 году. Логичным продолжением нативной поддержки выпуска токенов с помощью транзакции (не контракта как в Ethereum), явился выпуск матчера, который обеспечивал работу децентрализованной биржи.</li>
<li>В том же году был реализован протокол Waves NG, который позволил достичь хорошей пропускной способности. Waves NG был реализован на основе идей, изложенных в <a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">статье</a>. Данные предложения были нацелены на улучшение протокола Bitcoin, но никогда не были там реализованы, зато были воплощены в Waves.</li>
<li>Летом 2018 года был выпущен язык для смарт-контрактов Ride, который позволил менять логики аккаунтов, а в января 2019 года появилась возможность писать контракты для токенов</li>
<li>Летом 2019 года до мейннета добрался Ride для полноценных децентрализованных приложений (Ride4dApps)</li>
<li>Осенью 2019 года появилась первая в своем роде (среди основных блокчейнов проектов) монетарная политика</li>
</ul>
<h3 id="%D0%B2%D0%BB%D0%B8%D1%8F%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-waves-%D0%BD%D0%B0-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB">Влияение истории Waves на протокол</h3>
<p>История создания Waves достаточно сильно повлияла на технические детали проекта. Например, фреймворк Scorex корнями уходит в проект Nxt, другой Proof-of-Stake блокчейн с нативными токенами. Обе особенности были унаследованы Waves именно из Nxt. Легкость создания токенов и скорость работы протокола в дальнейшем сделали проект второй по популярности платформой для выпуска токенов и запуска ICO (сразу после Ethereum). Большое количество проектов на Waves использовали блокчейн именно для работы с токенами. С 2019 года на активно развиваются проекты, связанные с финансами сервисами, поэтому можно сказать, что в фокусе Web3 проектов на платформе сейчас находится задача создания открытой экосистемы финансовых продуктов.</p>
<h1 id="12-%D0%BF%D0%BE%D0%B4%D1%85%D0%BE%D0%B4%D1%8B-%D0%BA-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B5-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB%D0%B0-waves">1.2 Подходы к разработке протокола Waves</h1>
<p>Разработчики протокола Waves всегда руководствовались некоторыми базовыми принципами, которые сильно влияют на дальнейшее развитие протокола. Понимание данных принципов и мотивации за ними поможет легче следить за дальнейшим развитием проекта, поэтому перечислю данные особенности.</p>
<h2 id="%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD-%D0%B4%D0%BB%D1%8F-%D0%BB%D1%8E%D0%B4%D0%B5%D0%B9">Блокчейн для людей</h2>
<p>Мантрой Waves долгое время было &quot;Blockchain for the people&quot;. Она полностью отражала и отражает то, что делает команда. Главное, чего хочет достичь платформа - <strong>популяризировать технологию блокчейн для масс</strong>. В данный момент блокчейн является технологией для очень небольшой группы людей, которые понимают, что это за технология и как ее правильно использовать. Waves хочет изменить такое положение вещей и сделать так, чтобы технология приносила максимальную пользу всем.</p>
<p>Многие люди думают, что технология блокчейн крайне сложная и наукоемкая (во многом так и есть), Waves же пытается скрывать всю сложность за простым слоем абсракции. Блокчейн - это не самая удобная база данных, у которой есть несколько важных свойств: децентрализация, неизменяемость и открытость. Данные особенности не являются ценностями сами по себе, а только в случае правильного применения разработчиками конкретных приложений. Цель Waves состоит в предоставлении таких инструментов разработчикам, которые позволят им быстрее, проще, без излишнего погружения в сложные технические, давать ценность конечным пользователям.</p>
<p>Можно сказать, что принцип ориентации на реальное применение разбивается на несколько шагов:</p>
<ol>
<li>Платформа предоставляет разработчикам приложений легкий инструмент для использования особенностей блокчейна</li>
<li>Разработчики приложений делают продукты, которые решают проблемы пользователей и правильно используют блокчейн</li>
<li>Пользователи получают преимущества блокчейна. При этом не обязательно, чтобы пользователи знали что-то про блокчейн. Главное, чтобы решалась их проблема.</li>
</ol>
<h2 id="%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F-%D0%BD%D0%B0-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D1%83%D1%8E-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C">Ориентация на практическую применимость</h2>
<p>Всегда, во время разработки нового функционала или продукта, во главе угла ставится <strong>практическая применимость</strong> и какое количество людей <strong>потенциально</strong> смогут решить свои проблемы с помощью этого. Разработчики протокола пытаются не делать &quot;космические корабли&quot;, решать &quot;сферические проблемы в вакууме&quot; или заниматься оверинжинирингом, выбирая применимость &quot;здесь и сейчас&quot;. Лучше ведь иметь работающее сейчас, чем идеальное через 10 лет. Конечно, данный принцип не должен вступать в противоречие с безопасностью сети.</p>
<h2 id="%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D1%81%D1%82%D1%8C-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">Открытость разработки</h2>
<p>Протокол Waves является полностью открытым и процесс разработки максимально децентрализован. Все исходные коды доступны на <a href="https://github.com/wavesplatform">Github</a>. Кроме непосредственно исходного кода, там же обсуждаются пути развития протокола, различные проблемы и варианты их решения. Обновления протокола, связанные с изменением консенсуса, всегда проходят процедуру обсуждения с помощью <a href="https://forum.wavesplatform.com/t/wep-0-waves-enhancement-proposal-unified-proposal-system/14781">Waves Enhancement Proposals</a>. Но обсуждения это только первый этап, ведь все обновления консенсуса должны еще проходить через процедуру активации с голосованием, о чем мы поговорим с следующем разделе. Теперь вы знаете, что делать, если захотите что-то изменить в протоколе или добавить.</p>
<h1 id="13-%D0%BE%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD%D0%B0-waves">1.3 Отличительные особенности блокчейна Waves</h1>
<p>Если у вас уже есть опыт работы с другими блокчейнами, вам может быть интересно, чем же отличается Waves от условного Ethereum и почему он другой. Давайте быстро пройдемся по отличиям, которые будут детально рассматриваться в следующих разделах.</p>
<h2 id="%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D1%82%D0%BE%D0%BA%D0%B5%D0%BD%D0%B0%D0%BC%D0%B8%D0%B0%D1%81%D1%81%D0%B5%D1%82%D0%B0%D0%BC%D0%B8">Работа с токенами/ассетами</h2>
<p>Одной из особенностей работы с Waves с первого дня была простота выпуска токенов. Для этого достаточно отправить транзакцию или <a href="https://docs.waves.exchange/en/waves-exchange/waves-exchange-online-desktop/online-desktop-asset/online-desktop-token-creation">заполнить форму из 5 полей</a>) в любом UI клиенте.
Выпущенный токен автоматически становится доступен для переводов, торговки на децентрализованной бирже, использования в dApp и сжигания.</p>
<p>В отличие от Ethereum, в Waves токены не являются смарт-контрактами, а являются &quot;гражданами первого сорта&quot;, то есть являются отдельной полноценной сущностью. У этого есть как преимущества, так и недостатки, о которых мы поговорим в разделе 4 &quot;Токены&quot;.</p>
<h2 id="%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8">Транзакции</h2>
<p>Другая отличительная особенность Waves заключается в наличии большого количества типов транзакций. Например, в Ethereum есть смарт-контракты, которые могут являться чем угодно, в зависимости от их реализации. ERC-20, описывающий токен, это просто описание интерфейса смарт контракта - какие методы он должен иметь. В Waves подразумеватся, что лучше иметь легковесные/узкие специфичные вещи, чем абстрактные &quot;обо всем и ни о чем&quot;. Специфичность примитивов упрощает во многих местах разработку, но это иногда является менее гибким решением.</p>
<p>Ниже представлен список актуальных транзакций на момент написания этих строк:</p>
<p><img src="../../assets/5-1-1-transaction-types.png" alt="Waves transaction types" title="Waves Transaction Types"></p>
<p>В главе 5 &quot;Транзакции&quot; мы подробно разберем каждую из них.</p>
<h2 id="leasing">Leasing</h2>
<p>В Waves есть механизм стейкинга, который называется leasing. Любой владелец токена Waves может отправить токены в лизинг любой ноде Waves, чтобы та производила блоки &quot;от имени этих токенов&quot;.</p>
<blockquote>
<p>Лизингодатель передает право на генерацию блоков от имени его токенов лизингополучателю (владельцу ноды).</p>
</blockquote>
<p>Обычно это делается, когда пользователь не хочет или не может заниматься разворачиванием своей ноды и ее поддержкой. Обычно, владельцы лизнговых пулов выплачивают б<strong>О</strong>льшую часть заработанного за счет лизинга средств лизингодателям. Отправить в лизинг средства можно моментально, но в генерируюющем балансе ноды они начнут учитываться только через 1000 блоков.</p>
<p>Забрать же токены из лизинга можно моментально.</p>
<h2 id="fair-pos">Fair PoS</h2>
<p>В Waves используется алгоритм Proof-of-Stake для определения права на генерацию блока. Блоки генерируются в среднем каждую минуту, а вероятность генерации блока нодой зависит от 3 параметров:</p>
<ul>
<li>Генерирующего баланса ноды, то есть баланса самой ноды + количества токенов, которые сдали ей в лизинг.</li>
<li>Текущего времени и рандома (великий Рандом есть всегда в жизни!)</li>
<li>Генерирующего баланса сети, ведь не все токены в сети участвуют в генерации блоков, они могут быть в ордерах на биржах или лежать на холодных кошельках.</li>
</ul>
<p>Чтобы начать генерировать блоки, достаточно иметь 1000 Waves генерирующего баланса (свои + полученные в лизинг). Зачем вам генерировать блоки? За каждый блок нода получает на свой баланс комиссии из транзакций в этом блоке и вознаграждение &quot;из воздуха&quot;. Оба этих момента не такие простые, так что рассмотрим их чуть позже.</p>
<p>Очень частый вопрос, который встречается - сколько блоков я буду генерировать в месяц с балансом N? Точное числе предсказать невозможно, так как зависит от случайностей и изменений в сети, но примерно предсказать можно. Чтобы сделать это, надо знать текущие параметры сети:</p>
<ol>
<li><em>Сколько токенов Waves участвуют в генерации блоков?</em> Это так называемый генерирующий баланс сети в целом. Для легкости рассчета скажем, что 50 млн токенов участвуют в генерации блоков.</li>
<li><em>Какой баланс нашей ноды?</em> То есть, сколько у нас своих токенов на аккаунте ноды и сколько нам сдали в лизинг. В нашем случае возьмем генерирующий баланс равный 10 000 Waves.</li>
<li>Среднее время блока составляет 1 минуту, то есть в сети генерируется примерно 1440 блоков в день или 43200 блоков в месяц.</li>
</ol>
<p>Для вычисления примерного количества блоков, которые мы сгенерируем, делим количество блоков за период на генерирующий баланс сети и умножаем на наш баланс:</p>
<p>$ForgedBlocks = BlocksCountInPeriod / NetworkGenBalance * NodeGenBalance$</p>
<p>Сделав нехитрые вычисления получаем:</p>
<p><code>43200 / 50000000 * 10000 = 8.64</code></p>
<p>То есть, в среднем нода будет генерировать 8-9 блоков в месяц, если будет работать стабильно и параметры сети не изменятся, но, такого, конечно, не бывает, ведь в сети постоянно делается большое количество транзакций, которые меняют генерирующие балансы всей сети в целоом и каждой ноды в отдельности.</p>
<h2 id="community-driven-monetary-policy">Community driven monetary policy</h2>
<p>Первое время в Waves была ограниченная эмиссия в 100 млн. токенов, которые были выпущены сразу на момент запуска мейннета, но с осени 2019 года в сообществе решили, что для дальнейшего роста экосистемы, лучше будет включить в протокол эмиссию токенов. То есть, в каждом новом блоке появляются новые токены Waves. Какое именно количество токенов определяется сообществом, которое голосует за размер вознаграждения каждые 100 тысяч блоков. На момент написания этих строк, вознаграждение за блок составляло 6 Waves. При этом гарантируется, что размер вознаграждения не может изменяться больше, чем на 0.5 Waves после каждого периода голосования.</p>
<h2 id="sponsorship">Sponsorship</h2>
<p>Функция спонсирования токена является способом снижения входных барьеров для пользователей. Суть в том, что аккаунт, выпустивший токен, может спонсировать транзакции с этим токеном. Представим, есть токен А, его выпустил Cooper и включил спонсирование. Например, Alice заработала 100 токенов A и хочет 10 из них отправить Bob. Мы то с вами знаем, что для каждой транзакции в блокчейне необходимо платить комиссию, в сети Waves майнеры принимают только Waves в виде комиссии, а у Alice нет Waves. Придется идти и как-то покупать Waves?</p>
<p>Нет. Спонсорство токена позволяет его владельцу сказать, что он готов взять на себя комиссии за операции с этим токеном (токеном А в нашем случае). Владельцы токена А будут платить этот же токен в виде комиссии при отправке транзакции. В нашем примере, Alice сможет указать в своей транзакции, что получатель - Bob, количество для отправления - 10 токенов A, комиссия - 5 токенов A. В итоге, с ее аккаунта спишется 15 токенов, 10 получит Bob, 5 получит Cooper, как выпустивший и спонсирующий токен, а майнер получит Waves c аккаунта Cooper'а.</p>
<p>Почему Alice заплатит 5 токенов и сколько получит майнер? Поговорим об этом в следующих главах. Главное, что сейчас необходимо запомнить - <strong>в Waves существуют способы отправить транзакцию, не имея токенов Waves у себя на балансе.</strong></p>
<h2 id="ride-%D0%B8-%D1%81%D0%BC%D0%B0%D1%80%D1%82-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D1%8B">Ride и смарт контракты</h2>
<p>Waves является блокчейном общего назначения, не специализирующемся на чем-то одном, поэтому появление смарт-контрактов стало логичным продолжением развития платформы. Про смарт-контракты в Waves мы поговорим в главе 6 &quot;Ride&quot;. Сейчас стоит отметить, что контракты пишутся на языке Ride, который был придуман специально для смарт-контрактов и является не Тьюринг-полным. В языке нет циклов, но зато нет газа, не бывает ошибок &quot;Out of gas&quot; как в Ethereum и стоимость транзакции всегда известна заранее. Заинтриговал? Это ведь только начало, мы поговорим про модель исполнения Ride и синтаксис языка позже.</p>
<h2 id="waves-ng">Waves NG</h2>
<p>Чуть раньше я уже <a href="./1-1-history-of-waves.md">затрагивал тему</a>, связанную с Waves NG и упоминал, что она позволяет транзакциям быстрее попадать в блоки и работать блокчейну так быстро, что платформа в состоянии обрабатывать сотни транзакций в секунду в основной сети. А там, на минуточку, больше 400 нод, распределенных по всему миру, на совершенно разном железе и с разной пропускной способностью.</p>
<p><img src="../../assets/1-3-2-nodes-on-the-map.png" alt="Waves nodes map" title="Waves nodes map"></p>
<h2 id="dex">DEX</h2>
<p>Легкий и быстрый выпуск токенов наряду с &quot;классовым равенством&quot; (помните, что токены являются гражданами первого сорта?) позволяют сделать торговлю токенами простой. Нода Waves (речь про версию на Scala) поддерживает возможность создания расширений, одним из таких расширений является матчер. Матчер принимает ордера на покупку и продажу токенов и хранит их (централизованно). Например, Alice хочет продать токен wBTC и купить Waves, а Bob наоборот. Они формируют ордера (криптографически подписанные примитивы) и отправляют их в матчер, который определяет, что эти ордера выставлены в одной паре и их можно сматчить по определенной цене. В результате матчер формирует Exchange транзакцию, которая содержит 2 ордера (один от Alice, другой от Bob) и отправляет в блокчейн. При этом, матчер забирает себе комиссию с пользователей, а нода, которая смайнит блок с Exchange транзаций, получает комиссию от матчера.</p>
<p><img src="../../assets/1-3-3-how-dex-works.png" alt="How does DEX work" title="How does DEX work"></p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-2-%D0%BD%D0%BE%D0%B4%D0%B0-waves-%D0%B8-%D0%BA%D0%B0%D0%BA-%D0%BE%D0%BD%D0%B0-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%B5%D0%B5-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F">Глава 2. Нода Waves и как она работает, ее конфигурация</h1>
<p>Непосредственное техническое знакомство с платформой Waves я бы рекомендовал начать с установки и настройки ноды. Не обязательно для основной сети, можно для testnet (полная копия по техническим возможностям) или stagenet (экспериментальная сеть). Почему я рекомендую начать с установки ноды? Во-первых, я сам свое знакомство с блокчейном Waves начинал именно с этого, а во-вторых, установка и настройка заставляют разобраться в том, какие есть настройки у ноды и какие параметры есть у сети.</p>
<h2 id="%D0%B8%D0%B7-%D1%87%D0%B5%D0%B3%D0%BE-%D1%81%D0%BE%D1%81%D1%82%D0%BE%D0%B8%D1%82-%D0%BD%D0%BE%D0%B4%D0%B0-waves">Из чего состоит нода Waves</h2>
<p>Как и почти во всех блокчейнах, нода - программный продукт, который отвечает за прием транзакций, создание новых блоков, синхронизацию данных между разными узлами и достижение консенсуса между ними. Каждый участник сети запускает свою копию ноды и синхронизируется с остальными. Про правила консенсуса мы поговорим чуть позже, сейчас давайте разберемся, что из себя представляет нода с точки зрения ПО.</p>
<p>По большому счету, нода это исполняемый файл (<code>jar</code> файл для Sсala версии и бинарный для Go), который в момент запуска читает конфигурационный файл, чтобы на основе этих параметров начать общаться с другими узлами в сети по протоколу поверх TCP. Получаемые и генерируемые данные нода складывает в LevelDB (key-value хранилище). По большому то счету все, но дьявол кроется в деталях. По мере углубления в особенности работы вы поймете, что это далеко не так просто, как может показаться. А пока, давайте поговорим о том, с чего нода начинает свою работу в момент запуска - конфигурационного файла.</p>
<h2 id="%D1%83%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D0%BD%D0%BE%D0%B4%D1%8B">Установка ноды</h2>
<p>В данной книге мы не будем разбирать процесс установки ноды, так как это много раз описано уже в разных источниках (документация, видео на youtube, посты на форуме). Нам никакой книги не хватит, если мы захотим окунуться в эту тему, потому что существует много способов запуска ноды:</p>
<ol>
<li>Запуск <code>jar</code> файла</li>
<li>Запуск Docker контейнера</li>
<li>Установка и запуск из <code>.deb</code> файла</li>
<li>Установка из <code>apt-</code> репозитория</li>
</ol>
<p>Лично я предпочитаю запуск Docker контейнера, так как это упрощает и поддержку, и настройку, и конфигурирвание. Другой причиной моей любви к Docker может быть то, что я делал Docker образ, размещенный в Docker Hub и отлично знаю как там что работает. Хотя вряд ли, это просто удобнее! <img class="emoji" alt="smiley" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAWaUlEQVR4Xu2bebAlV33fP79zum/fe9+99+3z3qyaGc0iCQ3LzEhIMpalICQKx0JYyEAkgTEJlAtX4qLKdhHsgBIndoWYONj8gR0gWAI5BoPAC7KQUyJG20gapAgxZvbhzfZm3r7crfuck+5TXdXFvEUjBymqsk/Vd86dmdPn/j7f/p2tXz9xzvGPuSj+UZd/MuCfDAh4mcs9Iuquu9gaOHaheI0I2wRGlZY+HFUAhKY1bsbBWec4jOWFRHj+vvs4+nHnLC9jeVkmQUnLsbu52gm3hpqbVShX6FBVVUmhSoIoAS0AhYzDWYftZrKY2DZt7H4QGx4Sxze33Ms+l5ZXtQHP3CrVwT5+QWl+qVRWP6UrSqmqRkUZuEOURbRLJSAXGOAczmQSnFXYrmA7Fts0mJa13bZ91Bo+PznDn+35pmu+quaAR26U4Ph75RdHhuXJakN/oWc0+ulofaSidQHRsKM0rCmNDlHe9nqiK28h2vNeytf8MpXr/o1X+tn/W/p/vk3aNrvGX+v7SPvK+sz6zr4j+67sO18VGXDwTrm6HPKfyjX95qA3IGhoJDKockDQtxE1+gbUyB6ktg0pD0BQBdEgAA4AEHCAM5A0ce0p3MJh7Pgz2LPfI5kZw7YTXEeTzBmS2YT2gvnbdsy/3fElt+//iwGSlqN38pFyVe4p9Yc9ui9M2SyqGhCM7EJfcjNq+GqoDORwCWAhNxwBHMt8FkCBBCBAawp7fh/mxEMk489jmwlJU2FmYrrT8WK76T6+9Ut8yqXllTDAgz99B43hCn9Yruu7wqESQa9GVwzBmh3obbej1lwDQRlcF5xBRPEPKc7ZPFtKkLSx557AHP5zknMHMS1NMmuIJ7q0581951v8yt6vMOeNeJkM8PD7b2XtwABfqvYGN4QjKXxdCGppfektqM23I1Ef2DYCSyc6uVhylk6QAKqM68xgj6cmHPkbkoUuybwjHu/SnE0emZrizt3f5MxLMSF4qfBDAzxQHgyvioYjdB2C/n6Cy9+DGvlpcDGSzILIamAvXQ4EIOmA1uhtdyL1TciB+xE1jVJlCDo3KOIH0hhvE5GLNiG4WPgHb6E/hb/fw49m8ELYP0jwmg8g/ZcjZhaQJWP7J1IKFMQBNFFrriYM68gLnwM9SaQjgKuGiO9PY32HiExfjAnBxcAD6rJRPl3uD66P1kTohkrh+wguvxvV2AzxNIgq4HnZDCgywrSQxmaCK+6GA18EmSGyEVh3/WUu+TTwPhGxL2ZCcDHwB+/iI5WGvjNcUyLo0wT1tN76s0htIyQzHh63DHBUgkBDqwPW8pKKUlCJIDHQ6S5vSNLOYvCxcPCrCF2sLVFJ3J0H7zLP7biPTxUmvKRJsIB/7A72bO6X/1VeX+4pDUcEDQg2vgm1/iYgARGE5eBDnt9/mB8eOs0/f+teyrWyh7moEmjaC23+8sGn2bl9Hbt2b4NOvMQEB+DZAuyph0nGvksyB93zHdqn2ovHp90/u+4rPAOsaEKwGvzdI5TX1/lkNBj2hP0hQU2h+0dRQ28Auwg4JKdHfhz+hf2H+K3f/AJTkx0OHjjEb3z03WgsWFYvCkyi+NR//VMe/NZzDAxG/Mfffj+vef3WHzfBgeA8P4iPSS8cBXsWl4S4tulZn3Q/mTK87d5x2kUmXNwQEEB97CbeVanp64MUXtdCVEWhBq8ErcA0EVl+qbOdDv/zyw/RCDpsujTk2Sef46lHL+ean7kCWl1WLaUST33neX/N69NrZxZ8X3zi8rtQ1oJbksJ4LB2gBnfhmufRiRD0GyqL5vqP3WTede+XuBdwwIsZUKT+R6+m0RPJr3v4eqqyoGpDSHUUzAIiDpwsTf1Qc/zQec786BSXDIdEocLE8MRjz3PNdZvBxeBWsT1OfNvhGqxpKHorYdZX2ucYW7cPQ2wAlmaCFaQ64mPU8XlsPfQm9CzYX//o1e4bv7OPWRFxWXmxDFCAfs82bo8aemfQCFCVVJFCautBHGKbK6/1UYnDh04S2A6NckQYCAP1gNNjZ2nNzFKpKjArOKAlbdPM2vprapEQacXEbMf3uXVnL5juSpMZTgIfo2pO+piz2KNGsvM925LbUwO+CDjALG9AcffljQNE9bJ8IGhoVE+ALiskipByL2JbgIUV+Iktp0+fpxIKoU6loFJSzC02GT83xebN9ZVXBK3SNvN0mk36epS/Fi1ZX75P4jbY7iqbpRiyGKMIHXewPf5wRn3OfOCNA+5Pn5zCSJ4GK2WAAPp3r2d3pSp7dS1AlTWqpJBSBVEBmBaIA1Y2YHZ6nigUtAIleCOcSZidmQNXAmNWmv2zNr5tqBVKvCdZX75Pb4BZZQ5xksXoY1Wl2MeeMVSq8d7fvd7tvvEBHgcssKIB3vORmro1rGn/MEOXNBIoCCIgWX0MA1hLu90m0IIIXkrhodutRaABNmb5Evo2GINSKr+erC/fJ7bIgJUlPlYJlI/dVDUZy0iNW8HuAwxgCwMumPy29hNWyu5G8U9yNBIqJBCUDsB2eNF1zBp/B5UIQu6qgADOxjlEsvK1Nkbya4D8s88gsK3CvBWlfKw2EB+7Z6hqKuXkxozt6DRJMQwguHDp+/getkZl2akrGilpVGaA1oDxBuBWMECKk1sUBTQdRXGgAkUYxBDPpUqKTCwwIQiyNr4tDii69H3iukUGrLiSKMD4mFXoPEPGkjF9fI/b+r6HOZCzLmuA3lhnVxCpin+OFwjoPA9dB2yTFTf8LpP17WoNmLQFg3UQhJpaeQoWZyC2yxAIWJW2sb6tdQWntfg+cfNgbA4JwNJYnPMxID52z5CxZEwb63YXcDCHYNkM6KuoK3QkSJhKK0SJFy6GZB5U+YL9qAEbg8tkQMOaYcth42PxSgyEkWKwX3mAFU9KxmZtfNvE2Px6iI3vE+Jx6AKiQUJQqUQXPJBnaZzHnTOEQsaUsYH9+koGqExR4C6VQOHhtYBSxZqfLIJ0QVQBnwlHEYBm44YII4KxDqWETtfSP1qmvxFAe5UxbPFt+odKtM42sRXt+zAivk8sxXfSBSMgujDBWQ8P5LOvZ/AsGVMUJJeScxYGUKz/gA6FNeSpL5LDowpG1y0ARJbeza5l2+YKPX0pRCdGRFhsO153RR0dAq1VjskO32ZH2vax44v01qDVcVlfvk+63R8fcuSGkFAUKSTWM6AFAsGzgfbI+USoLrgy1AF9ko97dDHii71DAY1jqRJHowa73zTAuemEyZmEoFHi2msb0IpBWLkIvk3a1l+TXuv7SPvyfZK45Xf0TnCuqFOuoonHFTKmjA0IV50DlFAWlYM7L8T/UZhQ0IKw1Bfm2tzylj4mZgxHfjDHO9+3gTU1C9MGRFi1xI41/Zbb/9UmvvrFk1x5XcP3xeQCCAV9URWflzkv56EjCjI2QC1nQLFkC3j/XOGA82OriD3vdeUnPwbKswt84P3DtNUo5fkWnFvM4d3qyyjAdJPdW3q44vd2ULYGTs2BsUUbdwG4W6aTIn7AMyEChQFeLrhgLVHG0saQQxucE8TpvFGRGYIDWQZHcnUNcmKSst8GO9AX95TM5QxMzFOeXsh/ZgioAhhZCu/jLDIij9PgZS0Y8GxFT27Zs0BimcsucCZJJeByM6RYZ5VyEAlY5+Vc4Ssur3EFTGHzcmVFZzy4AJqlk1++HRAtgGA7zpvgkMIVDx7nLJaMbbXnAQ6gkzDhHbOZewpnFYKlyBHH7ILlqccT1o0Il25WRI3cAAsY8KYASKF/0ENQDdjCH5RAkJsdw/wUHDhsiGPh6l0BWgvOFkY561KZnMV6NkCWHIZcWkTEAcx25cS62Pm09Q66BKzgFAiCKju+9rU2n/l8m9EBxaYNiu3bFVfsVGzZLN6UWg2kLKBzEilAsKtkgyyzsgqQCLbpmJ2BsVOOI0cdB/7ecPio5eRpy2IC/+3fV9n7uhDbLoYGzjPgEoeLnWcDR47slsuA5MScPbKzq7HGYa1FOZWP9yIdDbChoRiMHBM/Sjh+EP76r6DSA319MLpWs3ZU0hpG1giDg1BvCOVK8aA4LIHWgIM4gaSbykC7Da0mzM45Jifg7LhLBafPWMbPWubnoNuCioZGGTY1NBNNRywOlEGUgC224BmDZ+lCxgaYlY7DFkgePcPRN2+3bWJbdkbhhwOCKEAsAJdsgZ7IURvqY+ueG2m12kycPMTcxBTz8zOMP2fY9xQUx2EPTKUCpciDE+ZGOCCOIUllDLRb3gT/dzwAiEBUhkojYmB9L72jIwyt3YbqLDD+zCP0Bwlr1+Y703y9w4CzeSYnFtOx7YwNiAG7kgHxn7zAyY9cxZFyx73GJXkKofK1FB/RJZvBhQ4zuI4rf+6DlIIAl7RJ4i7NmTMsTE3SWphhdvwIi1Oz/izfac/TmZ9J6wUfVDu2JE0DCGGkUZFQ0pr6aINyT18K3EO5ElEfXkN9aAuVnlpajxLVBglKJSSoMHHqGIf2P8rQSMLwEGAcqAwYHOBjj52fIBdaHMnYVjPAAZ3FmHh8Tp4YzAzwTXMBCGBgwzphYKPi6InjzE+cZP2m7agopFQqEW3aSpjWQRCgtUJEobTCJV1M3MSktQCCFCdrBeBwgA4rXojGp6+zmMSQJAndTodOp0XcjUEFjI8d5FS2Z7g2pKcOdhaQIk5vRKaWI2NajD1RZ+kQKCbCGGg9PGa/u2Ojen/Qdsp08RMfThAFDqjW4bVXBTx73yJ/99Cfcdudv8rQ8AhBoFEC4gwKRagDb0QYhqnqlEpr0UHo2+nMIAGAxFiM8ZAkcUw37qaQXTx0Cuuwvs9AK1Slig4SThw9yKMPfxWlYe81CiygQBxYBxiHyeDbjqTtbMYEtIA4Y13pFRkLND/1FH8/Neu+b5oW17XY2IEFBDxhF274Gc26Yc2hfQ/xh//hQ9z/+d/j/+x/gsXFRaJyhWpPnUq1RikqEwQhWmuKE6RFUlEs+DhrvESEQOvMNH9tT62W9lUjCCOmJs/zxN99my/8wT388X/+FeZPHeGyywLe8FoFHRDvPmDAJg7XsZiWJWPJmIAmYFd7LG6B1lxM69nT7oGbh+1rXVtBFbA+TiQQ6Dp2bBOu/SnNs49CqzPG/oe/zOPf/jK9QxvYsPlyLrtyNxsv2cHmbTtZM7KOWi0zpJeoFHJhCYLAC2Cx2UpNXGBhYYFTY0c5cewIxw+/wMED3+PMiR/Smp+iFsDaOqiy5pa3BdSq4NoAAhYweep3HG7ekrFkTOC1ggHFMGgBcx/7Lt9540Z7fKDXblYVQVVASgq0AxHoOG57V8CpH1h6gpCdQzAXW6aaJzn7wkkOPfNtDBBWqvTUB+kbGGZgzTr6B0YolatUUkWlEs5lBrbotFu0mvNMT5xh8vwZZqcnaC1MknRiIgWNClxSg4HBFFgL8aKjsll481sULDrwW25SCT5rWxYzb9N+7PGMBZgDWhfzg5EEmD8yy/zjY+5P3tpn/53uUdgKqAgIBTTQxm98bnxnyL6vxGzoUyit6VpFy8Bi4liMHc24RbM7Rmt8jB+N7edwAsbm4zSTeKEBrSEKoFKCDamqo0JPqFMpqgFUNIQidDqOMzG845dCqiHgBEHACi5/7moWHGbGkjFkLOCVLL8VXpoFC8DML/8t33lird2/tm52S9VnASpUoAUJgVnHLW/XnD1hmf6+Yf2wohQITsBYIXaOxCq6lrSG2Hl4/OrqKHbXgJZ8p6u8x4TKf6aU1SJo8dfQ7sLZSceb7gi5cpfAOQciuAw+gXzck8waxifs/owBmAEWXsoPRzvAzGyb3s8+6z7zGw3zGamoskRCGFiUVhCAWCHoWO74cMi9n4RzpyzrhhVR6IEQkeJUCljnLjil5pJifhUyCSLgRfFccbHjOD3t2PmWgJvfoWHCgCh8fwZs2/qhkcxa2lOmncWeMswBMzkTL25AkQVzwOTvP82RGzbK566vmA/rSLChQgILgaQCaUGj1/KeXyvx1T+IOXXMsnZYqOQ7Pa1ACtJVXvsQYOl53+QPRRe6KfyUY9tNAW9/b4CaMmBU/hgQXNtiU3ibwptJw5PH5HO//7Q7AkwCcxf/fkChLjAFVG/7uv3GU3XZvi1MbiYMQBRKCSoARJB5RzpZcmdqwl/fG3PiyYSRXqFeE0qSmyAXosqKh0DncngLnZhsGWMmdlz17hI3vFUhEwY6+aTXBdsCO++IZyzd8wlHxuxDt33dfQOYyBm6AKsasMpcMAVU7v5L90cP3G7XjGjzevIxKlohCE5AZqGnx/DOD4Y8faVm3zdjZs87BnuhWhHvm1KgAN9+OXgHNr/r3QQWFh1TKVh9s+a2O0K2bQXOWegKLgZfNx12zhJPpzpnsmH4bBYrMO3hlx37hfQnPvEJVirp/7l77rnHAEy00M+e5/s3jborKophAkEE8DAKEIhBWo71OxQ7rguII+H0acfMtKMbCw6wgPMSbCHi/G4vtv0dZ6oJekSx5+0lbv6FkOGK9fAuFjx4W7BNm8I7PPx4Bm8O/Mtvud/ZP84p4AwwlbJ3/59flBSROjACrH/TRtZ99hb5tXWb1BvC0QDdqwjqgvQoJAIJHRIAPcCAZqElHD5gOfqcYXrM0p13kBTDorjroCKI+hQjWxVbX6fZuk0oWQuTFjr5JjIRXAtc05LMO8ysJT6bcHrMfu9DD7r/8t2TnAROA+Mp2/xP7E1REekH1gCj23sZuv82+eDWTermcFij+1VugqDKApHkr8UDVaChIFI02zA97ZibhsUZR9x1AERVod4vNHqF/gEoBQ4WLcw6PLj14NB12LbDLTiSfJ2PzxsO/8h++1/8hfvvh6c4C17nU65pgJ+kAQL0A8N5NjT+/OfV26671L2/MqjLwaBGNwRdU0gZJBKkBBKACKDxxlABQoFAipOIARLnAWllNWBy8Kzu5tvaFphFi5lzJFOG1qRpP3ZEvnD71+y3gBlgPIMHZlxaXo53hRXQCwzlRgz86z1s+dAe+cW1o2q3HlAEfQqVZUJFpQIJMwloEA/tQFY4hjnAb2jyM33sPLxt47e2Nl/jzZTlzFm7/7PPuP/x6Wc4Ckzl4JPAbMpkX9a3xYE6MJirv6Kpf+atXHfDFvn5viG1RfcqdF2hqoJUBF0CSuLNQIOoYtcD5OAOH7bJwIGOw3T9WR7bdJgF68f7zIQ99sgx97UPP8hjLcM8MO3BvZh3aXmlfl+glmdDP9AHNNbXqP32Dey9dqPcMtgvu4KakswEXVXFkPDZgJdSAGBzcFye6nnKm6b18MmCdZNT7vnHT7q/+c1HePrUAguQ7/BgOr/rC6/4b4yISJRnQyM3oQ7UgOBX97LlZ7ervVv63d5anc2liopUJBAKEoAKfjwD/Pk9AfJHWN2W7SzMc/zYtDz9V4fs0+mO9BiQgIefz+Hn8rveAXjFDSjmBSoevlAV6AEiDerndrDm+o2s3zmoNg5V3bpqyEAUUAs1EUBs6HQSFpoxUxNNOf3DSTv2v8c49RcHOWfAAh1gEWh6+EKtYry/0gYsNSLIjejJVc2NKQOlXDqXLWoAFGCK2qubqw20cvjFTDl48ur7vcHCiAgo56p4+EIaUHlNIQxgC/hcHp52rs4S8FeVAUtXi/ACBb4uDChmgcKAGEh8TSFXBMqr24DV5woNKK/lz0M2l/Fj+xUo/xd+DYsy448VUQAAAABJRU5ErkJggg==" /></p>
<h2 id="%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D0%BD%D0%BE%D0%B4%D1%8B">Конфигурация ноды</h2>
<p>Конфигурационный файл ноды Waves описан в формате <a href="https://github.com/lightbend/config/blob/master/HOCON.md">HOCON</a> (это как JSON, только с комментариями, возможностью композиции нескольких файлов и, что не менее важно, с меньшим количеством кавычек). Полный файл с конфигурацией выглядит громоздко, но я все-таки приведу его здесь, версия на момент написания этих строк (файл постоянно меняется, но актульную версию можно найти в <a href="https://github.com/wavesplatform/Waves/blob/master/node/src/main/resources/application.conf">репозитории Waves на Github</a>).</p>
<p>Файл содержит большое количество комментариев, поясняющих каждый параметр, поэтому подробно разбирать все параметры мы не будем. Поговорим только об основных моментах.
В конфигурации содержатся следующие разделы:</p>
<ul>
<li>waves</li>
<li>kamon</li>
<li>metrics</li>
<li>akka</li>
</ul>
<p>Последние 3 раздела являются служебными, которые отвечают за параметры логгирования, отправку метрик и фреймворка akka. Нас интересует только первый раздел, который касается непосредственно протокола и содержит на первом уровне следующие подразделы:</p>
<ul>
<li><strong>db</strong> - параметры для работы с LevelDB и настройки какие данные сохранять. Например, результаты некоторых транзакций можно сжимать (экономить до 10 ГБ), но это вредит удобству работу с API. Поэтому будьте осторожны с тем, что включать, а что выключать и экономить место на диске.</li>
<li><strong>network</strong> - параметры общения с другими нодами в сети. В этом разделе много важных параметров, которые мы разберем чуть ниже.</li>
<li><strong>wallet</strong> - параметры файла для сохранения ключей. Каждая нода, которая хочет генерировать блоки (чтобы получать за них вознаграждение), должна подписывать свои блоки. Для этого у ноды должен быть доступ к ключу аккаунта. В этой секции задается приватный ключ (а если быть точнее, то seed фраза в кодировке <a href="https://en.wikipedia.org/wiki/Base58">base58</a>), пароль для того, чтобы эту фразу зашифровать, и путь, по которому хранить файл с этим зашифрованным ключом.</li>
<li><strong>blockchain</strong> - параметры блокчейна, в котором будет работать нода. В данном разделе есть настройка <code>type</code>, которая позволяет задать одну из заранее определенных типов блокчейнов (stagenet, testnet или mainnet). При указании значения <code>custom</code> можно менять все параметры блокчейна, в том числе первоначальное количество токенов, их распределение, байт сети (уникальный идентификатор каждой сети), поддерживаемую функциональность и т.д.</li>
<li><strong>miner</strong> - параметры генерации новых блоков. По умолчанию, генерация включена (надо понимать, что это будет работать только при наличии генерирующего баланса больше 1000 Waves на аккаунте), но ее можно отключить с помощью параметра <code>enable</code>. Может пригодиться, если, например, нужна нода, которая будет только валидировать блоки, но не генерировать их. Другой полезный параметр - <code>quorum</code>, который определяет сколько соединений с другими нодами необходимо, чтобы нода пыталась генерировать блоки. Если задать данный параметр, равный 0, то можно запустить блокчейн, состоящий из 1 узла. Зачем вам такой блокчейн, если этот один узел может переписывать всю историю и делать все, что захочет? Для тестирования! Идеальная песочница для игр с блокчейном.</li>
<li><strong>rest-api</strong> - в ноде есть встроенный REST API, который по умолчанию отключен, но после включения (за это отвечает параметр <code>enable</code>) позволяет делать HTTP запросы для получения данных из блокчейна или записи в нее новых транзакций. В данном API есть как открытые для всех методы, так и те, которые требуют API ключ, который задается в этой же секции настроек. Параметр <code>port</code> задает на каком порту будет слушать нода входящие HTTP запросы, на этом же порту будет доступен Swagger UI с описанием всех методов API. <code>api-key-hash</code> позволяет указать хэш от API-ключа, с которым будут доступны приватные методы. То есть в конфигурационном файле мы указываем не сам ключ, а хэш от него. А какой хэш надо взять? SHA-1? SHA-512? Или, прости господи, MD5? Ничто из перечисленного, потому что в Waves используется <code>secure hash</code>, который является последовательным вычислением хешей <code>Blake2b256</code> и <code>Keccak256</code> - <code>keccak256(blake2b256(data))</code>. В REST API есть метод <a href="https://docs.wavesprotocol.org/en/waves-node/node-api/utils"><code>/utils/hash/secure</code></a>, который позволяет передать значение и получить готовый хэш.</li>
<li><strong>synchronization</strong> - параметры синхронизации в сети, в том числе максимальная длина форка и параметр <code>max-rollback</code>, который задает сколько блоков может быть откачено и по умолчанию равно 100. Фактически можно сказать, что время финализации транзакции, после которого точно можно быть уверенным, что транзакция не пропадет из сети, составляет 100 минут (среднее время блока составляет 1 минуту).</li>
<li><strong>utx</strong> задает параметры пула неподтвержденных транзакций. Каждая нода настраивает эти параметры в зависимости от объема доступной оперативной памяти, мощности и количества CPU. Параметр <code>max-size</code>, задающий максимальное количество транзакций в списке ожидания, составляет 100 000 по умолчанию, а <code>max-bytes-size</code> имеет значение <code>52428800</code>. При достижении любого из этих лимитов, нода перестанет принимать транзакции в свой список ожидания. Про UTX мы поговорим отдельно в главе 5 &quot;Транзакции&quot;.</li>
<li><strong>features</strong> - каждый новый функционал и изменения консенсуса (именно правил консенсуса, не изменения API или внутренностей ноды!) должны проходить через процедуру голосования. Принцип работы голосования мы разберем позже в этом разделе. Сейчас просто скажем, что каждая нода голосует используя массив <code>supported</code> в этой части конфигурации. Так же нода может автоматически выключиться, если вся сеть приняла какое-то обновление, которое не поддерживается этой версией, используя флаг <code>auto-shutdown-on-unsupported-feature</code>.</li>
<li><strong>rewards</strong> позволяет установить размер вознаграждения для майнера блока. Как и в случае с обновлениями протокола, проводится голосование, но голосование за размер вознаграждения работает по другому принципу.</li>
<li><strong>extensions</strong> описывает какие расширения вместе с этой нодой необходимо запускать.</li>
</ul>
<p>В разделе <code>waves</code> на первом уровне так же лежат некоторые параметры:</p>
<ul>
<li><code>directory</code> - путь к директории, в которой нода будет сохранять все файлы, которые относятся к ней, к том числе файлы LevelDB с данными</li>
<li><code>ntp-server</code> - сервер синхронизации времени</li>
<li><code>extensions-shutdown-timeout</code> - это время, которое дается расширенниям, подключенным к ноде, корректно завершиться при выключении самой ноды</li>
</ul>
<p><strong>В следующим разделах мы будем подробнее разбирать какие параметры влияют на поведение ноды и каким образом.</strong></p>
<h2 id="%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8">Особенности конфигурации</h2>
<p>Вы уже увидели, что конфигурация ноды осуществляется с помощью HOCON файлов, которые поддерживают возможность композиции. Другими словами, в файле конфигурации можно использовать инструкции <code>include filename.conf</code>, который может загружать разные разделы конфигурации из другого файла. Некоторые разделы могут повторяться в разных файлах, поэтому там так же есть механизм разрешения конфликтов (чем ниже подключен файл, тем больший приоритет он имеет). Если у вас есть опыт работы с CSS, то принцип такой же. В некоторых местах документации Waves приводится нотация вроде <code>waves.network.port</code>, как нетрудно догадаться, это обозначает параметр в конфигурации вместе с путем:</p>
<pre class="hljs"><code><div>waves {
  network {
    port = 6868
  }
}
</div></code></pre>
<h3 id="%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C">Безопасность</h3>
<p>При конфигурировании ноды имеет значение уделить особое внимание тем параметрам, которые напрямую влияют на безопасность - разделам <code>wallet</code> и <code>rest-api</code>. Хорошей практикой считается указать в конфигурационном файле base58 представление seed фразы и пароль, запустить ноду, а затем удалить фразу из файла (не перезапуская ноду). Таким образом, запущенная нода будет знать приватный ключ и пароль (это есть в оперативной памяти), но в файле конфигурации ничего не останется. Если вдруг кто-то получит доступ к вашей конфигурации или даже <code>wallet</code> файлу, он не сможет расшифровать ключ.</p>
<p>API ключ ноды не менее важен, потому что он позволяет отправить с ноды транзакции, подписанные ключами, хранящимися в ноде. В отличие от данных аккаунта, в конфигурации хранится только хэш, поэтому удалять оттуда после запуска смысла нет, но есть смысл использовать максимально сложный ключ и никак не тот, который стоит по умолчанию (в старых версиях был ключ по-умолчанию, в последних такого уже нет).</p>
<h3 id="%D0%BE%D0%BF%D1%82%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD%D0%B0">Оптимальные настройки блокчейна</h3>
<p>Очень часто задаваемый вопрос - какие же настройки оптимальные? В первую очередь зависит от того, о какой сети мы говорим - <code>stagenet</code>, <code>testnet</code>, <code>mainnet</code> или <code>custom</code>? Например, для <code>custom</code> не существует оптимальных, так как различаются требования к сети. Но надо понимать, что нода Waves не всемогущая, эмпирически показано, что при времени блока меньше 12 секунд (<code>waves.blockchain.genesis.average-block-delay</code>), времени микроблока меньше 3 секунд (<code>waves.miner.micro-block-interval</code>) и относительно большом количестве узлов в сети (10+), сеть может быстро разделяться на несколько. Такое поведение вызвано задержками в передаче сетевых сообщений.</p>
<p>Важным параметром, который надо настраивать с учетом особенностей окружения, является максимальное количество транзакций в UTX. 100 000 транзаций является оптимальным для ноды, удовлетворяющей минимальным системным требованиям.</p>
<p>Я описал выше только самые основные параметры, многие другие мы будем рассматривать в следующих разделах, по мере погружения в протокол и его особенности. Сейчас же приведу полный файл конфигурации с комментариями:</p>
<pre class="hljs"><code><div># Waves node settings in HOCON
# HOCON specification: https://github.com/lightbend/config/blob/master/HOCON.md
waves {
  # Node base directory
  directory = &quot;&quot;

  db {
    directory = ${waves.directory}&quot;/data&quot;
    store-transactions-by-address = true
    store-invoke-script-results = true
    # Limits the size of caches which are used during block validation. Lower values slightly decrease memory consummption,
    # while higher values might increase node performance. Setting ghis value to 0 disables caching alltogether.
    max-cache-size = 100000

    max-rollback-depth = 2000
    remember-blocks = 3h
  }

  # NTP server
  ntp-server = &quot;pool.ntp.org&quot;

  # P2P Network settings
  network {
    # Peers and blacklist storage file
    file = ${waves.directory}&quot;/peers.dat&quot;

    # String with IP address and port to send as external address during handshake. Could be set automatically if UPnP
    # is enabled.
    #
    # If `declared-address` is set, which is the common scenario for nodes running in the cloud, the node will just
    # listen to incoming connections on `bind-address:port` and broadcast its `declared-address` to its peers. UPnP
    # is supposed to be disabled in this scenario.
    #
    # If declared address is not set and UPnP is not enabled, the node will not listen to incoming connections at all.
    #
    # If declared address is not set and UPnP is enabled, the node will attempt to connect to an IGD, retrieve its
    # external IP address and configure the gateway to allow traffic through. If the node succeeds, the IGD's external
    # IP address becomes the node's declared address.
    #
    # In some cases, you may both set `decalred-address` and enable UPnP (e.g. when IGD can't reliably determine its
    # external IP address). In such cases the node will attempt to configure an IGD to pass traffic from external port
    # to `bind-address:port`. Please note, however, that this setup is not recommended.
    # declared-address = &quot;1.2.3.4:6863&quot;

    # Network address
    bind-address = &quot;0.0.0.0&quot;

    # Port number
    port = 6863

    # Node name to send during handshake. Comment this string out to set random node name.
    # node-name = &quot;default-node-name&quot;

    # Node nonce to send during handshake. Should be different if few nodes runs on the same external IP address. Comment this out to set random nonce.
    # nonce = 0

    # List of IP addresses of well known nodes.
    known-peers = [&quot;52.30.47.67:6863&quot;, &quot;52.28.66.217:6863&quot;, &quot;52.77.111.219:6863&quot;, &quot;52.51.92.182:6863&quot;]

    # How long the information about peer stays in database after the last communication with it
    peers-data-residence-time = 1d

    # How long peer stays in blacklist after getting in it
    black-list-residence-time = 15m

    # Breaks a connection if there is no message from the peer during this timeout
    break-idle-connections-timeout = 5m

    # How many network inbound network connections can be made
    max-inbound-connections = 30

    # Number of outbound network connections
    max-outbound-connections = 30

    # Number of connections from single host
    max-single-host-connections = 3

    # Timeout on network communication with other peers
    connection-timeout = 30s

    # Size of circular buffer to store unverified (not properly handshaked) peers
    max-unverified-peers = 100

    # If yes the node requests peers and sends known peers
    enable-peers-exchange = yes

    # If yes the node can blacklist others
    enable-blacklisting = yes

    # How often connected peers list should be broadcasted
    peers-broadcast-interval = 2m

    # When accepting connection from remote peer, this node will wait for handshake for no longer than this value. If
    # remote peer fails to send handshake within this interval, it gets blacklisted. Likewise, when connecting to a
    # remote peer, this node will wait for handshake response for no longer than this value. If remote peer does not
    # respond in a timely manner, it gets blacklisted.
    handshake-timeout = 30s

    suspension-residence-time = 1m

    # When a new treansaction comes from the network, we cache it and doesn't push this transaction again when it comes
    # from another peer.
    # This setting setups a timeout to remove an expired transaction in the elimination cache.
    received-txs-cache-timeout = 3m

    upnp {
      # Enable UPnP tunnel creation only if you router/gateway supports it. Useful if your node is runnin in home
      # network. Completely useless if you node is in cloud.
      enable = no

      # UPnP timeouts
      gateway-timeout = 7s
      discover-timeout = 3s
    }

    # Logs incoming and outgoing messages
    traffic-logger {
      # Codes of transmitted messages to ignore. See MessageSpec.messageCode
      ignore-tx-messages = [23, 25] # BlockMessageSpec, TransactionMessageSpec

      # Codes of received messages to ignore. See MessageSpec.messageCode
      ignore-rx-messages = [25] # TransactionMessageSpec
    }
  }

  # Wallet settings
  wallet {
    # Path to wallet file
    file = ${waves.directory}&quot;/wallet/wallet.dat&quot;

    # Password to protect wallet file
    # password = &quot;some string as password&quot;

    # The base seed, not an account one!
    # By default, the node will attempt to generate a new seed. To use a specific seed, uncomment the following line and
    # specify your base58-encoded seed.
    # seed = &quot;BASE58SEED&quot;
  }

  # Blockchain settings
  blockchain {
    # Blockchain type. Could be TESTNET | MAINNET | CUSTOM. Default value is TESTNET.
    type = TESTNET

    # 'custom' section present only if CUSTOM blockchain type is set. It's impossible to overwrite predefined 'testnet' and 'mainnet' configurations.
    #    custom {
    #      # Address feature character. Used to prevent mixing up addresses from different networks.
    #      address-scheme-character = &quot;C&quot;
    #
    #      # Timestamps/heights of activation/deactivation of different functions.
    #      functionality {
    #
    #        # Blocks period for feature checking and activation
    #        feature-check-blocks-period = 10000
    #
    #        # Blocks required to accept feature
    #        blocks-for-feature-activation = 9000
    #
    #        reset-effective-balances-at-height = 0
    #        generation-balance-depth-from-50-to-1000-after-height = 0
    #        block-version-3-after-height = 0
    #        max-transaction-time-back-offset = 120m
    #        max-transaction-time-forward-offset = 90m
    #        pre-activated-features {
    #          1 = 100
    #          2 = 200
    #        }
    #        lease-expiration = 1000000
    #      }
    #      # Block rewards settings
    #      rewards {
    #        term = 100000
    #        initial = 600000000
    #        min-increment = 50000000
    #        voting-interval = 10000
    #      }
    #      # List of genesis transactions
    #      genesis {
    #        # Timestamp of genesis block and transactions in it
    #        timestamp = 1460678400000
    #
    #        # Genesis block signature
    #        signature = &quot;BASE58BLOCKSIGNATURE&quot;
    #
    #        # Initial balance in smallest units
    #        initial-balance = 100000000000000
    #
    #        # Initial base target
    #        initial-base-target =153722867
    #
    #        # Average delay between blocks
    #        average-block-delay = 60s
    #
    #        # List of genesis transactions
    #        transactions = [
    #          {recipient = &quot;BASE58ADDRESS1&quot;, amount = 50000000000000},
    #          {recipient = &quot;BASE58ADDRESS2&quot;, amount = 50000000000000}
    #        ]
    #      }
    #    }
  }

  # New blocks generator settings
  miner {
    # Enable/disable block generation
    enable = yes

    # Required number of connections (both incoming and outgoing) to attempt block generation. Setting this value to 0
    # enables &quot;off-line generation&quot;.
    quorum = 1

    # Enable block generation only in the last block is not older the given period of time
    interval-after-last-block-then-generation-is-allowed = 1d

    # Mining attempts delay, if no quorum available
    no-quorum-mining-delay = 5s

    # Interval between microblocks
    micro-block-interval = 5s

    # Max amount of transactions in key block
    max-transactions-in-key-block = 0

    # Max amount of transactions in micro block
    max-transactions-in-micro-block = 255

    # Miner references the best microblock which is at least this age
    min-micro-block-age = 4s

    # Minimal block generation offset
    minimal-block-generation-offset = 0

    # Max packUnconfirmed time
    max-pack-time = ${waves.miner.micro-block-interval}
  }

  # Node's REST API settings
  rest-api {
    # Enable/disable REST API
    enable = yes

    # Network address to bind to
    bind-address = &quot;127.0.0.1&quot;

    # Port to listen to REST API requests
    port = 6869

    # Hash of API key string
    api-key-hash = &quot;&quot;

    # Enable/disable CORS support
    cors = yes

    # Enable/disable X-API-Key from different host
    api-key-different-host = no

    # Max number of transactions
    # returned by /transactions/address/{address}/limit/{limit}
    transactions-by-address-limit = 1000
    distribution-address-limit = 1000
  }

  # Nodes synchronization settings
  synchronization {

    # How many blocks could be rolled back if fork is detected. If fork is longer than this rollback is impossible.
    max-rollback = 100

    # Max length of requested extension signatures
    max-chain-length = 101

    # Timeout to receive all requested blocks
    synchronization-timeout = 60s

    # Time to live for broadcasted score
    score-ttl = 90s

    # Max baseTarget value. Stop node when baseTraget greater than this param. No limit if it is not defined.
    # max-base-target = 200

    # Settings for invalid blocks cache
    invalid-blocks-storage {
      # Maximum elements in cache
      max-size = 30000

      # Time to store invalid blocks and blacklist their owners in advance
      timeout = 5m
    }

    # History replier caching settings
    history-replier {
      # Max microblocks to cache
      max-micro-block-cache-size = 50

      # Max blocks to cache
      max-block-cache-size = 20
    }

    # Utx synchronizer caching settings
    utx-synchronizer {
      # Max microblocks to cache
      network-tx-cache-size = 1000000

      # Max scheduler threads
      max-threads = 8

      # Max pending queue size
      max-queue-size = 5000

      # Send transaction to peers on broadcast request even if it's already in utx-pool
      allow-tx-rebroadcasting = yes
    }

    # MicroBlock synchronizer settings
    micro-block-synchronizer {
      # How much time to wait before a new request of a microblock will be done
      wait-response-timeout = 2s

      # How much time to remember processed microblock signatures
      processed-micro-blocks-cache-timeout = 3m

      # How much time to remember microblocks and their nodes to prevent same processing
      inv-cache-timeout = 45s
    }
  }

  # Unconfirmed transactions pool settings
  utx {
    # Pool size
    max-size = 100000
    # Pool size in bytes
    max-bytes-size = 52428800 // 50 MB
    # Pool size for scripted transactions
    max-scripted-size = 5000
    # Blacklist transactions from these addresses (Base58 strings)
    blacklist-sender-addresses = []
    # Allow transfer transactions from the blacklisted addresses to these recipients (Base58 strings)
    allow-blacklisted-transfer-to = []
    # Allow transactions from smart accounts
    allow-transactions-from-smart-accounts = true
    # Allow skipping checks with highest fee
    allow-skip-checks = true
  }

  features {
    auto-shutdown-on-unsupported-feature = yes
    supported = []
  }

  rewards {
    # desired = 0
  }

  extensions = [
    # com.wavesplatform.matcher.Matcher
    # com.wavesplatform.api.grpc.GRPCServerExtension
  ]

  # How much time to wait for extensions' shutdown
  extensions-shutdown-timeout = 5 minutes
}

# Performance metrics
kamon {
  # Set to &quot;yes&quot;, if you want to report metrics
  enable = no

  # A node identification
  environment {
    service = &quot;waves-node&quot;

    # An unique id of your node to distinguish it from others
    # host = &quot;&quot;
  }

  metric {
    # An interval within metrics are aggregated. After it, them will be sent to the server
    tick-interval = 10 seconds

    instrument-factory.default-settings.histogram {
      lowest-discernible-value = 100000 # 100 microseconds
      highest-trackable-value = 2000000000000 # 200 seconds
      significant-value-digits = 0
    }
  }

  # Reporter settings
  influxdb {
    hostname = &quot;127.0.0.1&quot;
    port = 8086
    database = &quot;mydb&quot;

    # authentication {
    #   user = &quot;&quot;
    #   password = &quot;&quot;
    # }
  }
}

# Non-aggregated data (information about blocks, transactions, ...)
metrics {
  enable = no
  node-id = -1 # ${kamon.environment.host}

  influx-db {
    uri = &quot;http://&quot;${kamon.influxdb.hostname}&quot;:&quot;${kamon.influxdb.port}
    db = ${kamon.influxdb.database}

    # username = ${kamon.influxdb.authentication.user}
    # password = ${kamon.influxdb.authentication.password}

    batch-actions = 100
    batch-flash-duration = 5s
  }
}

# WARNING: No user-configurable settings below this line.

akka {
  loglevel = &quot;INFO&quot;
  loggers = [&quot;akka.event.slf4j.Slf4jLogger&quot;]
  logging-filter = &quot;akka.event.slf4j.Slf4jLoggingFilter&quot;
  log-dead-letters-during-shutdown = false

  http.server {
    max-connections = 128
    request-timeout = 20s
    parsing {
      max-method-length = 64
      max-content-length = 1m
    }
  }

  io.tcp {
    direct-buffer-size = 1536 KiB
    trace-logging = off
  }
}

include &quot;deprecated-settings.conf&quot;
</div></code></pre>
<h1 id="%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%BC%D0%B0%D0%B9%D0%BD%D0%B8%D0%BD%D0%B3%D0%B0-waves-ng">Процесс майнинга (Waves NG)</h1>
<p>Процесс майнинга является ключевым для ноды, в конце концов ее основная задача в том, чтобы производить блоки с транзакциями. Чтобы это эффективно делать, нода также должна получать информацию о блоках от других нод и отправлять им свои блоки. Давайте рассмотрим упрощенную модель майнинга в Waves. Более подробная информация о процессе майнинга, включая формулы, есть в статье <a href="https://forum.wavesplatform.com/uploads/default/original/1X/b9f220c13f73c3a41dff7f4523c6c4a1fc03ebf6.pdf">Fair Proof of Stake</a>.</p>
<h2 id="proof-of-stake">Proof of Stake</h2>
<p>В основе майнинга лежит алгоритм Proof-of-Stake, который подразумевает, что вероятность сгенерировать блок каким-либо аккаунтом прямо пропорциональна балансу этого аккаунта. Давайте рассмотрим простейший случай: допустим, у нас есть аккаунт с балансом 10 млн Waves (из 100 млн выпущенных в момент создания). Вероятность смайнить блок будет 10%, иными словами мы будем генерировать примерно 144 блока в сутки (1440 всего блоков за сутки в среднем появляется в сети).</p>
<p>Теперь немного усложним. Хоть и выпущено всего 100 миллионов токенов, не все из них участвуют в майнинге (например, токены могут быть на бирже, а не на аккаунте ноды). Если в майнинге участвует 50 миллионов, то нода с балансом в 10 млн уже будет генерировать 288 блоков в сутки. Но на самом деле количество токенов, которые участвуют в майнинге, постоянно меняется, поэтому прямо предсказать, сколько будет смайнено блоков, не получится.</p>
<p>Вопрос, который возник у самых любопытных - <em>в каком порядке ноды будут генерировать блоки?</em>. Для ответа на этот вопрос потребуется углубиться в особенности реализации PoS в Waves, поэтому пристегнитесь и взбодритесь.</p>
<p>Можно сказать, что для ответа на вопрос &quot;Кто будет следующим генератороом блока?&quot; ноды используют информацию о балансах, времени между блоками и генератор псевдо-случайных чисел. Начнем с последнего, использовать <code>urandom</code> в данном случае не получится, так как он недетерминированный, и каждая нода получит свой результат. Поэтому ноды &quot;договариваются&quot; о рандоме. Каждый блок в цепочке содержит наряду с транзакциями, адресом ноды, сгенерировавшей блок, версией и времеменем, поле, называемое <code>generation-signature</code>. Взгляните, как выглядит блок номер 1908853 в мейннете в JSON представлении (без транзакций):</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"blocksize"</span>: <span class="hljs-number">22520</span>,
  <span class="hljs-attr">"reward"</span>: <span class="hljs-number">600000000</span>,
  <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"2kCWg8HMhLPXGDi94Y6dm9NRx4aXjXpVmYAE4y4KaPzgt1Z5EX9mevfWoiBLLr1cc1TZhTSqpozUJJZ3BpA5j3oc"</span>,
  <span class="hljs-attr">"generator"</span>: <span class="hljs-string">"3PEFQiFMLm1gTVjPdfCErG8mTHRcH2ATaWa"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">"reference"</span>: <span class="hljs-string">"3Jcr6m6SM3hZ1bu6xXBmAVhA2VEUHMvE6omhEiRFn3VhEuDkgb6sgeJUC1VNRB3vTSwPb5qh576a8DwGt3Ts72Tx"</span>,
  <span class="hljs-attr">"features"</span>: [],
  <span class="hljs-attr">"totalFee"</span>: <span class="hljs-number">28800000</span>,
  <span class="hljs-attr">"nxt-consensus"</span>: {
    <span class="hljs-attr">"base-target"</span>: <span class="hljs-number">74</span>,
    <span class="hljs-attr">"generation-signature"</span>: <span class="hljs-string">"6cVJBZsjzuSqp7LPD3ZSw5V1BZ25hZQHioh9gHjWPKNq"</span>
  },
  <span class="hljs-attr">"desiredReward"</span>: <span class="hljs-number">600000000</span>,
  <span class="hljs-attr">"transactionCount"</span>: <span class="hljs-number">70</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1580458301503</span>,
  <span class="hljs-attr">"height"</span>: <span class="hljs-number">1908853</span>
}
</div></code></pre>
<p>Обратите внимание: для удобства структуры данных в этой книге представлены в формате JSON, но сами ноды работают с блоками, транзакциями, подписями и т.д. в бинарном формате. Для этого есть описания бинарных структур данных в документации, а с недавнего времени бинарный формат данных представляет из себя Protobuf.</p>
<p>Generation signature является SHA256 хэшом от <code>generation-signature</code> предыдущего блока и публичного ключа генератора этого блока. Первые 8 байт хэша <code>generting-signature</code> конвертируются в число и используется как некий рандом, называемый <code>hit</code>. Значение <code>base-target</code> отвечает за среднее время между блоками и пересчитывается во время генерации каждого блока. Если бы в сети постоянно были все ноды со всем стейком сети, готовые сгенерировать блок, то <code>base-target</code> не был бы нужен, но коль это не так, нужен синтетический параметр, который меняется в зависимости от текущего времени между блоками и автоматически выравнивать среднее время между блоками в 60 секунд.</p>
<p>Итак, у нас есть параметры <code>hit</code>, который является псевдо-случайным числом, баланс каждого аккаунта и значение <code>base-target</code>, но что делать ноде со всем этим? Каждая нода, в момент получения нового блока по сети, запускает функцию проверки, когда будет ее очередь генерировать блок.</p>
<pre><code>Δt = f(hit, balance, baseTarget)
</code></pre>
<p>В результате выполнения этой функции, нода получает число секунд до момента, когда наступит ее время генерировать блок. Фактически, после этого нода устанавливает таймер, при наступлении которого начнет генерировать блок. Если она получит следующий блок до наступления таймера, то операция будет выполнена заново и таймер будет переставлен на новое значение <code>Δt</code>.</p>
<p>Валидация блоков происходит таким же образом, за одним исключением, что в формулу подставляется баланс не этой ноды, а сгенерировавшей блок.</p>
<h2 id="waves-ng">Waves NG</h2>
<p>Если вы вообще что-то знаете про Waves, то могли слышать про Waves NG, который делает блокчейн Waves быстрым и отзывчивым. Waves-NG получил свое названия от статьи <a href="https://www.usenix.org/system/files/conference/nsdi16/nsdi16-paper-eyal.pdf">Bitcoin-NG: A Scalable Blockchain Protocol</a>, которая была опубликована в 2016 году и предлагала способ масштабирования сети Bitcoin за счет изменения протокола генерации блоков. NG в названии расшифровывается как Next Generation, и действительно предложение помогло бы сети Bitcoin выйти на новый уровень по пропускной способности, но эта инициатива так никогда и не была реализована в Bitcoin. Зато была воплощена в протоколе Waves в конце 2017 года. Waves NG влияет на то, как генерируются блоки и ноды общаются друг с другом.</p>
<p>В момент наступления своего времени майнинга, нода генерирует так называемый <em>ключевой блок</em> (key block), становясь лидером. Ключевой блок не содержит транзакций, он является только началом блока, который будет меняться. Далее лидер получает право генерировать так называемые <em>микроблоки</em>, которые добавляют новые транзакции в конец блока и меняют его сигнатуру. Например, лидер генерирует ключевой блок со следующими параметрами:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"blocksize"</span>: <span class="hljs-number">39804</span>,
  <span class="hljs-attr">"reward"</span>: <span class="hljs-number">600000000</span>,
  <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"4oBqMB7szmsbSYYguiaAXSE7ZLy13e4x97EKMmA4gs6puRqPKzCVJkuC6Py9eTpiovhcLAYuUSsnEYAi4i73tvoA"</span>,
  <span class="hljs-attr">"generator"</span>: <span class="hljs-string">"3P2HNUd5VUPLMQkJmctTPEeeHumiPN2GkTb"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">"reference"</span>: <span class="hljs-string">"4KEFeMDQgPdntzqmSNZ92NBSMcNft1o4EyQexNLXEdN3976XbdYwDgqaucd9gu2PJWt9tpt1wuvRcTMiiDtkZaX7"</span>,
  <span class="hljs-attr">"features"</span>: [],
  <span class="hljs-attr">"totalFee"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">"nxt-consensus"</span>: {
    <span class="hljs-attr">"base-target"</span>: <span class="hljs-number">66</span>,
    <span class="hljs-attr">"generation-signature"</span>: <span class="hljs-string">"HpFc5qqVftyjKbqhADkQGWBg38CVR9Bz29c7uDZKKvYV"</span>
  },
  <span class="hljs-attr">"desiredReward"</span>: <span class="hljs-number">600000000</span>,
  <span class="hljs-attr">"transactionCount"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1580472824775</span>,
  <span class="hljs-attr">"height"</span>: <span class="hljs-number">1909100</span>
}
</div></code></pre>
<p>В блоке нет транзакций, что видно из значения <code>transactionCount</code>, но основные параметры вроде подписи и ссылки на предыдущий блок (поле <code>reference</code>) уже есть. Создатель этого блока сможет через несколько секунд сгенерировать микроблок со всеми транзакциями, которые появились в сети за эти секунды, и разослать остальным нодам. При этом в блоке поменяются некоторые поля:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-comment">// неизмененные параметры опущены</span>
  <span class="hljs-attr">"blocksize"</span>: <span class="hljs-number">51385</span>,
  <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"4xMaGjQxMX2Zd4jMUUUs5cmemkVwT8Jc5sqx6wzMUokVqWg5jvWSDF6SBF1P7x4UNQjYsgsCs4csa2qtRmG8j3g4"</span>,
  <span class="hljs-attr">"totalFee"</span>: <span class="hljs-number">65400000</span>,
  <span class="hljs-attr">"transactionCount"</span>: <span class="hljs-number">167</span>,
  <span class="hljs-attr">"tranasctions"</span>: [{...}, {...}, ..., {...}]
}
</div></code></pre>
<p>В блок добавились 167 транзакций, которые увеличили размер блока, так же поменялась подпись блока и комиссия, которую заработает лидер.</p>
<p>Несколько важных моментов, которые важно понимать:</p>
<ul>
<li>Микроблок содержит только транзакции и подпись лидера, параметры консенсуса не дублируются</li>
<li>Время генерации микроблоков зависит от настроек майнера (поле <code>waves.miner.micro-block-interval</code> в конфигурации задает значение для каждой ноды). По умолчанию лидер будет генерировать микроблоки каждые 5 секунд.</li>
<li>При каждом новом микроблоке меняются данные последнего блока, поэтому последний блок называют &quot;жидким&quot; (liquid) блоком</li>
<li>Ключевой блок и все микроблоки, которые к нему относятся, объединяются в один блок так, что в блокчейне не остается никаких данных о микроблоках. Можно сказать, что они используются только для передачи информации о транзакциях между нодами.</li>
</ul>
<p>Лидер блока будет генерировать микроблоки и менять жидкий блок до тех пор, пока не будет сгенерирован другой ключевой блок в сети (то есть у какой-то другой ноды сработает таймер начала майнинга) или достигнуты лимиты блока на размер (1 МБ).</p>
<h2 id="%D1%87%D1%82%D0%BE-%D0%B4%D0%B0%D0%B5%D1%82-waves-ng">Что дает Waves NG?</h2>
<p><strong>Благодаря Waves NG сокращается время попадания транзакции в блок. То есть можно в своем приложении обеспечивать гораздо лучший пользовательский опыт.</strong> Пользователь может получать обратную связь по своей транзакции за ~5 секунд, если нет большой очереди за попадание в блок. Только надо понимать, что попадание в блок не является гарантией финализации и блок может быть отменен (до 100 блоков в глубину, но на практике 2-3 блока в крайне редких случаях).</p>
<p><strong>Waves NG делает нагрузку на сеть более равномерной.</strong> В случае отсутствия Waves NG, блоки генерировались бы раз в минуту (сразу 1 МБ данных) и отправлялись бы по сети целиком. То есть можно представить ситуации, когда 50 секунд ноды (кроме майнера) ничего не делают и ждут, а потом принимают блок и валидируют его на протяжении 10 секунд. С Waves NG эта нагрузка более размазана по времени, ноды получают каждые 5 секунд новую порцию данных и валидируют их. Это в целом повышает пропускную способность.</p>
<p>Waves NG однако может себя иногда вести не очень удобно. Как вы помните, каждый блок содержит в себе поле <code>reference</code>, которое является ссылкой на поле <code>signature</code> предыдущего блока. <code>reference</code> фиксируется в момент генерации ключевого блока, и может случиться такое, что новый майнер поставит в своем ключевом блоке ссылку не на последнее состояние жидкого блока. Иными словами, если новый майнер блока <code>N</code> не успел получить и применить последний микроблок блока <code>N - 1</code> от предыдущего майнера, то он сошлется на &quot;старую&quot; версию блока <code>N - 1</code>, транзакции из последнего микроблока будут удалены из блока <code>N - 1</code> для всей сети.</p>
<p>Но не пугайтесь, это приведет только к тому, <strong>что исключенные транзакции попадут в блок <code>N</code></strong>, вместо блока <code>N - 1</code>, в котором мы уже могли успеть увидеть эти транзакции в своем клиентском коде.</p>
<p>Waves NG так же влияет на распределение комиссий в блоке. Майнер получает 60% от комиссий из предыдущего блока и 40% из своего блока. Сделано это для того, чтобы исключить возможную &quot;грязную игру&quot; узлов, когда они будут специально ссылаться на самую первую версию предыдущего блока, чтобы забрать все транзакции оттуда и положить в свой блок, а соответственно получить и комиссии.</p>
<p>Получаемая комиссия может быть потрачена майнером в этом же блоке. Он может добавить в блок транзакцию, за которую получит комиссию в 0.1 Waves и следующей же транзакцией положить в блок, переводящую эти 0.1 Waves с его аккаунта.</p>
<h1 id="%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB%D0%B0-%D0%B8-%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D0%B3%D0%BE%D0%BB%D0%BE%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Обновления протокола и другие голосования</h1>
<p>Как вы могли понять из предыдущего раздела, протокол работы блокчейна, в особенности Waves NG, совсем нетривиальная штука. Но как и любой протокол, он может и должен меняться со временем, чтобы становиться лучше. Но тут не все так просто. Команда разработки Waves не может просто так выпустить обновления и приказать всем обновиться или сказать, что те, кто не обновится, перестанут работать - это противоречит принципам децентрализации. Многие блокчейны идут по пути жестких &quot;форков&quot;, просто выпускается новый функционал с новой версией ноды, дальше кому надо - устанавливает и начинает майнить с поддержкой новой фичи. Кто согласен - переключается на новую цепочку, кто нет - продолжает майнить старую. Этот путь далеко не лучший и может вести к бесчисленному количеству форков, поэтому добавление нового функционала или изменение правил консенуса в Waves возможно только через процедуру предложения нового функционала и голосование.</p>
<p>Процедуру изменения параметров консенсуса с помощью голосований часто называют гаверненсом (governance). Мы не будем использовать это слово, потому что governance в Waves сейчас ограничен двумя типами голосований, в то время как во многих других блокчейнах возможных изменений гораздо больше (баны аккаунтов, жесткие изменения балансов аккаунтов и другие зверства, плохо уживающиеся с принципами децентрализации).</p>
<h2 id="%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%B0-%D0%BF%D1%80%D0%B5%D0%B4%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D0%B0">Процедура предложения нового функционала</h2>
<p>В экосистеме Waves есть неписанное правило (писанного быть не может, децентрализация ведь), что все новые функции и изменения консенсуса должны проходить через процедуру обсуждения. Все предложения по изменения являются так называемыми Waves Enhancement Proposal или WEP. У каждого WEP есть порядковый номер, четка определенная структура и вопросы, на которые это предложение должно отвечать. Форма WEP была предложена на форуме Waves в специальном разделе, но в данный момент основные обсуждения и предложения на github.</p>
<p>Итак, каждое предложение формулируется в виде WEP, далее это предложение обсуждается всеми заинтересованными сторонами, вносятся корректировки, уточняются формулировки и т.д. В конечно итоге, любой человек может реализовать предложенный WEP в коде ноды (репозиторий ведь открытый) и отправить Pull Request на добавление изменений в основную ветку разработки. Команда Waves отвечает за качество кода в репозитории, поэтому при отсутствии проблем с качеством, код будет добавлен в основную ветку и попадет в сборку следующего релиза, которые так же публикуются на github. Но это не говорит о том, что новый код начнет работать, потому что каждый новый функционал (далее фича, от слова &quot;feature&quot;) должен быть одобрен не только разработчиками, но и сообществом, для этого запускается процедура голосования.</p>
<!-- TODO: добавить ссылки на WEP -->
<h2 id="%D0%B3%D0%BE%D0%BB%D0%BE%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B7%D0%B0-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%BA%D0%BE%D0%BD%D1%81%D0%B5%D0%BD%D1%81%D1%83%D1%81%D0%B0">Голосования за правила консенсуса</h2>
<p>Как только владелец ноды устанавливает новую версию, у него появлется возможность голосовать за то, чтобы новая фича была активирована. У каждой фичи есть порядкой номер, по которому идет голосование и идентификация, обычно номера новых фич перечислены в описаниях к релизу на Github, но так же можно посмотреть в API ноды. Владелец ноды может добавить номер поддерживамой фичи в свою конфигурацию в массив <code>waves.features.supported</code>. После этого (а точнее после перезапуска ноды) в каждый генерируемый блок от этой ноды начинает добавляться номер поддерживаемой фичи. То есть, в бинарном представлении блока (в котором и идет работа), появляется новое значение с номером фичи.</p>
<p>Для того, чтобы фича была активирована, необходимо, чтобы ее поддержка была не менее 80% - не менее 80% блоков за период голосования должны в себе содержать информацию о поддержке фичи. Периоды голосования начинаются на каждом кратном десяти-тысячном блое (блок номер 100 000, 110 000, 120 000 и т.д.). Проще говоря, из блоков с номерами 100000-109999 не менее 80% содержать информацию о поддержке новой фичи.</p>
<p>Фактически гаверненс в Waves устроен очень близко к тому, как работает система выборов президента США. Жители страны напрямую не голосуют за президента, они выбирают представителей от каждого штата (количество представителей разнится от штата к штату. Представители уже непосредственно голосуют за президента США.</p>
<p>В Waves владельцы токенов могут напрямую голосовать за активацию фичи, однако, в большинстве случаев они не имеют своих нод и сдают свои токены в лизинг, передавая, таким образом, свое право голоса, владельцу лизингового пула. Важно понимать, что они в любой момент могут отменить лизинг, если владелец пула голосует не так, как они хотели бы, что снизит количество блоков, которые сгенерирует данный пул. Самые большие пулы в Waves часто делают голосования среди лизеров с помощью децентрализованных приложений (мы рассмотрим пример такого голосования в разделе 7), так что и представительская <em>демократия</em>/децентрализация могут быть прозрачными.</p>
<p>Если фича была поддержана более чем 80% стейка, то она будет активирована через 10000 блоков с момента завершения периода голосования. Например, если голосование была во время блоков 10000-19999, то фича станет активной на высоте 30000. Данная задержка позволяет еще раз проверить, что все нормально и новая фича не вызовет форки.</p>
<!-- TODO: зачем на самом деле нужна эта задержка? -->
<p>Если посмотреть в код ноды или в API (<code>/activation/status</code>), то можно заметить, что у каждой фичи есть следующие возможные статусы:</p>
<ul>
<li><strong>VOTING</strong> - идет голосование по фиче</li>
<li><strong>APPROVED</strong> - фича одобрена, но пока не активирована (из-за задержки в 10 000 блоков)</li>
<li><strong>ACTIVATED</strong> - фича активирована, все ноды на этой цепочке должны поддерживать данную фичу</li>
</ul>
<p>Как видите, у фичи нет статуса <code>REJECTED</code>, то есть голосование за фичу может идти бесконечно.</p>
<h2 id="%D0%B3%D0%BE%D0%BB%D0%BE%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0-%D0%B2%D0%BE%D0%B7%D0%BD%D0%B0%D0%B3%D1%80%D0%B0%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0-%D0%B1%D0%BB%D0%BE%D0%BA">Голосование за вознаграждение за блок</h2>
<p>В Waves есть еще один вид голосования нодами, который не встречается практически нигде - голосование за вознаграждение за блок. В 2016 году блокчейн Waves запускался с ограниченной эмиссией токенов - 100 миллионов, коорые уже были созданы на момент запуска сети. Но осенью 2019 года комьюнити осознало, что все-таки модель с эмиссией является более живой, поэтому было предложение обновление - WEP-7, которое прошло через процедуру голосования и на блоке N фича была активирована. Теперь за каждый сгенерированный блок, майнер получает не только комиссии (и то 40% от своего блока и 60% от предыдущего, вы ведь помните про Waves NG?), но и получает Waves, &quot;генерируемые из воздуха&quot;. Примерно каждую минуту общее количество Waves в природе увеличивается на определенное значение. На какое именно значение - предмет голосования нод.</p>
<p>Каждые 100 тысяч блоков (примерно 2 с половиной месяца) начинается голосование за величину вознаграждения. В момент активации фичи N было установлено значение в 6 Waves. Каждые 100 000 блоков это значение может меняться не больше, чем на 0.5 Waves, и то при условии поддержки более чем 50% майнеров.</p>
<p>Голосование за вознаграждение за блок осуществляется немного по другому принципу, не как в случае с фичами. Владельцы нод могут в своем конфигурационном файле в параметре <code>waves.reward.desired</code> установить значение вознаграждения, которое хотели бы увидеть в долгосрочной перспективе. По истечении периода голосования, подсчитывается сколько блоков содержат желаемое вознаграждение больше, чем текущее, и если больше 50%, то вознаграждение увеличивается на 0.5 Waves на следующие 110 000 блоков (наступление нового периода голосования + сам период голосования).</p>
<p>Некоторые участники сообщество спрашивали, почему в <code>waves.reward.desired</code> просто не указывать <code>+</code> или <code>-</code>, раз все равно вознаграждение не будет изменено больше, чем на 0.5 Waves. Указание желаемого вознаграждения в долгосрочной перспективе избавляет от необходимости частого изменения конфигурации. Вы можете поставить значение <code>10</code> и не лезть каждый период голосования в конфигурацию, так как вы будете голосовать за увеличение до тех пор, пока вознаграждение не достигнет 10 Waves за блок. А как только достигнет (если достигнет), нода перестанет голосовать за увеличение вознаграждения. Так просто.</p>
<!-- TODO: Добавить ссылку на WEP-7 и на какой высоте была активация-->
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-3-%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D1%8B-%D0%B8-%D0%BA%D0%BB%D1%8E%D1%87%D0%B8">Глава 3. Аккаунты и ключи</h1>
<p>Первое, с чем сталкивается человек, когда начинает пользоваться блокчейном - работа с ключами. В отличие от классических веб приложений, где у нас есть логин и пароль, в блокчейнах есть только ключи, которые позволяют идентифицировать пользователя и валидность его действий.</p>
<p>У каждого аккаунта есть публичный ключ и соответствующий ему приватный. Публичный ключ является фактически идентификатором аккаунта (ID), в то время как приватный позволяет сформировать подпись. В Waves используется подписи с <a href="https://en.wikipedia.org/wiki/EdDSA#Ed25519">кривой Curve25519-Ed25519</a> с ключами X25519 (что иногда является проблемой, потому что поддержка ключей X25519 есть далеко не во всех библиотеках для языков программирования).</p>
<p>Публичный и приватный ключи представляют из себя 32 байтовые значения, которые соответствуют друг другу по определенным правилам (подробнее можете найти в описании <a href="https://blog.filippo.io/using-ed25519-keys-for-encryption/">EdDSA</a>). Важно понимать несколько вещей, которые отличаю Waves от других блокченов:</p>
<ul>
<li>не любые 32 байта могут быть приватным ключом</li>
<li>приватный ключ не содержит в себе публичный ключ (например, в Ethereum приватный ключ содержит публичный, поэтому имеет размер в 64 байта, в Waves публичный ключ вычисляется каждый раз для приватного ключа)</li>
<li>подпись с помощью EdDSA является недетерменированной, то есть одни и те же данные можно подписать одним и тем же ключом и получать разные подписи, так как используются и случайные значения</li>
</ul>
<h2 id="%D0%BF%D1%83%D1%82%D0%B5%D1%88%D0%B5%D1%81%D1%82%D0%B2%D0%B8%D1%8F-%D0%BA%D0%BB%D1%8E%D1%87%D0%B0">Путешествия ключа</h2>
<p>Большинство пользователей все-таки сталкивается с ключами не в виде массива байт, а в виде сид-фразы, часто так же называемой мнемонической фразой. Любая комбинация байт может быть сидом, но в клиентах Waves обычно используется 15 английских слов. На основе сид фразы вычисляется приватный ключ следующим образом:</p>
<ol>
<li>строка переводится в массив байт</li>
<li>вычисляется хэш <code>blake2b256</code> для данного массива байт</li>
<li>вычисляется хэш <code>keccak256</code> для результата предыдущего шага</li>
<li>вычисляется приватный ключ на основе предыдущего шага, пример функции для этого шага представлен ниже</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GenerateSecretKey</span><span class="hljs-params">(hash []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">SecretKey</span></span> {
    <span class="hljs-keyword">var</span> sk SecretKey
    <span class="hljs-built_in">copy</span>(sk[:], hash[:SecretKeySize])
    sk[<span class="hljs-number">0</span>] &amp;= <span class="hljs-number">248</span>
    sk[<span class="hljs-number">31</span>] &amp;= <span class="hljs-number">127</span>
    sk[<span class="hljs-number">31</span>] |= <span class="hljs-number">64</span>
    <span class="hljs-keyword">return</span> sk
}

</div></code></pre>
<p>Иными словами, а точнее кодом:
<code>privateKey = GenerateSecretKey(keccak256(blake2b256(accountSeedBytes)))</code></p>
<p>Публичный и приватный ключи обычно представляют в виде <code>base58</code> строк вроде <code>3kMEhU5z3v8bmer1ERFUUhW58Dtuhyo9hE5vrhjqAWYT</code>.</p>
<p>При отправке транзакций (например, отправке токенов) пользователь имеет дело с адресом, а не публичным ключом получателя. Адрес генерируется из публичного ключа получателя с некоторыми дополнительными параметрами: версия спецификации адреса, байт сети и чек-сумма. В данный момент в сети Waves есть только одна версия адресов, поэтому первым байтом в этой последоствальности является <code>1</code>, второй байт - уникальный идентификатор сети, который позволяет отличать адреса в разных сетях (mainnet, testnet, stagenet и т.д.). Байты сети для перечисленных выше сетей <code>W</code>, <code>T</code>, <code>S</code> соответственно. Благодаря байту сети невозможно ошибиться и отправить токены на адрес, которого не может существовать в сети, в которой отправляется транзакция (нельзя отправить токены в mainnet на адрес в сети testnet). После первых двух служебных байт идут 20 байт, полученных в результате функций хэширования blake2b256 и keccak256 над публичным ключом. Эта операция <code>keccak256(blake2b256(publicKey))</code> возвращает 32 байта, но последние 12 байт отбрасываются. Последние 4 байта в адресе являются чек-суммой, которая считается как <code>keccak256(blake2b256(data))</code>, где <code>data</code> это первые 3 параметра (версия, байт сети и 20 байт хэша публичного ключа). Полученная последовательность байт переводится в base58 представление, чтобы получилось похожее на это: <code>3PPbMwqLtwBGcJrTA5whqJfY95GqnNnFMDX</code>.</p>
<blockquote>
<p>Опытные разработчики на Waves пользуются особенностями формирования адресов, чтобы по одному только виду определять к какой сети относится адрес. Благодаря тому, что первые 2 байта в адресе похожи для всех адресов в одной сети, можно примерно понимать к какой сети относится адрес. Если адрес выглядит как <code>3P...</code>, то адрес с большой долей вероятности относится к mainnet, а если адрес начинается с <code>3M...</code> или <code>3N</code>, то перед вами скорее всего адрес из testnet или stagenet.</p>
</blockquote>
<h2 id="%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%BC%D0%B8">Работа с ключами</h2>
<p>Если по какой-то причине, приложение необходимо генерировать ключи для пользователя, то можно воспользоваться библиотеками для разных языков программирования. Например, в библиотеке <code>waves-transactions</code> для JavaScript/TypeScript сгенерировать seed фразу можно с помощью следующего кода:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> {seedUtils} <span class="hljs-keyword">from</span> <span class="hljs-string">'@waves/waves-transactions'</span>

<span class="hljs-keyword">const</span> seedPhrase = seedUtils.generateNewSeed(<span class="hljs-number">24</span>);

<span class="hljs-built_in">console</span>.log(seedPhrase);

<span class="hljs-comment">// infant history cram push sight outer off light desert slow tape correct chuckle chat mechanic jacket camp guide need scale twelve else hard cement</span>
</div></code></pre>
<p>В консоль выведется строка из 24 слов, которые являются seed фразой нового аккаунта. Эти слова являются случайным подмножеством из словаря, который есть в <a href="https://github.com/wavesplatform/ts-lib-crypto/blob/master/src/crypto/seed-words-list.ts">коде библиотеки @waves/ts-lib-crypto</a> и в котором содержится 2048 слов.</p>
<p>В данном примере я сгенерировал 24 слова, но по умолчанию во многих приложениях Waves генерируется набор из 15 слов. Почему именно 15 и увеличивается ли безопасность, если сгенерировать больше слов?</p>
<p>15 слов из 2048 в любом порядке достаточно, для того, чтобы вероятность генерации двух одинаковых seed фраз была пренебрежительно мала. В то же время, 24 слова еще уменьшают такую вероятность, почему бы не использовать большие значения? Ответ прост - чем больше слов мы используем, тем больше надо записывать и/или запоминать пользователю и тем сложнее ему будет. Смысл использования seed фразы (а не приватного ключа) именно в упрощении опыта пользователя, а с 24 словами мы заметно ухудшаем пользовательский опыт (user experience).</p>
<blockquote>
<p>Какова вероятность, что кто-то сможет подобрать 15 слов какого-либо кошелька? Этим вопросом задаются многие пользователи, поэтому пользователь <code>deemru</code> на одном из форумов про Waves даже провел <a href="https://wavestalk.ru/t/bezopasnost-koshelka-waves/123/2">рассчеты</a>. Приведу их ниже.</p>
</blockquote>
<ul>
<li>Имеем 20 байт хэша публичного ключа в адресе, которые должны совпасть, это 2^160 вариантов.</li>
<li>(Здесь же отметим, что 15 слов по 2048 (2^11) вариантов каждый, что даёт 2^(11*15) = 2^165, то есть перекрывают 160 бит с запасом в 5 бит, то есть 15 слов взяты не с потолка, это минимально достаточное количество, больше будет излишним, меньше не покроет всех бит публичного ключа в адресе).</li>
<li>Предположим скорость перебора у нас 2 миллиона проб в секунду (такие результаты даёт например F72s_v2 (72 виртуальные цп, память 144 ГБ) на Azure, стоит сие 171 тысяча рублей в месяц).</li>
<li>Начинаем считать: 2 миллиона это ~2^21 проб в секунду, за год будет 60*60*24*365 = 31536000 секунд, это ~2^25, получаем 2^(21+25) = 2^46 проб за год.</li>
<li>Вероятность найти конкретный кошелёк 1/2^(160-46) = 1/2^114</li>
<li>Миллион это ~2^20, тогда вероятность найти кошелёк из миллиона кошельков: 1/2^(114-20) = 1/2^94</li>
<li>Пока тяжело… давайте предположим у нас не 1 машина, а миллион: 1/2^(94-20) = 1/2^74</li>
<li>И не один год, а миллион лет: 1/2^(74-20) = 1/2^54</li>
<li>Умножим миллион имеющихся мощностей на миллион дата-центров: 1/2^(54-20) = 1/2^34</li>
<li>Ну вот, получилась нормальная такая вероятность (которую хотя бы в голове можно представить): 1 шанс из 17 миллиардов найти за миллион лет, в миллионах дата-центров с миллионом машин в каждом 1 кошелёк из миллиона.</li>
<li>Удачи.</li>
</ul>
<p>Теперь вернемся к тому, как работать с сид фразой. Имея seed фразу можно получить приватный ключ, публичный ключ и адрес. Я снова покажу как это сделать на JS, но вы же помните, что есть библиотеки и для других языков?</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">import</span> {seedUtils} <span class="hljs-keyword">from</span> <span class="hljs-string">'@waves/waves-transactions'</span>;
<span class="hljs-keyword">import</span> {
  address,
  privateKey,
  publicKey
} <span class="hljs-keyword">from</span> <span class="hljs-string">'@waves/ts-lib-crypto'</span>


<span class="hljs-keyword">const</span> seedPhrase = seedUtils.generateNewSeed(<span class="hljs-number">24</span>);

<span class="hljs-built_in">console</span>.log(privateKey(seedPhrase));   <span class="hljs-comment">// 3kMEhU5z3v8bmer1ERFUUhW58Dtuhyo9hE5vrhjqAWYT</span>
<span class="hljs-built_in">console</span>.log(publicKey(seedPhrase));    <span class="hljs-comment">// HBqhfdFASRQ5eBBpu2y6c6KKi1az6bMx8v1JxX4iW1Q8</span>
<span class="hljs-built_in">console</span>.log(address(seedPhrase, <span class="hljs-string">'W'</span>)); <span class="hljs-comment">// 3PPbMwqLtwBGcJrTA5whqJfY95GqnNnFMDX</span>
</div></code></pre>
<p>Обратите внимание, что в функции <code>privateKey</code> и <code>publicKey</code> мы передаем только сид фразу, в то время как в <code>address</code> передаем еще один параметр <code>chainId</code> (он же байт сети). Как вы помните из объяснения выше, адрес в себе содержит такой дополнительный параметр.</p>
<h2 id="%D0%BA%D0%B0%D0%BA-%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82-%D0%BF%D0%BE%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F-%D0%B2-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD%D0%B5">Как аккаунт появляется в блокчейне</h2>
<p>Мы разобрали как работают ключи, как связаны сид фраза, приватный и публичный ключ, а также как к ним относится адрес, но я не упомянул один очень важный момент, о котором забывают некоторые начинающие разработчики. До момента совершения какого-либо действия с аккаунтом (отправка с него или на него транзакции), блокчейн ничего не знает об этом аккаунте. Если вы сгенерировали аккаунт (у себя локально или в любом клиенте), но в блокчейне не было транзакций, связанных с этим аккаунтом (входящих или исходящих), вы не сможете найти никакую информацию о вашем аккаунте в эксплорере или с помощью API. Это отличается от поведения в централизованных системах и API, поэтому может быть не так интуитивно понятным и простым, но об этом важно помнить.</p>
<h1 id="%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%B5-%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D1%8B-vs-%D1%81%D0%BC%D0%B0%D1%80%D1%82-%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D1%8B">Обычные аккаунты vs. смарт аккаунты</h1>
<p>Как вы уже наверняка поняли из предыдущего раздела, в Waves используется модель аккаунтов, а не входов и выходов (input и output) как в Bitcoin. Но отличия модели Waves есть не только от Bitcoin, но, например, и от Ethereum, где тоже есть аккаунты. Основное отличие в том, что в Waves есть несколько типов аккаунтов. Давайте разберем их по порядку.</p>
<h2 id="%D0%BE%D0%B1%D1%8B%D1%87%D0%BD%D1%8B%D0%B5-%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D1%8B">Обычные аккаунты</h2>
<p>Работа обычных аккаунтов максимальна проста и интуитивно понятна. Каждый аккаунт (с неким публичным ключом) &quot;обладает&quot; некими токенами и сохраняет данные в свое хранилще. Чтобы сделать действие с аккаунта, необходимо сформировать транзакцию, подписать приватным ключом этого аккаунта и отправить в сеть. <strong>Валидная подпись транзакции позволяет делать операции с этого аккаунта.</strong> Ноды при валидации транзакции фактически прооверяют соответствие подписи и тела транзакции. Так же они должны проверить некоторые параметры из блокчейна, например, если аккаунт хочет отправить токены, есть ли они у него на балансе. Проще всего понять принцип работы с помощью аналогии - аккаунт явлется амбаром, с которым можно сделать что угодно (унести оттуда <s>сыр</s> токены, например), если есть ключ от амбарного замка.</p>
<p>Но обычный аккаунт можно превратить в смарт-аккаунт, который ведет себя по-другому.</p>
<h2 id="%D1%81%D0%BC%D0%B0%D1%80%D1%82-%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82">Смарт аккаунт</h2>
<p>Если на обычный аккаунт поставить скрипт, который задает другие правила валидации <strong>исходящих</strong> транзакций, то он станет <strong>смарт-аккаунтом.</strong> Смарт-аккаунт так же будет &quot;владеть&quot; токенами, но чтобы что-то с ними сделать (перевести, сжечь, обменять и т.д.) надо не предоставить подпись, а удовлетворять условиям, описанным в теле скрипта. Модель во многом похожа на то, что есть в Bitcoin, за одним исключением - в Waves используется не примитивный Bitcoin script, а гораздо более мощный язык Ride. В этой книге будет отдельный раздел, посвященный Ride, поэтому сейчас больше поговорим про концепцию смарт-аккаунтов. Код на Ride отправляется в сеть с помощью транзакции установки скрипта (<code>SetScript</code>) и превращает обычный аккаунт в смарт.</p>
<p>Смарт-аккаунты являются разновидностью смарт-контрактов. В целом можно выделить 3 вида смарт-контрактов, которые встречаются в природе:</p>
<ul>
<li>Простые смарт-контракты для упраления аккаунтами (мультиподпись, эскроу и т.д.)</li>
<li>Сложные контракты с нетривиальной логикой (Crypto-Kitties, Bancor и т.д.)</li>
<li>Контракты токенов (ERC-20, ERC-721)</li>
</ul>
<p>Смарт-аккаунты являются представителями первой категории, будучи предназначенными для базовых операций с аккаунтом. В Waves есть инструменты для создания сложных контрактов, которые будут рассмотрены в разделе 6, а для создания токенов в Waves вообще не требуются контракты, что так же рассмотрим в главе 4.</p>
<p>Смарт-аккаунты <strong>позволяют валидировать только исходящие транзакции</strong> (не входящие). Скрипт смарт-контракта является предикатом, который выполняется при попытке отправить транзакцию с аккаунта, и транзакция считается валидной только в том случае, если тело скрипта возвращает <code>true</code>. Тело скрипта может содержать различную логику, опирающуюся на:</p>
<ul>
<li>Параметры транзакции (например, размер комиссии, получатель транзакции перевода, тип транзакции и т.д.)</li>
<li>Данные из блокчейна (номер последнего блока в блокчейне, данные из хранилища <strong>любого</strong> аккаунта)</li>
<li>Подписи транзакции</li>
</ul>
<p>Продолжая аналогию с амбаром, можно сказать, что смарт-аккаунт является амбаром с другим типом замка, который открывается не по ключу (или не только по ключу), но и может опираться на время, содержимое амбара (или любых других амбаров), личность открывающего и т.д. Думаю, многие амбары во многих колхозах были бы в большей безопасности, если там были замки, открыть которые можно только 5 ключами от разных людей.</p>
<h2 id="%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D1%81%D0%BC%D0%B0%D1%80%D1%82-%D0%B0%D0%BA%D0%BA%D0%B0%D1%83%D0%BD%D1%82%D1%8B">Когда использовать смарт-аккаунты</h2>
<p>Смарт-аккаунты очень легковесны, не требуют много вычислительных мощностей от нод, в то же время покрывает большое количество кейсов. Самыми частыми случаями использования смарт-аккаунтов являются:</p>
<ul>
<li><strong>Мультиподпись.</strong> Например, есть аккаунт с токенами от 3 сторон, и тратить их можно только если согласны 2 стороны из 3.</li>
<li><strong>Эскроу.</strong> Часто при совершении операций в реальной жизни между 2 сторонами необходимо наличие некоего арбитра, который фиксирует факт совершения действия с одной стороны и необходимость передачи ей денег. Продажа квартиры - отличный пример, где при передаче ключей необходимо передавать деньги. Такое можно реализовать с помощью эскроу контракта.</li>
<li><strong>Атомарный обмен.</strong> Обмен токенов в двух сетях, когда токены блокируются сторонами в 2 различных сетях с помощью секрета. Как только одна сторона разблокирует токены в сети А секретом, вторая увидит этот секрет и сможет забрать токены в сети Б.</li>
</ul>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-4-%D1%82%D0%BE%D0%BA%D0%B5%D0%BD%D1%8B">Глава 4. Токены</h1>
<p>После того, как мы поговорили об аккаунтах вполне логично поговорить про другую важную сущность в блокчейне Waves - про токены. Мне лично кажется необходимым начать с истории вопроса, потому что многие все еще знают Waves как платформу для выпуска токенов. В эру бума ICO (2017 год) Waves был второй по популярности платформой для выпуска токенов, потому что позволяла сделать это очень просто. На первом месте был Ethereum, в котором для выпуска токенов необходимо писать смарт-контракт (очень простой и чаще всего в соответствии с ERC-20, но все же). В Waves же выпуск токена делается крайне просто - отправкой одной транзакции специального типа <code>Issue</code>.</p>
<!-- TODO: добавить картинку с количеством токенов на Waves/Eth -->
<p>В некоторых клиентах для Waves (например, в Waves.Exchange) достаточно заполнить одну небольшую форму для выпуска простого токена, который автоматически будет доступен для переводов между аккаунтами, работы с децентрализованными приложениями или торговли на DEX. В данный момент в блокчейне Waves выпущено более 20 000 различных видов токенов.</p>
<h2 id="%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%82%D0%BE%D0%BA%D0%B5%D0%BD%D0%BE%D0%B2">Принципы работы токенов</h2>
<p>В Waves все токены являются &quot;граждами первого сорта&quot; (first-class citizens), они есть прямо в ядре блокчейна, как есть, например, аккаунты. Некоторые (особенно с опытом работы с Ethereum) удивляются этому, но такой подход имеет ряд преимуществ:</p>
<ul>
<li><strong>Простота выпуска.</strong> В 2017 году Waves занимал второе место именно благодаря простоте выпуска, что не надо было разбираться как работает Solidity или EVM, чтобы сделать токен, привязать к каким-то активам в реальной жизни, и начать использовать.</li>
<li><strong>Быстрота работы.</strong> Простые токены в Waves не исполняют никакого кода смарт-контрактов для своей работы, поэтому будут работать быстрее, чем в случае с Solidity. Фактически простой токен в Waves - запись в базе данных LevelDB.</li>
<li><strong>Возможность торговли из коробки.</strong> Выпускаемые токены на Waves автоматически поддерживаются для торговли на децентрализованных биржах на базе матчера Waves. Про работу матчера мы поговорим отдельно.</li>
</ul>
<p><em>У вас уже должен был возникнуть вопрос, а что если я хочу не просто выпустить токен, но сделать для него свою логику?</em></p>
<p><strong>Такое тоже возможно с помощью создания смарт-ассетов, которые мы рассмотрим позже в этой главе.</strong></p>
<p>Много новых разработчиков спрашивают, чем отличается <strong>ассет</strong> от <strong>токена</strong>. В коде ноды Waves вы гораздо чаще будете встречать слоово <code>asset</code>, нежели <code>token</code>, но для удобства в рамках этой книги предлагаю считать эти 2 понятия взаимозаменяемыми. Да, в реальной жизни <code>asset</code> это скорее актив, а <code>токен</code> скорее что-то близкое к жетону, но в мире блокчейна граница между понятиями размылась.</p>
<p>В Waves есть только один токен, который не является ассетом - это сам токен Waves, который платится как комиссия майнерам. Можно сказать, что все токены в Waves равны по возможностям, но токен Waves чуть &quot;ровнее&quot; и его поведение отличается от других ассетов.</p>
<h2 id="%D0%B2%D1%8B%D0%BF%D1%83%D1%81%D0%BA-%D1%82%D0%BE%D0%BA%D0%B5%D0%BD%D0%B0">Выпуск токена</h2>
<p>Как я уже писал выше, для выпуска токена достаточно отправить транзакцию типа <code>Issue</code>, что можно легко сделать с помощью библиотеки на JS:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> { issue } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'seed phrase of fifteen words'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Euro'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">'It is an example of token'</span>,
  <span class="hljs-attr">quantity</span>: <span class="hljs-number">1000000</span>,
  <span class="hljs-comment">//senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-attr">reissuable</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">decimals</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">script</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">Date</span>.now(),
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000000</span>,
}

<span class="hljs-keyword">const</span> signedIssueTx = issue(params, seed)
<span class="hljs-built_in">console</span>.log(signedIssueTx)

</div></code></pre>
<p>В результате выполнения этого кода в консоль выведется следующий JSON:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"id"</span>: <span class="hljs-string">"CZw4KCpPUv5t1Uym3rLc9yEaQyDsP3VVPspdpmWKvVPE"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">"senderPublicKey"</span>: <span class="hljs-string">"HRQUmzJKgHDGbsfS23kSA1VRuudy5MY3wGCroUmNhKuJ"</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Euro"</span>,
  <span class="hljs-attr">"description"</span>: <span class="hljs-string">"It is an example of token"</span>,
  <span class="hljs-attr">"quantity"</span>: <span class="hljs-number">1000000</span>,
  <span class="hljs-attr">"decimals"</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">"reissuable"</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">"script"</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">"fee"</span>: <span class="hljs-number">100000000</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1575034734086</span>,
  <span class="hljs-attr">"chainId"</span>: <span class="hljs-number">87</span>,
  <span class="hljs-attr">"proofs"</span>: [
    <span class="hljs-string">"2ELbuezHiaHUDCuWpfhULwqSA8SUm4vGzWQe5QUmLEPZTA5WMXctiaXaoF9aUbr8TBSBreQxa8WYMsp6Sy2qSSGU"</span>
  ]
}
</div></code></pre>
<p>Давайте разберем основные параметры:</p>
<ul>
<li><strong>name</strong> - название токена (4-16 байт)</li>
<li><strong>description</strong> - описание для токена (0-1000 байт)</li>
<li><strong>quantity</strong> - количество выпускаемых токенов</li>
<li><strong>decimals</strong> - количество знаков после запятой. Обратите внимание, что если поставить значение равное <code>0</code>, то токен будет неделимый. В примере выше минимальной единицой будет не 1 токен, а одна стоая от токена, что логично, так как мы выпускаем аналог евро как пример. Если быть точнее, то выпускаем 1 миллион токенов под название <code>Euro</code>, минимальной единицей которой будет евроцент.</li>
<li><strong>reissuable</strong> - флаг перевыпускаемости токена. Если значение равно <code>true</code>, то владелец токена в любой момент может довыпустить сколько угодно новых токенов такого вида. В момент перевыпуска, владелец может поменять значение этого флага, таким образом зафиксировав количество токенов в блокчейне.</li>
<li><strong>script</strong> - скомпилированный Ride скрипт, описывающий логику работы токена. В нашем примере значаение равно <code>null</code>, так как мы не хотим задавать никаких правил обращения токена.</li>
<li><strong>fee</strong> - комиссия за выпуск токена. В Waves минимальный транзакция для выпуска обычного токена (не NFT) составляет 1 Waves. Почему же тогда в транзакции указано 100000000, где аж 8 нолей? Все просто, у токена Waves количество decimals равно 8, а комиссия указывается в самых маленьких единицах, в случае с Waves минимальные единицы называют иногда <em><strong>waveslet</strong></em>.</li>
</ul>
<p>Отправив такую подписанную транзакцию, можно создать новый токен с названием <code>Euro</code>. Конечно, никакой ценности в таком токене нет, но ценность это уже следующий вопрос. Новосозданный токен получит уникальный идентификатор <code>assetId</code> равный ID транзакциии, которая его породила, в нашем случае <code>CZw4KCpPUv5t1Uym3rLc9yEaQyDsP3VVPspdpmWKvVPE</code>.</p>
<p>Данное правило может быть крайне полезным, поэтому предлагаю запомнить - <code>assetId</code> токена равен <code>ID</code> issue транзакции, которая его создала. В дальнейшем при работе с этим токеном придется использовать  именно его assetId в подавляющем боольшинстве случаев.</p>
<p>Другой важный параметр, который надо запомнить, у токена Waves (нативного/системного для оплаты транзакций) нет <code>assetId</code>, поэтому в местах, где для других токенов вставляется длинная строка, для Waves необходимоо ставить <code>null</code>.</p>
<h2 id="%D0%B2%D1%8B%D0%BF%D1%83%D1%81%D0%BA-nft-%D1%82%D0%BE%D0%BA%D0%B5%D0%BD%D0%B0">Выпуск NFT токена</h2>
<p>Non-fungible токены очень часто используются для различных механик, чаще всего игровых. NFT отличаются тем, что каждый токен уникален и имеет свой уникальный идентификатор. В Waves выпуск Non-fungible токена осуществляется так же, как и выпуск fungile токенов, за несколькими ограничениями:</p>
<ul>
<li><code>quantity</code> обязательно должно быть равно единице</li>
<li><code>decimals</code> всегда должно быть 0</li>
<li><code>reissuable</code> должно быть задано <code>false</code></li>
</ul>
<p>При соблюдении условий выше уже можно выпускать токен с комиссией не в 1 Waves, а в тысячу раз меньше - 0.001 Waves. Для удобной работы с NFT токенами существует JavaScript библиотека <code>@waves/waves-games</code>, которая упрощает создание и сохранение мета-информации о токене. Пример выпуска NFT с помощью этой библиотеки найдете ниже:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">import</span> { wavesItemsApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'@waves/waves-games'</span>
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'my secret backend seed'</span>

<span class="hljs-keyword">const</span> items = wavesItemsApi(<span class="hljs-string">'T'</span>) <span class="hljs-comment">//testnet, use 'W' for mainnet</span>
<span class="hljs-keyword">const</span> item = <span class="hljs-keyword">await</span> items
  .createItem({
    <span class="hljs-attr">version</span>: <span class="hljs-number">1</span>,
    <span class="hljs-attr">quantity</span>: <span class="hljs-number">100</span>,
    <span class="hljs-attr">name</span>: <span class="hljs-string">'The sword of pain'</span>,
    <span class="hljs-attr">imageUrl</span>: <span class="hljs-string">'https://i.pinimg.com/originals/02/c0/46/02c046b9ec76ebb3061515df8cb9f118.jpg'</span>,
    <span class="hljs-attr">misc</span>: {
      <span class="hljs-attr">damage</span>: <span class="hljs-number">22</span>,
      <span class="hljs-attr">power</span>: <span class="hljs-number">13</span>,
    },
  }).broadcast(seed)
<span class="hljs-built_in">console</span>.log(item)

</div></code></pre>
<p>Обратите внимание, что в примере выше выпускается 100 токенов, не токен с количеством 100, а 100 разных, у каждого из которых будет уникальный ID. Другими словами, библиотека отправит 100 issue транзакций. Минимальная комиссия за каждый токен составит 0.001 Waves, а для всех 100 - 0.1 Waves. Больше примеров по работе с библиотекой для NFT вы найдете в <a href="https://docs.item.market/sdk/lib.html#installation">их туториалах</a>.</p>
<h2 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D1%8B%D0%BF%D1%83%D1%81%D0%BA-%D1%82%D0%BE%D0%BA%D0%B5%D0%BD%D0%BE%D0%B2">Перевыпуск токенов</h2>
<p>Если у токена в момент создания стояло значение <code>true</code> для поля <code>reissuable</code>, то создатель может отправлять транзакции типа <code>Reissue</code>, который позволит довыпустить еще токенов. Пример генерации reissue транзакции во многом похож на пример с issue:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> { reissue } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">quantity</span>: <span class="hljs-number">1000000</span>,
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'CZw4KCpPUv5t1Uym3rLc9yEaQyDsP3VVPspdpmWKvVPE'</span>,
  <span class="hljs-attr">reissuable</span>: <span class="hljs-literal">false</span>
}

<span class="hljs-keyword">const</span> signedReissueTx = reissue(params, seed)

</div></code></pre>
<p>Главное отличие в том, что название или описание мы поменять не можем. В нашем примере мы довыпускаем к уже выпущенному миллиону токенов с названием Euro, еще один миллион.</p>
<p>Вы так же можете заметить, что в этой транзакции тоже есть флаг <code>reissuable</code>. Если отправить reissue транзакцию с полем <code>reissuable</code> равным <code>true</code>, то в дальнейшем отправлять такие транзакции для этого токена уже будет нельзя.</p>
<p>В примере выше поле комиссия опущена, но библиотека <code>@waves/waves-transactions</code> автоматически подставит минимальное значение в 1 Waves. Я часто пишу &quot;минимальное значание&quot; комиссии, чтобы показать, что это значение можно сделать больше, но сейчас сеть Waves не испытывает проблем с пропускной способностью, поэтому даже транзакции с минимальной комиссией почи моментально попадают в блоки.</p>
<p>Обратите внимание, что в истории Waves недолгое время был баг, который позволял перевыпускать токены, у которых <code>reissuable</code> был равен <code>false</code>. Баг был оперативно поправлен, но в блокчейне могут встратиться некоторые токены, которые всегда были неперевыпускаемые, но были перевыпущены. Удалить их оттуда не получится, ведь блокчейн иммутабелен. Так что об этом только стоит знать, если вы вдруг делаете эксплорер или какую-то аналитику.</p>
<h2 id="%D1%81%D0%B6%D0%B8%D0%B3%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%BE%D0%BA%D0%B5%D0%BD%D0%BE%D0%B2">Сжигание токенов</h2>
<p>Иногда бывает, что токен мешает и не хочется видеть его в портфолио, а очень часто встречается необходимость сжигать по какой-то бизнес логике. Для этого в Waves есть транзакция типа <code>Burn</code>, которая позволяет сжечь токены (но только со своего аккаунта, конечно).</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> { burn } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'CZw4KCpPUv5t1Uym3rLc9yEaQyDsP3VVPspdpmWKvVPE'</span>,
  <span class="hljs-attr">quantity</span>: <span class="hljs-number">100</span>
}

<span class="hljs-keyword">const</span> signedBurnTx = burn(params, seed)

</div></code></pre>
<p>Транзакция burn максимально прооста и позволяет задать assetId токена, который хотим сжечь и количество. Собственно, все.</p>
<h2 id="%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8-%D0%BE-%D1%82%D0%BE%D0%BA%D0%B5%D0%BD%D0%B5">Изменение информации о токене</h2>
<p>Очень много пользователей спрашивают, можно ли поменять название или описание своего токена. Причин для этого может быть много - переименование компании, изменение адреса веб-сайта (адрес сайта мог быть в описании токена). До недавнего времени такое изменение было невозможно и заданное в самом начале жизни название и описание были навсегда с токеном, но в начале 2020 года появилась транзакция <code>UpdateAssetInfo</code>, которая позволяет обновить название и описание, но не чаще, чем раз в 100 000 блоков, что примерно равно 2,5 месяцев. На момент написания этих строк функционал был активирован только в stagenet и транзакция <code>UpdateAssetInfo</code> еще не поддерживалась библиотеками.</p>
<h2 id="%D0%B0-%D0%B4%D0%B0%D0%BB%D1%8C%D1%88%D0%B5-%D1%87%D1%82%D0%BE">А дальше что?</h2>
<p>Выпуск токена в большинстве случаев является только началом интеграции, поэтому в дальнейшем мы поговорим о том, как использовать Ride для задания логики и API для интеграций вашей бизнес логики с блокчейном.</p>
<h1 id="%D1%81%D0%BF%D0%BE%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">Спонсирование транзакций</h1>
<p>Среди разработчиков децентрализованных приложений есть несколько тем, обсуждение которых приводит к явно выраженной боли на лицах. Такими темами являются:</p>
<ol>
<li><strong>Работа с ключами.</strong> Просить у пользователя ключи нельзя, но он должен как-то подписывать транзакции.</li>
<li><strong>Необходимость платить комиссию в токенах за каждую транзакцию</strong>. Как объяснить пользователям, что каждая транзакция требует комиссии в токене платформы, и что не менее важно - откуда они возьмут комиссии для своих первых транзакций?</li>
</ol>
<p>Обозначенные проблемы приводят к очень высокой стоимости привлечения одного пользователя. Например, один из популярных dApp в экосистеме Waves имел стоимость привлечения клиента около $80 (!), при LTV меньше $10. Конверсию портили именно барьеры с расширением и комиссиями.</p>
<p>Первая проблема часто решается с помощью браузерных расширений вроде Metamask и Waves Keeper, но это решение не дружественное для пользователей и требует большого количества усилий, поэтому в экосистеме Waves появился Signer. Он не требует предоставлять ключи dApp, и в то же время не заставляет устанавливать браузерные расширения. В <a href="https://medium.com/@izhur27/getting-started-with-waves-signer-893017c9b7ae">статье @Vladimir Zhuravlev рассказывается</a> об этом и как интегрировать Waves Signer в свое приложение.</p>
<p>А что же по поводу второй проблемы? Многие создатели dApp просто не заботятся этим вопросом, пользователи должны откуда-то взять токены для комиссий. Другие требуют привязывать банковские карты во время регистрации, что очень сильно снижает мотивацию.</p>
<p><strong>Сейчас я расскажу как решить проблему с комиссиями</strong>. Как сделать такой dApp, который не требует наличия нативного токена у пользователя. Это позволяет делать триальные периоды.</p>
<h2 id="%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D1%81%D0%BF%D0%BE%D0%BD%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">Как работает спонсирование</h2>
<p>Если у вас есть свой токен, который нужен пользователям вашего dApp, то вы можете использовать <a href="https://docs.wavesplatform.com/en/blockchain/waves-protocol/sponsored-fee">механизм спонсирования транзакций</a>. Пользователи будут платить комиссию в вашем токене, но так как майнеры всегда получают комиссию только в Waves, то фактически Waves будут списываться с аккаунта, выпустившего токен. Давайте еще раз по шагам, так как это важно понимать:</p>
<ul>
<li>Пользователь платит комиссию за транзакцию в вашем токене (например, он отправляет 10 ваших токенов, дополнительно платит 1 токен в виде комиссии, в итоге с его аккаунта списывается 11 токенов)</li>
<li>Вы получаете эти токены (1 в нашем примере)</li>
<li>С вашего аккаунта списываются WAVES в необходимом количестве и уходят майнерам(количество спонсируемых токенов и их соотетствие Waves настраивается в момент отправки транзакции SetSponsorship)</li>
</ul>
<p><img src="../../assets/4-2-1-sponsorship.png" alt="How sponsorship works" title="How sponsorship works"></p>
<p><em>Вопрос, который должен был сразу возникнуть - сколько токенов заплатит пользователь и сколько токенов спишется с аккаунта спонсора?</em></p>
<p>Ответ: владелец может сам установить соотношение. В момент начала спонсирования создатель токена задает сколько его токенов соответствуют минимальной комиссии (0.001 Waves или 100 000 в минимальной фракции). Давайте перейдем к примерам и коду, чтобы было понятнее.</p>
<p>Для включения спонсирования, необходимо отправить транзакцию типа <code>Sponsorship</code>. С помощью пользовательского интерфейса можно сделать в Waves.Exchange, а с помощью <a href="https://github.com/wavesplatform/waves-transactions">waves-transactions</a> можно выполнить следующий код:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { sponsorship } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'A'</span>,
  <span class="hljs-attr">minSponsoredAssetFee</span>: <span class="hljs-number">100</span>
}

<span class="hljs-keyword">const</span> signedSponsorshipTx = sponsorship(params, seed)
</div></code></pre>
<p>Код выше сформирует (но не отправит в блокчейн) транзакцию:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"id"</span>: <span class="hljs-string">"A"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-number">14</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"senderPublicKey"</span>: <span class="hljs-string">"3SU7zKraQF8tQAF8Ho75MSVCBfirgaQviFXnseEw4PYg"</span>,
  <span class="hljs-attr">"minSponsoredAssetFee"</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">"assetId"</span>: <span class="hljs-string">"4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC"</span>,
  <span class="hljs-attr">"fee"</span>: <span class="hljs-number">100000000</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1575034734209</span>,
  <span class="hljs-attr">"proofs"</span>: [
    <span class="hljs-string">"42vz3SxqxzSzNC7AdVY34fM7QvQLyJfYFv8EJmCgooAZ9Y69YDNDptMZcupYFdN7h3C1dz2z6keKT9znbVBrikyG"</span>
  ]
}
</div></code></pre>
<p>Самым главным параметром в транзакции является <code>minSponsoredAssetFee</code>, который задает соответствие 100 токенов <code>A</code> равны 0.001 Waves. Таким образом, чтобы отправить <code>Transfer</code> пользователь должен будет в качестве комиссии приложить 100 токенов <code>A</code>.</p>
<p>Важно понимать некоторые ограничения, связанные со спонсированием. Использовать спонсированные токены как комиссию можно только для транзакций типов <code>Transfer</code> и <code>Invoke</code>. Спонсировать токен может только аккаунт, выпустивший этот токен. То есть, вы не сможете спонсировать токены, выпущенные не вами. Как только баланс создателя токена станет меньше 1.005 Waves, спонсирование автоматически выключитс (и обратно включится, когда баланс снова станет больше этого значения).</p>
<h3 id="%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C">Безопасность</h3>
<p>Прежде чем включать спонсирование, надо понимать несколько важных моментов.</p>
<ol>
<li>Пользователь может использовать спонсируемые токены для операций не только с этим токеном. Например, аккаунт с токенами <code>A</code> на балансе может отправлять токены <code>B</code>, а как комиссию приложить токены <code>A</code>.</li>
<li>Пользователь может платить не минимальную комиссию за транзакцию. Например, если у пользователя есть 100 000 ваших токенов, а вы поставили параметр <code>minSponsoredAssetFee</code> равным 100, то пользователь сможет все свои 100 000 токенов указать в качестве комиссии. Вы получите 100 000 токенов <code>A</code>, а майнер получит 1000 Waves с вашего аккаунта (100 000 / 100 = 1000), если они есть на вашем аккаунте.</li>
</ol>
<p>Функция спонсирования есть в Waves долгое время и отлично работает, но есть <a href="https://forum.wavesplatform.com/t/wep-2-customizable-sponsorship/15880">WEP-2 Customizable Sponsorship</a>, в котором высказывались идеи по его улучшению. Если вам есть что добавить - присоединяйтесь к обсуждению.</p>
<h1 id="smart-assets">Smart Assets</h1>
<p>Токены на Waves по умолчанию не являются смарт-контрактом (в отличие от Ethereum), поэтому они свободно обращаются и владельцы токенов могут делать с ними все, что хочется. Но если сильно хочется изменить поведение токена, то это можно сделать, превратив обычный ассет в смарт-ассет. Мы уже рассматривали смарт-аккаунты, чье поведение отличается от обычных аккаунтов тем, что перед отправкой транзакции с такого аккаунта, выполняется его скрипт и он должен вернуть <code>true</code>. Смарт-ассеты очень сильно похожи на смарт-аккаунты. Точно так же к ассету добавляется скрипт на Ride, который выполняется при каждой операции с этим токеном и должен вернуть <code>true</code>, чтобы транзакция считалась валидной. Но есть несколько отличительных особенностей смарт-ассета.</p>
<h2 id="%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%B0-%D0%BA-%D0%B0%D1%81%D1%81%D0%B5%D1%82%D1%83">Добавление скрипта к ассету</h2>
<p>Главное отличие смарт-ассетов от смарт-аккаунтов заключается в том, что если токен выпущен без скрипта, то он не может быть к нему добавлен позже. Сделано это для того, чтобы создатели токенов не имели возмоожности обманывать пользователей, например, отправляя им токены, правила обращения которых могут поменяться. Важно так же пояснить, что если токен выпущен со скриптом и этот скрипт прямо не запрещает, то такой скрипт можно будет обновлять. Вы можете сказать, что владельцы токенов так тоже могут обманывать, но в таком случае пользователи с самого начала хотя бы будут видеть, что токен является смарт-ассетом и могут иметь это ввиду.</p>
<p>Другая причина невозможности добавления скрипта к ассетам, выпущенным без этого заключается в том, что функционал смарт-ассетов появился на третьем году жизни блокчейна Waves, и давать простым токенам, уже несколько лет живущим в сети Waves возможность менять правила игры на ходу без учета мнения пользователей было бы не совсем правильно.</p>
<p>А что же делать, если мы хотим выпустить токен, но не написали еще его скрипт? Достаточно в виде скрипта поставить <code>true</code> (а точнее скомпилированную версию такого скрипта в формате base64 - <code>AwZd0cYf</code>) как скрипт. Такой скрипт не будет запрещать никакие операции с токеном, но позволит в дальнейшем обновить скрипт и задать нужные вам правила.</p>
<p>В разделах 5 (Транзакции) и 6 (Ride) мы подробнее рассмотрим особенности задания скриптом для ассетов и отличительные особенности Ride для токенов.</p>
<h2 id="%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-%D1%81%D0%BC%D0%B0%D1%80%D1%82-%D0%B0%D1%81%D1%81%D0%B5%D1%82%D0%B0">Пример смарт-ассета</h2>
<p>Примером смарт ассета, используемого в экосистеме Waves является Waves Reward Token, который выпустила команда Waves и раздала многим пользователям платформы, чтобы они в дальнейшем могли их переводить амбассадорам (и только им) в качестве благодарности за помощь. Команда Waves в дальнейшем выкупает эти токены. Таким образом, самые активные амбассадоры зарабатывают токены у пользователей и продают команде Waves. Код токена WRT гарантирует, что он может быть переведен только амбассадарам, список которых администрируется командой Waves и хранится в хранилище одного из их аккаунтов.</p>
<h1 id="%D1%82%D0%BE%D1%80%D0%B3%D0%BE%D0%B2%D0%BB%D1%8F-%D0%B0%D1%81%D1%81%D0%B5%D1%82%D0%B0%D0%BC%D0%B8-%D0%B8-dex">Торговля ассетами и DEX</h1>
<p>После появления возможности создания своих токенов, было логичным сделать возможность торговли ими (а если быть точнее - обмена) без участия посредников. Для этого в Waves был создан матчер (от англ &quot;match&quot; - соответствовать, подходить под пару), долгое время являвшийся частью ноды, по умолчанию выключенной (достаточно было в конфигурации ноды включить флаг <code>waves.matcher.enabled</code>).</p>
<h2 id="%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%BC%D0%B0%D1%82%D1%87%D0%B5%D1%80">Как работает матчер</h2>
<p>Матчер принимает от пользователей заявки на обмен токенов, в экосистеме Waves такие заявки принято называть order. Пример такой &quot;заявки&quot; или &quot;намерения&quot; пользователя совершить обмен, представлен ниже:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"senderPublicKey"</span>: <span class="hljs-string">"FMc1iASTGwTC1tDwiKtrVHtdMkrVJ1S3rEBQifEdHnT2"</span>,
  <span class="hljs-attr">"matcherPublicKey"</span>: <span class="hljs-string">"7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy"</span>,
  <span class="hljs-attr">"assetPair"</span>: {
    <span class="hljs-attr">"amountAsset"</span>: <span class="hljs-string">"BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa"</span>,
    <span class="hljs-attr">"priceAsset"</span>: <span class="hljs-literal">null</span>
  },
  <span class="hljs-attr">"orderType"</span>: <span class="hljs-string">"buy"</span>,
  <span class="hljs-attr">"amount"</span>: <span class="hljs-number">150000000</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1548660872383</span>,
  <span class="hljs-attr">"expiration"</span>: <span class="hljs-number">1551252872383</span>,
  <span class="hljs-attr">"matcherFee"</span>: <span class="hljs-number">300000</span>,
  <span class="hljs-attr">"proofs"</span>: [
    <span class="hljs-string">"YNPdPqEUGRW42bFyGqJ8VLHHBYnpukna3NSin26ERZargGEboAhjygenY67gKNgvP5nm5ZV8VGZW3bNtejSKGEa"</span>
  ],
  <span class="hljs-attr">"id"</span>: <span class="hljs-string">"Ho6Y16AKDrySs5VTa983kjg3yCx32iDzDHpDJ5iabXka"</span>,
  <span class="hljs-attr">"sender"</span>: <span class="hljs-string">"3PEFvFmyyZC1n4sfNWq6iwAVhzUT87RTFcA"</span>,
  <span class="hljs-attr">"price"</span>: <span class="hljs-number">1799925005</span>,
}
</div></code></pre>
<p>Помимо информации об отправителе, служебных полей и подписи, каждый order содержит в себе информацию о том, в какой паре токенов должен произойти обмен, тип ордера (<code>buy</code> или <code>sell</code>), срок истечения действия ордера, количество токенов для обмена и цену, по которой пользователь хочет совершить обмен. Посмотрев на пример выше, можно понять, что пользователь хочет обменять <code>Waves</code>, потому что <code>assetPair.priceAsset</code> равен <code>null</code> и тип ордера <code>buyd</code>, на токен c assetId <code>BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa</code> и <a href="https://wavesexplorer.com/tx/BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa">названием <code>Zcash</code></a>, которое можно найти в эксплорере.</p>
<p>Количество токенов для обмена указано 150000000 (всегда помним, что у Waves 8 знаков после запятой, поэтому фактически он хочет обменять 1.5 Waves) на Zcash по цене 17.99925005 за единицу (у Zcash количество знаков после запятой тоже 8). Иными словами, если найдется желающий продать 1 Zchah токен в обмен на 17.99925005 не позднее указанной даты экспирации (1551252872383 или 02/27/2019 @ 7:34am UTC), то будет совершен обмен.</p>
<p>Давайте представим, что другой пользователь отправил контр-ордер для этой же пары со следующими параметрами:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">"senderPublicKey"</span>: <span class="hljs-string">"FMc1iASTGwTC1tDwiKtrVHtdMkrVJ1S3rEBQifEdHnT2"</span>,
  <span class="hljs-attr">"matcherPublicKey"</span>: <span class="hljs-string">"7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy"</span>,
  <span class="hljs-attr">"assetPair"</span>: {
    <span class="hljs-attr">"amountAsset"</span>: <span class="hljs-string">"BrjUWjndUanm5VsJkbUip8VRYy6LWJePtxya3FNv4TQa"</span>,
    <span class="hljs-attr">"priceAsset"</span>: <span class="hljs-literal">null</span>
  },
  <span class="hljs-attr">"orderType"</span>: <span class="hljs-string">"sell"</span>,
  <span class="hljs-attr">"amount"</span>: <span class="hljs-number">3000000000</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">154866085334</span>,
  <span class="hljs-attr">"expiration"</span>: <span class="hljs-number">1551252885334</span>,
  <span class="hljs-attr">"matcherFee"</span>: <span class="hljs-number">300000</span>,
  <span class="hljs-attr">"proofs"</span>: [
    <span class="hljs-string">"YNPdPqEUGRW42bFyGqJ8VLHHBYnpukna3NSin26ERZargGEboAhjygenY67gKNgvP5nm5ZV8VGZW3bNtejSKGEa"</span>
  ],
  <span class="hljs-attr">"id"</span>: <span class="hljs-string">"Ho6Y16EFvFmyyZC1n4sfNWq6iwAVhzUT87RTFcAabXka"</span>,
  <span class="hljs-attr">"sender"</span>: <span class="hljs-string">"3PAKDrySs5VTa983kjg3yCx32iDzDHpDJ5i"</span>,
  <span class="hljs-attr">"price"</span>: <span class="hljs-number">1799925005</span>,
}
</div></code></pre>
<p>Отправитель этого ордера хочет сделать обратную операцию обмена (<code>Zcash</code> -&gt; <code>Waves</code>) по такой же цене, но хочет обменять 30 Zcash.</p>
<p>Оба ордера отправляются на один матчер с публичным ключом <code>7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy</code>, который увидев совпадение параметров (пара, цена) и валидность подписи и даты экспирации, сформирует транзакцию обмена - <code>Exchange</code>. При этом, первый оредр будет исполнен полностью (все 1.5 Waves будут обменены на Zcash), а второй только частично и будет дальше ждать подходящий ордеров для совершения обмена. Примерная схема работы представлена на рисунке:</p>
<p><img src="../../assets/4-4-1-how-dex-works.png" alt="How matching works" title="How matching workks"></p>
<p>Пример <code>Exchange</code> транзакции мы рассмотрим в главе про транзакции, давайте сейчас поговорим про особенности матчера.</p>
<h2 id="%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BC%D0%B0%D1%82%D1%87%D0%B5%D1%80%D0%B0">Функции матчера</h2>
<p>Матчер является сердцем децентрализованных бирж (DEX) на базе Waves, cамой популярной из которых сейчас является waves.exchange. Давайте разберемся как работает матчер и вся процедура децентрализованного обмена.</p>
<p>Матчер принимает от всех желающих их ордера на покупку или продажу токенов, хранит их в стакане (orderbook) и при нахождении соответствия формирует транзакцию обмена и отправляет в блокчейн (отправляет ноде, которая уже добавляет в блок, непосредственно производя обмен токенов на балансах пользователей).</p>
<p>Давайте опишем весь путь для обмена токенов:</p>
<ol>
<li>Пользователь формирует ордер на совершения обмена, указывая пару токенов, тип ордера (что на что хочет обменять), цену обмена, количество токенов для обмена, срок действия, размер комиссии для матчера и на какой матчер хочет отправить свой ордер.</li>
<li>Пользователь подписывает ордер и отправляет на матчер по API.</li>
<li>Матчер проверяет валидность подписи ордера, правильность указанных дат, указанную пользователем комиссию и наличие токенов для обмена и комиссии на балансе у пользователя (для этого делает запрос к блокчейн ноде).</li>
<li>Если обмен совершается в паре, где один или оба токена являются смарт-ассетами, матчер выполняет скрипт ассета и только при получении <code>true</code> считает ордер валидным. В случае получения <code>false</code> или исключения, матчер считает ордер не валидным.</li>
<li>В случае нахождения в стакане (orderbook) контр-ордера, с которым можно совершить операцию обмена, матчер формирует <code>Exchange</code> транзакцию и отправляет блокчейн ноде. Если подходящего ордера не было в стакане, то свежесозданный ордер добавляется в стакан, где будет находиться до тех пока, не найдется правильный контр-ордер или не закончится срок действия ордера. Стоит заметить, что транзакция обмена делается от имени матчера и с подписью матчера, а не от имени пользователей, соответственно, комиссию за попадание в блокчейн платится матчером.</li>
<li>Блокчейн нода при получении <code>Exchange</code> транзакции валидирует транзакцию и входящие в него ордера (транзакция обмена в себя включает сами ордера тоже) и добавляет в блок.</li>
<li>Состояние балансов аккаунтов в блокчейне меняется в соответствии с параметрами <code>Exchange</code> транзакции.</li>
</ol>
<h2 id="%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%B0-%D0%B2-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD%D0%B5-waves">Особенности обмена в блокчейне Waves</h2>
<p>Децентрализованный обмен в Waves может осуществляться и без матчера: два пользователя могут свои ордера объединить в <code>Exchange</code> транзакцию и отправить в сеть от имени третьего аккаунта (или одного из них), но в виду неудобности такого способа, большинство транзакций обмена совершается с помощью матчера.</p>
<p>Матчер является централизованной сущностью и контролируется одним лицом или командой, но почему мы тогда называем обмен децентрализованным, а биржи с использованием матчера - DEX? Надо разобраться в главном отличии обычных централизованных бирж от DEX - контроль средств. Централизованные биржи имеют прямой доступ к средствам пользователей и их ключам, поэтому могут делать с ними все, что хотят, в то время как матчер в Waves имеет доступ только к намерениям пользоваталей (ордерам) и не могут ничего сделать с вашими токенами напрямую. Самое плохое, что может сделать матчер - обменять по не самой выгодной цене, которая есть рынке или не совершить транзакцию обмена, хотя контр-ордер был в стакане.</p>
<p>Есть ли более децентрализованные решения? Конечно есть, есть полностью децентрализованные биржи, однако при полной децентрализации невозможно решить проблему <a href="https://www.investopedia.com/terms/f/frontrunning.asp">фронт-раннинга</a> блокчейн нод (в описанной выше схеме есть риск фронт-раннинга матчера).</p>
<p>Другой особенностью обмена является то, что матчеров в экосистеме Waves много, но они не обмениваются ордерами друг с другом. Фактически, вы доверяете одному матчеру, когда отправляете ему свой ордер. Вы ему доверяете, что он сделает операцию и он сделает это честно (например, не пустит вперед вашего ордер, который пришел позже). Именно это доверие мешает сделать обмен ордерами: скорее всего, вы готовы довериться одному матчеру, но не готовы довериться всем, потому что любой из множества может оказаться &quot;вредителем&quot;.</p>
<p>Наличие централизованного матчинга позволяет достичь отличной пропускной способности в тысячи формируемых <code>Exchange</code> транзакций в секунду. Максимально возможность скорость работы матчера сейчас намного выше, чем пропускная способность блокчейна. Конечно, торговать в режиме высокочастотной торговли (HFT, high-frequency trading) не получится, но есть большое количество ботов, которые делает сотни транзакций в секунду. Примеры ботов вы можете найти в github, самые популярные - <a href="https://docs.wavesplatform.com/en/building-apps/waves-api-and-sdk/examples/trading-bot">Scalping Bot</a> и <a href="https://github.com/PyWaves/BlackBot">Grid Trading Bot</a>.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-5-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8">Глава 5. Транзакции</h1>
<p>В отличие от многих других блокчейнов, где есть 1 (Bitcoin) или 2 (Ethereum) типа транзакций, в Waves их нассчитывается 17 на момент написания этих строк. Ниже представлена схема с условным разделением всех актуальных типов транзакций на категории:</p>
<p><img src="../../assets/5-1-1-transaction-types.png" alt="Waves transaction types" title="Waves Transaction Types"></p>
<p>У вас уже могли возникнуть вопросы: &quot;Почему у транзакций такой хаотичный порядок нумерации?, почему нумерация не идет последовательно хотя бы в рамках одной категории?&quot;.</p>
<p>Дело в том, что транзакции получали номера (они же ID) по мере их добавления в протокол. В этой части мы будем рассматривать транзакции по мере их появления в блокчейне.</p>
<p><strong>Важно: у многих типов транзакций есть несколько версий, в этой книге мы будем рассматривать последние актуальные версии в Mainnet.</strong></p>
<p>Работа с транзакциями осуществуется с помощью API ноды, который позволяет как получать транзакции, так и отправлять их. Для вас, как для разработчиков, транзакция в большинстве случаев будет выглядеть как простой JSON:</p>
<pre class="hljs"><code><div>
</div></code></pre>
<p>Сама нода хранит транзакции в бинарном представлении, а не в виде JSON, но в момент запроса по API кодирует в JSON и отдает в таком виде. Принимает она ее тоже в виде JSON. В REST API ноды есть следующие полезные эндпоинты:</p>
<p><code>GET /transactions/info/{id}</code> - получить информацию об одной транзакции
<code>GET /transactions/address/{address}/limit/{limit}</code> - получить транзакции по адресу
<code>GET /blocks/at/{height}</code> - получить список всех транзакций в блоке</p>
<h2 id="%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">Подпись транзакций</h2>
<p>У всех транзакций есть важное поле - <code>senderPublicKey</code>, которое определяет от имени какого аккаунта совершается действие. Чтобы транзакция (&quot;действие&quot;) считалась валидной, необходимо, чтобы подпись транзакции соответствовала этому публичному ключу (случаи со смарт-аккаунтами сейчас не рассматриваем).</p>
<p>Криптографические функции подписи ничего не знают про транзакции, так как они работают с байтами. В случае Waves, для подписания транзакций необходимо байты транзакции расположить в правильном порядке и передать функции подписи вместе с приватным ключом, в итоге получим подпись.</p>
<pre class="hljs"><code><div>signature = sign(transactionBytes, privateKey)
</div></code></pre>
<p>Правильный порядок байтов для каждой транзакции описан в документации. Криптография выходит за пределы этой книги, но мы можем рассмотреть как формируется подпись для одного из типов транзакции в JS библиотеке:</p>
<pre class="hljs"><code><div>
</div></code></pre>
<p>Подписание транзакций делается обычно на стороне клиентского приложения, но сама нода так же умеет подписывать транзакции через API. Надо понимать, что нода подпишет тем приватным ключом, который задан у нее в конфигурации. <strong>Подписать транзакцию от произвольного отправителя с помощью REST API нельзя.</strong> Многие разработчики думают, что им необходимо получить API key, чтобы подписать свою транзакцию с помощью ноды, но это будет работать только в том случае, есть в конфигурации задан приватный ключ от того аккаунта, который должен совершать действие.</p>
<h2 id="%D0%B6%D0%B8%D0%B7%D0%BD%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-%D1%86%D0%B8%D0%BA%D0%BB-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8">Жизненный цикл транзакции</h2>
<p>Давайте разберем все стадии работы с транзакцией на примере одного действия - отправки токена от одного пользователя другому. У нас возникло желание отправить токены с нашего аккаунта, от которого мы знаем seed фразу (<code>A</code> в нашем примере). Отправлять будем на аккаунт с публичным ключом <code>B</code>. Первым делом нам необходимо задать параметры транзакции:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">amount</span>: <span class="hljs-number">300000000</span>,
  <span class="hljs-attr">recipient</span>: address(<span class="hljs-string">'B'</span>),
  <span class="hljs-attr">feeAssetId</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">assetId</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">attachment</span>: <span class="hljs-string">'TcgsE5ehTSPUftEquDt'</span>,
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000</span>,
}
</div></code></pre>
<p>Поля транзакции мы разберем в следующей части этой главы. Сейчас сконцентрируемся на последовательности действий. Чтобы получить транзакцию вместе с подписью для наших параметров, мы используем библиотеку <code>waves-transactions</code>. Функции <code>transfer</code> мы передаем обозначенные выше параметры и сид-фразу. В итоге мы получим JS объект, который будет содержать все указанные нами поля, а так же подпись в массиве <code>proofs</code>, время подписания транзакции (<code>timestamp</code>) и публичный ключ отправителя (аккаунта с сид фразой <code>A</code>) в поле <code>senderPublicKey</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> signedTransferTx = transfer(params, <span class="hljs-string">'A'</span>);
broadcast(signedTransferTx);
</div></code></pre>
<p>Библиотека от нас скрывает криптографию и подготовительный этап - формирование правильного порядка байт для подписи. Подписанная транзакция в форме JS объекта может быть отправлена в любую ноду, у которой открыт API. Запрос отправляется на <code>POST /transactions/broadcast</code> в виде JSON. Нода примет транзацию, если нет никаких проблем - подпись валидная, хватает токенов на балансе нашего аккаунта для совершения транзакции и т.д. Провалидированная транзакция попадет в UTX ноды, куда мы отправляли запрос, а она уже дальше будет рассылать информацию об этой транзакции всем нодам, с которыми она соединена.</p>
<h3 id="utx">UTX</h3>
<p>UTX - список транзакций, которые находятся в ожидании попадания в блок. То есть кто-то их отправил и нода приняла транзакцию, но транзакция в блок не попала. В Waves есть определенные особенности, связанные с тем как такие транзакции обрабатываются. Как транзакция может попасть в UTX? Существует всего 2 способа для этого:</p>
<ul>
<li>Кто-то отправит транзакцию на эту ноду (c помощью REST API или gRPC)</li>
<li>Нода получит транзакция по бинарному протоколу от другой ноды в сети</li>
</ul>
<p>В конечном итоге можно сказать, что транзакции в сеть приходят через API, но не объязательно, чтобы это был API данной конкретной ноды.</p>
<p>У транзакции, которая попала в UTX, есть 2 варианта дальнейшего развития событий:</p>
<ul>
<li>В какой-то момент времени она будет добавлена в блок одним из майнеров и попадет в блок</li>
<li>Транзакция станет невалидной и будем удалена из UTX (и никогда не сможет попасть в блок). Транзакция может стать невалидной по нескольким причинам - изменилось состояние блокчейна (другая транзакция попала в блок и изменила баланс отправителя, скрипт на аккаунте или скрипте теперь уже возвращает <code>false</code> и тд), истекло время жизни транзакции (сейчас в сети Waves <code>timestamp</code> транзакции может отличаться на -2 или +1.5 часа от текущего времени блокчейна).</li>
</ul>
<p>Время жизни транзакции может истечь только по причине загрузки сети на все 100%. Ноды в Waves добавляют в блок транзакции поочередно, начиная с самых выгодных для них с наибольшей комиссией. Если в момент отправки нашей транзакции перевода токенов, в UTX было много транзакций с большей комиссией, то майнеры не будут добавлять в блок нашу, ведь у блока есть лимит на размер (1 МБ) и количество (6000). Майнеры будут производить блоки максимального размера с самыми выгодными для них транзакциями. Если такое продолжится на протяжении 90 минут, то наша транзакция станет невалидной. На самом деле сортировка транзакция в UTX майнерами производится не только на основе размера коммиссии, поэтому особенности работы UTX мы рассмотрим в дальнейшем.</p>
<p><strong>Для многих новичков становится неожиданностью, что в Waves в блоки могут попадать транзакции &quot;из прошлого&quot; и &quot;из будущего&quot;, у которых <code>timestamp</code> на 120 минут меньше или 90 минут больше настоящего времени.</strong> В некоторых случаях необходимо это учитывать при разработке своих приложений.</p>
<h1 id="%D1%82%D0%B8%D0%BF%D1%8B-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">Типы транзакций</h1>
<p>В Waves есть два типа транзакций, которые сейчас не используются и которые вам точно не пригодятся при работе в основной сети - <code>Genesis</code> и <code>Payment</code>. Долго останавливаться на этих типах транзакций не будем.</p>
<h2 id="genesis-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--1-deprecated">Genesis транзакция (type = 1) [deprecated]</h2>
<p><code>Genesis</code> транзакции были только в <a href="http://nodes.wavesplatform.com/blocks/at/1">самом первом блоке блокчейна</a> и отвечали за распределение предвыпущенных токенов. Их сразу было 100 миллионов. Давайте посмотрим как выглядел <code>genesis</code> блок.</p>
<p><strong>Примечание:</strong> Многие путают <code>genesis</code> блок и <code>genesis</code> транзакции. <code>Genesis</code> блок - самый первый блок в блокчейн сети (во всех блокчейнах принято так называть), который отличается от остальных блоков только отсутствие ссылки на предыдущий блок, ведь его попросту не было. <code>Genesis</code> блок содержит <code>genesis</code> транзакции, которые отвечают за первоначальное распределение выпущенных токенов Waves.</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"reference"</span>: <span class="hljs-string">"67rpwLCuS5DGA8KGZXKsVQ7dnPb9goRLoKfgGbLfQg9WoLUgNY77E2jT11fem3coV9nAkguBACzrU1iyZM4B8roQ"</span>,
  <span class="hljs-attr">"blocksize"</span>: <span class="hljs-number">500</span>,
  <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"FSH8eAAzZNqnG8xgTZtz5xuLqXySsXgAjmFEC25hXMbEufiGjqWPnGCZFt6gLiVLJny16ipxRNAkkzjjhqTjBE2"</span>,
  <span class="hljs-attr">"totalFee"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">"nxt-consensus"</span>: {
    <span class="hljs-attr">"base-target"</span>: <span class="hljs-number">153722867</span>,
    <span class="hljs-attr">"generation-signature"</span>: <span class="hljs-string">"11111111111111111111111111111111"</span>
  },
  <span class="hljs-attr">"fee"</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">"generator"</span>: <span class="hljs-string">"3P274YB5qseSE9DTTL3bpSjosZrYBPDpJ8k"</span>,
  <span class="hljs-attr">"transactionCount"</span>: <span class="hljs-number">6</span>,
  <span class="hljs-attr">"transactions"</span>: [
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"2DVtfgXjpMeFf2PQCqvwxAiaGbiDsxDjSdNQkc5JQ74eWxjWFYgwvqzC4dn7iB1AhuM32WxEiVi1SGijsBtYQwn8"</span>,
      <span class="hljs-attr">"fee"</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1465742577614</span>,
      <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"2DVtfgXjpMeFf2PQCqvwxAiaGbiDsxDjSdNQkc5JQ74eWxjWFYgwvqzC4dn7iB1AhuM32WxEiVi1SGijsBtYQwn8"</span>,
      <span class="hljs-attr">"recipient"</span>: <span class="hljs-string">"3PAWwWa6GbwcJaFzwqXQN5KQm7H96Y7SHTQ"</span>,
      <span class="hljs-attr">"amount"</span>: <span class="hljs-number">9999999500000000</span>
    },
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"2TsxPS216SsZJAiep7HrjZ3stHERVkeZWjMPFcvMotrdGpFa6UCCmoFiBGNizx83Ks8DnP3qdwtJ8WFcN9J4exa3"</span>,
      <span class="hljs-attr">"fee"</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1465742577614</span>,
      <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"2TsxPS216SsZJAiep7HrjZ3stHERVkeZWjMPFcvMotrdGpFa6UCCmoFiBGNizx83Ks8DnP3qdwtJ8WFcN9J4exa3"</span>,
      <span class="hljs-attr">"recipient"</span>: <span class="hljs-string">"3P8JdJGYc7vaLu4UXUZc1iRLdzrkGtdCyJM"</span>,
      <span class="hljs-attr">"amount"</span>: <span class="hljs-number">100000000</span>
    },
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"3gF8LFjhnZdgEVjP7P6o1rvwapqdgxn7GCykCo8boEQRwxCufhrgqXwdYKEg29jyPWthLF5cFyYcKbAeFvhtRNTc"</span>,
      <span class="hljs-attr">"fee"</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1465742577614</span>,
      <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"3gF8LFjhnZdgEVjP7P6o1rvwapqdgxn7GCykCo8boEQRwxCufhrgqXwdYKEg29jyPWthLF5cFyYcKbAeFvhtRNTc"</span>,
      <span class="hljs-attr">"recipient"</span>: <span class="hljs-string">"3PAGPDPqnGkyhcihyjMHe9v36Y4hkAh9yDy"</span>,
      <span class="hljs-attr">"amount"</span>: <span class="hljs-number">100000000</span>
    },
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"5hjSPLDyqic7otvtTJgVv73H3o6GxgTBqFMTY2PqAFzw2GHAnoQddC4EgWWFrAiYrtPadMBUkoepnwFHV1yR6u6g"</span>,
      <span class="hljs-attr">"fee"</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1465742577614</span>,
      <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"5hjSPLDyqic7otvtTJgVv73H3o6GxgTBqFMTY2PqAFzw2GHAnoQddC4EgWWFrAiYrtPadMBUkoepnwFHV1yR6u6g"</span>,
      <span class="hljs-attr">"recipient"</span>: <span class="hljs-string">"3P9o3ZYwtHkaU1KxsKkFjJqJKS3dLHLC9oF"</span>,
      <span class="hljs-attr">"amount"</span>: <span class="hljs-number">100000000</span>
    },
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"ivP1MzTd28yuhJPkJsiurn2rH2hovXqxr7ybHZWoRGUYKazkfaL9MYoTUym4sFgwW7WB5V252QfeFTsM6Uiz3DM"</span>,
      <span class="hljs-attr">"fee"</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1465742577614</span>,
      <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"ivP1MzTd28yuhJPkJsiurn2rH2hovXqxr7ybHZWoRGUYKazkfaL9MYoTUym4sFgwW7WB5V252QfeFTsM6Uiz3DM"</span>,
      <span class="hljs-attr">"recipient"</span>: <span class="hljs-string">"3PJaDyprvekvPXPuAtxrapacuDJopgJRaU3"</span>,
      <span class="hljs-attr">"amount"</span>: <span class="hljs-number">100000000</span>
    },
    {
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"29gnRjk8urzqc9kvqaxAfr6niQTuTZnq7LXDAbd77nydHkvrTA4oepoMLsiPkJ8wj2SeFB5KXASSPmbScvBbfLiV"</span>,
      <span class="hljs-attr">"fee"</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1465742577614</span>,
      <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"29gnRjk8urzqc9kvqaxAfr6niQTuTZnq7LXDAbd77nydHkvrTA4oepoMLsiPkJ8wj2SeFB5KXASSPmbScvBbfLiV"</span>,
      <span class="hljs-attr">"recipient"</span>: <span class="hljs-string">"3PBWXDFUc86N2EQxKJmW8eFco65xTyMZx6J"</span>,
      <span class="hljs-attr">"amount"</span>: <span class="hljs-number">100000000</span>
    }
  ],
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1460678400000</span>,
  <span class="hljs-attr">"height"</span>: <span class="hljs-number">1</span>
}
</div></code></pre>
<p>Можно заметить, что было 6 публичных ключей-получателей свеже выпущенных токенов Waves. У всех транзакций одинаковый timestamp и они все были бесплатными (<code>fee</code> равен нулю), потому что нечем еще было платить <code>fee</code> на момент создания этих транзакций.</p>
<p>Эти транзакции созданы не вручную, они генерируются автоматически специальной утилитой <code>genesis-generator</code>, который есть в репозитории ноды. Вам это может понадобится сделать, если вы захотите запустить свой приватный блокчейн. Как это сделать (и зачем) мы рассмотрим в одной из следующих глав.</p>
<p>Внимательные читатели могут спросить, почему в самой первой транзакции отправляется <code>9999999500000000</code> токенов, если было выпущено всего 100 миллионов? В Waves во всех транзакциях счет идет минимальными неделимыми единицами токена (fraction). У токена Waves количество знаков после запятой (decimals) равно 8, поэтому минимальная единица - одна сто миллионная. Если в поле <code>amount</code> любой транзакции стоит значение <code>100000000</code> (10^8), это обозначает на самом деле один целый токен Waves. В случае с <code>genesis</code> транзакцией, <code>9999999500000000</code> означает 99 999 995 токенов или 9999999500000000 минимальных единиц. Минимальные единицы Waves часто называют WAVELET.</p>
<h2 id="payment-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--2-deprecated">Payment транзакция (type = 2) [deprecated]</h2>
<p>В момент запуска блокчейна Waves было реализовано всего 2 типа транзакций - уже рассмотренный тип <code>genesis</code> и <code>payment</code>, который позволял переводить токены Waves c одного аккаунта на другой. Примеры транзакции <code>payment</code> в JSON представлении можно посмотреть в <a href="http://nodes.wavesplatform.com/blocks/at/2000">блоке под номером 2000</a>.</p>
<pre class="hljs"><code><div>    {
      <span class="hljs-attr">"senderPublicKey"</span>: <span class="hljs-string">"6q5VhGeTanU5T8vWx6Jka3wsptPKSSHA9uXHwdvBMTMC"</span>,
      <span class="hljs-attr">"amount"</span>: <span class="hljs-number">10000000000</span>,
      <span class="hljs-attr">"sender"</span>: <span class="hljs-string">"3PGj6P4Mfzgo24i8cG3nhLU6uktF6s5LVCT"</span>,
      <span class="hljs-attr">"feeAssetId"</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">"signature"</span>: <span class="hljs-string">"3gzk9QyfqQGvsU8A4zMMorpKTcFpdG7UtC4c5E7ds9MGMCMSyp6JZymQJoCjUSJQ8AaSWQDQwNmQ5F46ud4ofA5o"</span>,
      <span class="hljs-attr">"proofs"</span>: [
        <span class="hljs-string">"3gzk9QyfqQGvsU8A4zMMorpKTcFpdG7UtC4c5E7ds9MGMCMSyp6JZymQJoCjUSJQ8AaSWQDQwNmQ5F46ud4ofA5o"</span>
      ],
      <span class="hljs-attr">"fee"</span>: <span class="hljs-number">1</span>,
      <span class="hljs-attr">"recipient"</span>: <span class="hljs-string">"3P59ixWkqiEnL7RJoXtZewgbatKBZo8bG15"</span>,
      <span class="hljs-attr">"id"</span>: <span class="hljs-string">"3gzk9QyfqQGvsU8A4zMMorpKTcFpdG7UtC4c5E7ds9MGMCMSyp6JZymQJoCjUSJQ8AaSWQDQwNmQ5F46ud4ofA5o"</span>,
      <span class="hljs-attr">"type"</span>: <span class="hljs-number">2</span>,
      <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1465865163143</span>
    }
</div></code></pre>
<p><code>Payment</code> транзакция умеет отправлять только Waves токены (не кастомные ассеты) с одного адреса на другой. Она стала устаревшей с появлением <code>Transfer</code> транзакций, которые умеют отправлять как токены Waves, так и кастомные токены, поэтому сейчас <code>Payment</code> уже нигде не используется.</p>
<h2 id="issue-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--3">Issue транзакция (type = 3)</h2>
<p>D разделе про токены мы уже подробно рассматривали как выпустить свой ассет с помощью <code>Issue</code> транзакции, поэтому сейчас не буду останавливаться на том, как его использовать. Стоит только сказать, что отличительная особенность <code>Issue</code> транзакции в наличии 2 принципиально разных вариантов выпуска токена:</p>
<ul>
<li>выпуск уникального токена (он же не взаимозаменяемый токен, non-fungible token, NFT)</li>
<li>выпуск обычного токена</li>
</ul>
<p>Выпуск уникального токена отличается тем, что параметры <code>amount</code>, <code>reissuable</code>, <code>decimals</code> должны иметь заранее известные значения - <code>1</code>, <code>false</code> и <code>0</code> соответственно. При соблюдении этого условия минимальная комиссия составит 0.001 Waves. Если данные параметры отличаются (хотя бы один из параметров), то токен считается обычным и минимальная комиссия выпуска составит 1 Waves.</p>
<p>Пример JSON представления <code>Issue</code> транзакции представлен ниже:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: <span class="hljs-string">"7nSKRN4XZiD3TGYsMRQGQejzP7x8EgiKoG2HcY7oYv6r"</span>,
    quantity: <span class="hljs-number">210000000</span>,
    signature: <span class="hljs-string">"3Vj8M9tkVZmnjdYAKKN3GzAtV9uQDX5hhgUfXQDdvZsk2AmvqQum3oGBJqdjALVHXX2ibLAZHeruwjNXR46WgBnm"</span>,
    fee: <span class="hljs-number">100000000</span>,
    description: <span class="hljs-string">""</span>,
    type: <span class="hljs-number">3</span>,
    version: <span class="hljs-number">1</span>,
    reissuable: <span class="hljs-literal">true</span>,
    sender: <span class="hljs-string">"3PAJ6bw7kvSPf6Q9kAgfSLzmpFspZmsi1ki"</span>,
    feeAssetId: <span class="hljs-literal">null</span>,
    proofs: [
<span class="hljs-string">"3Vj8M9tkVZmnjdYAKKN3GzAtV9uQDX5hhgUfXQDdvZsk2AmvqQum3oGBJqdjALVHXX2ibLAZHeruwjNXR46WgBnm"</span>
],
    script: <span class="hljs-literal">null</span>,
    assetId: <span class="hljs-string">"oWgJN6YGZFtZrV8BWQ1PGktZikgg7jzGmtm16Ktyvjd"</span>,
    decimals: <span class="hljs-number">1</span>,
    name: <span class="hljs-string">"ihodl"</span>,
    id: <span class="hljs-string">"oWgJN6YGZFtZrV8BWQ1PGktZikgg7jzGmtm16Ktyvjd"</span>,
    timestamp: <span class="hljs-number">1528867061493</span>,
    height: <span class="hljs-number">1039500</span>
}
</div></code></pre>
<blockquote>
<p>Важно: если токен выпущен без скрипта, то он не может быть к нему добавлен позже, поэтому если вы хотите добавить скрипт в будущем, но пока у вас нет этого скрипта, то в качестве скрипта указывайте <code>AwZd0cYf</code> (<code>true</code> в скомпилированном base64 варианте)</p>
</blockquote>
<h2 id="tranfer-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--4">Tranfer транзакция (type = 4)</h2>
<p><code>Tranfser</code> транзакция пришла на замену <code>Payment</code> транзакции, потому что <code>Payment</code> не позволял отправлять токены, созданные с помощью <code>Issue</code> транзакции. В данный момент <code>Transfer</code> транзакция является наиболее часто встречающейся по данным <a href="http://dev.pywaves.org/txs/">dev.pywaves.org</a> и составляет порядка 70% транзакций в сети. Отправка <code>Transfer</code> транзакции похожа на отправку большинства транзакций, связанных с токенами:</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> { transfer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>);

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>;

<span class="hljs-comment">//Transfering 3 WAVES</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">amount</span>: <span class="hljs-number">300000000</span>,
  <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs'</span>,
  <span class="hljs-attr">feeAssetId</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">assetId</span>: <span class="hljs-literal">null</span>,
  <span class="hljs-attr">attachment</span>: <span class="hljs-string">'TcgsE5ehTSPUftEquDt'</span>,
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000</span>,
}

<span class="hljs-keyword">const</span> signedTransferTx = transfer(params, seed);
broadcast(signedTransferTx);

</div></code></pre>
<p>Пример выше сгенерирует транзакцию от аккаунта с сид фразой <code>example seed phrase</code>, автоматически подставит в созданную транзакцию дополнительные поля (<code>timestamp</code>,<code>senderPublicKey</code>, <code>proofs</code>), подпишет приватным ключом от указанной сид-фразы и добавит подпись транзакции в массив <code>proofs</code>.</p>
<p>Получаетелем транзакции является адрес <code>3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs</code>, а отправляем мы токены Waves. Чтобы вычислить сколько отправляется токенов нам надо вспомнить, что в транзакции указывается значение <code>amount</code> в минимальных фракциях этого токена. Чтобы получить в целых единицах, надо <code>300000000</code> разделить на <code>10^decimals</code>. <code>300000000 / (10^8) = 3</code>.</p>
<p>У <code>Transfer</code> транзакции есть несколько интересных особенностей:</p>
<ul>
<li>Она поддерживает спонсирование транзакций, поэтому в поле <code>feeAssetId</code> можно указать assetId какого-либо токена, который есть у вас и спонсируется создателем, тогда вы заплатите комиссию в этом токене. В нашем случае указано <code>null</code>, поэтому комиссия будет уплачиваться в Waves.</li>
<li>У транзакции есть поле <code>attachment</code>, который может содержать до 140 байт информации. В библиотеке <code>waves-transactions</code> значение <code>attachment</code> надо передавать в формaте <code>base58</code>, поэтому вы видите <code>TcgsE5ehTSPUftEquDt</code>, хотя в &quot;человеческом&quot; представлении можно прочитать как <code>HelloWavesBook</code>.</li>
</ul>
<p><code>Transfer</code> транзакция позволяет указать в поле <code>amount</code> 0, то есть отправить 0 токенов получателю. Некоторые пользователи используют такую особенность для отправки <code>Transfer</code> транзакций как &quot;сообщений&quot; или событий, которые могут вызывать другие действия уже не в рамках блокчейна.</p>
<p>Пример <code>Transfer</code> транзакции представлен ниже:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: <span class="hljs-string">"CXpZvRkJqBfnAw3wgaRbeNjtLJcithoyQQQSzGQZRF3x"</span>,
    amount: <span class="hljs-number">32800000000</span>,
    signature: <span class="hljs-string">"4cR2NAor9WjeTbysg2QMerkgymc5RLrX8PPjdXkUkWEc7BFBKMCCj8RKF7X1UchbvtEGoqGyQh62MDq5KoXsnCzg"</span>,
    fee: <span class="hljs-number">100000</span>,
    type: <span class="hljs-number">4</span>,
    version: <span class="hljs-number">1</span>,
    attachment: <span class="hljs-string">""</span>,
    sender: <span class="hljs-string">"3P4FoAakEyk78TxUBcXH4uZXLaSE5BiDgjz"</span>,
    feeAssetId: <span class="hljs-literal">null</span>,
    proofs: [
<span class="hljs-string">"4cR2NAor9WjeTbysg2QMerkgymc5RLrX8PPjdXkUkWEc7BFBKMCCj8RKF7X1UchbvtEGoqGyQh62MDq5KoXsnCzg"</span>
],
    assetId: <span class="hljs-literal">null</span>,
    recipient: <span class="hljs-string">"3PNX6XwMeEXaaP1rf5MCk8weYeF7z2vJZBg"</span>,
    feeAsset: <span class="hljs-literal">null</span>,
    id: <span class="hljs-string">"JAutkv1Nk4xVrkb4fkacS4451VvyHC3iJtEDfBRD7rwr"</span>,
    timestamp: <span class="hljs-number">1528867058828</span>,
    height: <span class="hljs-number">1039500</span>
}
</div></code></pre>
<h2 id="reissue-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--5">Reissue транзакция (type = 5)</h2>
<p>Если при выпуске транзакции указать флаг <code>reissuable</code> в значение <code>true</code>, то создатель токена получает возможность перевыпускать токен. История <code>reissuable</code> транзакций в Waves немного странная, так как вы можете найти в блокчейне токены, которые в момент создания имели флаг <code>reissuable</code> равный <code>false</code>, но были перевыпущены. Таких токенов было всего 4, вот их assetId: <code>6SGeUizNdhLx8jEVcAtEsE7MGPHGYyvL2chdmPxDh51K</code>, <code>UUwsxTvvG7LiN7yaAKvNU48JHcSwQ3q1HvsXyAgc9fL</code>, <code>3DhpxLxUrotfXHcWKr4ivvLNVQUueJTSJL5AG4qB2E7U</code>, <code>CH1LNr9ASLVqSHDb482ZzSA5rBVLDtF5QbfECGgwE8bh</code>. Такое стало возможным благодаря багу в коде ноды, он позволял перевыпускать неперевыпускаемые токены. Данный был просуществовал непродолжительное время. Не удивляйтесь, если найдете перевыпущенные <code>non-reissuable</code> токены в истории mainnet Waves.</p>
<p>Пример <code>Reissue</code> транзакции представлен ниже:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: <span class="hljs-string">"4X2Fv5XaDwBj2hjRghfqmsQDvBHqSa2zBUgZPDgySSJG"</span>,
    quantity: <span class="hljs-number">10000000000000000</span>,
    signature: <span class="hljs-string">"5nNrLV46rVzQzeScz3RmZF4rzaV2XaSjT9kjtHoyrBzAj3iVZM9Gy6t5Paho7xRx9dyqzj1AKyWYQsgL2nFa7jYU"</span>,
    fee: <span class="hljs-number">1000000</span>,
    type: <span class="hljs-number">5</span>,
    version: <span class="hljs-number">1</span>,
    reissuable: <span class="hljs-literal">true</span>,
    sender: <span class="hljs-string">"3P6ms9EotRX8JwSrebeTXYVnzpsGCrKWLv4"</span>,
    feeAssetId: <span class="hljs-literal">null</span>,
    chainId: <span class="hljs-literal">null</span>,
    proofs: [
<span class="hljs-string">"5nNrLV46rVzQzeScz3RmZF4rzaV2XaSjT9kjtHoyrBzAj3iVZM9Gy6t5Paho7xRx9dyqzj1AKyWYQsgL2nFa7jYU"</span>
],
    assetId: <span class="hljs-string">"AC3KZWmywTEYrcQwpjg4sQiWxkZ2TZmv81JAvDmsoQvy"</span>,
    id: <span class="hljs-string">"6qd8QbnFrKEibTr26JyNh1hc4KaafGQYStyShtXdNk3v"</span>,
    timestamp: <span class="hljs-number">1528733511933</span>,
    height: <span class="hljs-number">1037381</span>
}
</div></code></pre>
<h2 id="burn-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--6">Burn транзакция (type = 6)</h2>
<p>Транзакция сжигания токенов позволяет сжечь любое количество токенов одного вида. Единственное условие - эти токены должны быть на вашем аккаунте.</p>
<p>Пример <code>Burn</code> транзакции представлен ниже:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: <span class="hljs-string">"EhuzuzEWHhZGo1th6YGy34AecoRP4sVi863xXCQUmgUT"</span>,
    amount: <span class="hljs-number">10000000000</span>,
    signature: <span class="hljs-string">"5HdfqY47Pm4G6h67K9ZpN7jQ4NKr9hsNsmTAtyFD5FhBPr3J9kNxodhYn6hMSieKE7UmYZvSohv7XJpyjKvGCfTC"</span>,
    fee: <span class="hljs-number">100000</span>,
    type: <span class="hljs-number">6</span>,
    version: <span class="hljs-number">1</span>,
    sender: <span class="hljs-string">"3PAjApsrjJWGmRDbGo65gGgrN2hFJroAZDC"</span>,
    feeAssetId: <span class="hljs-literal">null</span>,
    proofs: [
<span class="hljs-string">"5HdfqY47Pm4G6h67K9ZpN7jQ4NKr9hsNsmTAtyFD5FhBPr3J9kNxodhYn6hMSieKE7UmYZvSohv7XJpyjKvGCfTC"</span>
],
    assetId: <span class="hljs-string">"56w2Jbj8MGKwSWyTXvCzkqKKHiyX7C2zrgCQb2CEwM52"</span>,
    id: <span class="hljs-string">"EzeiYzYPwyJNEgofQrE23rpqaYERjUSnCaXZ84vUDoec"</span>,
    timestamp: <span class="hljs-number">1528814759445</span>,
    height: <span class="hljs-number">1038647</span>
}
</div></code></pre>
<h2 id="exchange-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--7">Exchange транзакция (type = 7)</h2>
<p>В предыдущей главе мы достаточно много говорили про процедуру обмена токенов, работу матчера и <code>Exchange</code> ордера. В том числе затронули тему, что транзакция содежит в себе ордера, и именно поэтому данная транзация является наиболее сложной в JSON представлении:</p>
<pre class="hljs"><code><div>{
    senderPublicKey: <span class="hljs-string">"7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy"</span>,
    amount: <span class="hljs-number">74</span>,
    signature: <span class="hljs-string">"2p1BS5BPkMW4C3C6vL8MsrQ8CBQRQqDoYieaZcxeMAq5zvAsm6T4N5DDN6MfPx8emVmbHfibZRsok2v2Ss45e1mj"</span>,
    fee: <span class="hljs-number">300000</span>,
    type: <span class="hljs-number">7</span>,
    version: <span class="hljs-number">1</span>,
    sellMatcherFee: <span class="hljs-number">63610</span>,
    sender: <span class="hljs-string">"3PJaDyprvekvPXPuAtxrapacuDJopgJRaU3"</span>,
    feeAssetId: <span class="hljs-literal">null</span>,
    proofs: [
<span class="hljs-string">"2p1BS5BPkMW4C3C6vL8MsrQ8CBQRQqDoYieaZcxeMAq5zvAsm6T4N5DDN6MfPx8emVmbHfibZRsok2v2Ss45e1mj"</span>
],
    price: <span class="hljs-number">103526336</span>,
    id: <span class="hljs-string">"GHKhG3CWNfXAPWprk9bHSE4rxN6QfNDe3d3rZGaDLWhm"</span>,
    order2: {
    version: <span class="hljs-number">1</span>,
    id: <span class="hljs-string">"5C8qLi2eK92CJtBqXbL9pMuQ2R9VpRMaJ6NGACfxMBCn"</span>,
    sender: <span class="hljs-string">"3P7DsCo8TN5t1PNz45exhLe6vKFkTQJYrNb"</span>,
    senderPublicKey: <span class="hljs-string">"6mYVd69bZsLYW9gpxu3Vjneaf4xpZPnKYiLFuGXJQKQw"</span>,
    matcherPublicKey: <span class="hljs-string">"7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy"</span>,
    assetPair: {
    amountAsset: <span class="hljs-string">"725Yv9oceWsB4GsYwyy4A52kEwyVrL5avubkeChSnL46"</span>,
    priceAsset: <span class="hljs-literal">null</span>
},
    orderType: <span class="hljs-string">"sell"</span>,
    amount: <span class="hljs-number">349</span>,
    price: <span class="hljs-number">103526336</span>,
    timestamp: <span class="hljs-number">1528814695617</span>,
    expiration: <span class="hljs-number">1528814995617</span>,
    matcherFee: <span class="hljs-number">300000</span>,
    signature: <span class="hljs-string">"4DSQvXBLA4U4mtTRzjz62Ci757TZsys8phWbfnCmwvrKDhYFfB8kEknJ9fknAfWkJua7wN4EPbdrSLPgRShaxTsj"</span>,
    proofs: [
<span class="hljs-string">"4DSQvXBLA4U4mtTRzjz62Ci757TZsys8phWbfnCmwvrKDhYFfB8kEknJ9fknAfWkJua7wN4EPbdrSLPgRShaxTsj"</span>
]
},
    order1: {
    version: <span class="hljs-number">1</span>,
    id: <span class="hljs-string">"Eiy6wSzu3aZu3V5Mi7VN54Vmu5KQE18nEQ3j5bJU2WYK"</span>,
    sender: <span class="hljs-string">"3PMFLMN9GG1coCXRn26vUmF2vtCCd4RDWRR"</span>,
    senderPublicKey: <span class="hljs-string">"Dk3r1HwVK1Ktp3MJCoAspNyyRpLFcs2h5SKsoV5F3Rvd"</span>,
    matcherPublicKey: <span class="hljs-string">"7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy"</span>,
    assetPair: {
    amountAsset: <span class="hljs-string">"725Yv9oceWsB4GsYwyy4A52kEwyVrL5avubkeChSnL46"</span>,
    priceAsset: <span class="hljs-literal">null</span>
},
    orderType: <span class="hljs-string">"buy"</span>,
    amount: <span class="hljs-number">74</span>,
    price: <span class="hljs-number">103526336</span>,
    timestamp: <span class="hljs-number">1528814695596</span>,
    expiration: <span class="hljs-number">1528814995596</span>,
    matcherFee: <span class="hljs-number">300000</span>,
    signature: <span class="hljs-string">"5kM8NRVxu4xtDUwz7GCVqyHbeszjXheJn1f7Q5Kpa4zdkeXe8k1kNENAU1YVNXyxNjMHCwtY9mwUkBpZWPo2CHWf"</span>,
    proofs: [
<span class="hljs-string">"5kM8NRVxu4xtDUwz7GCVqyHbeszjXheJn1f7Q5Kpa4zdkeXe8k1kNENAU1YVNXyxNjMHCwtY9mwUkBpZWPo2CHWf"</span>
]
},
    buyMatcherFee: <span class="hljs-number">300000</span>,
    timestamp: <span class="hljs-number">1528814695635</span>,
    height: <span class="hljs-number">1038644</span>
}
</div></code></pre>
<p>Как вы можете заметить, транзакция содержит поля <code>order1</code> (ордер типа <code>buy</code>) и <code>order2</code> (транзакция типа <code>sell</code>). Так же присутствует подпись в массиве <code>proofs</code>, которая явлется подписью матчера (не отправителей ордеров), размер комиссии для матчера (<code>sellMatcherFee</code>), комиссия для ноды, которая смайнит блок (<code>fee</code>).</p>
<p>Значения полей <code>matcherPublicKey</code> в ордерах должно совпадать с полем <code>senderPublicKey</code> для <code>Exchange</code> транзации, что гарантирует невозможность совершения операции обмена с помощью этих ордеров другим матчером.</p>
<p>Формирование <code>Exchange</code> транзакции в большинстве случаев не нужно пользователям и разработчикам, поэтому не поддерживается во многих библиотеках для разных языков программирования. Другое дело - ордера, формирование которых необходимо для ботов и многих пользовательских интерфейсов. Формирование ордера с помощью <code>waves-tranasctions</code> принципиально не отличается от формирования транзакции:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { order } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'b716885e9ba64442b4f1263c8e2d8671e98b800c60ec4dc2a27c83e5f9002b18'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">amount</span>: <span class="hljs-number">100000000</span>, <span class="hljs-comment">//1 waves</span>
  <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>, <span class="hljs-comment">//for 0.00000010 BTC</span>
  <span class="hljs-attr">priceAsset</span>: <span class="hljs-string">'8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS'</span>,
  <span class="hljs-attr">matcherPublicKey</span>: <span class="hljs-string">'7kPFrHDiGw1rCm7LPszuECwWYL3dMf6iMifLRDJQZMzy'</span>,
  <span class="hljs-attr">orderType</span>: <span class="hljs-string">'buy'</span>
}


<span class="hljs-keyword">const</span> signedOrder = order(params, seed)
</div></code></pre>
<p>Обратите внимание, что в отличие от примеров с транзакциями, в примере не используется функция <code>broadcast</code> для отправки транзакции, потому что <code>broadcast</code> отправляет транзакцию в ноду, а нам необходимо отправлять в матчер. Информацию про API матчера можете найти в <a href="https://docs.waves.exchange/en/waves-matcher/matcher-api">документации waves.exchange</a>.</p>
<h2 id="lease-%D0%B8-lease-cancel-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8-type-8-%D0%B8-9">Lease и Lease Cancel транзакции (type 8 и 9)</h2>
<p>В самом начале этой книги мы немного затронули тему лизинга, который позволяет сдавать свои токены другим нодам &quot;в аренду&quot; для генерации блоков. Чтобы сделать это необходимо отправить транзакцию типа <code>Lease</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { lease } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">amount</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs'</span>,
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000</span>
}

<span class="hljs-keyword">const</span> signedLeaseTx = lease(params, seed)
broadcast(signedLeaseTx);
</div></code></pre>
<p>Как видите, транзакция предельно простая, указываем получателя в поле <code>recipient</code> в виде адреса или алиаса (про них поговорим ниже) и сумму, которую ходим отдать в лизинг. Необходимо учитывать, что участвовать в майнинге эти токены будут только спустя 1000 блоков после того, как они будут отправлены в лизинг.</p>
<p>Отправитель лизинга может в любой момент отменить лизинг, снова получая к ним доступ для торговли, переводов или майнинга на своем адресе. Для этого необходимо отправить транзакцию <code>LeaseCancel</code>:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { cancelLease } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">leaseId</span>: <span class="hljs-string">'2fYhSNrXpyKgbtHzh5tnpvnQYuL7JpBFMBthPSGFrqqg'</span>,
  <span class="hljs-attr">senderPublicKey</span>: <span class="hljs-string">'3SU7zKraQF8tQAF8Ho75MSVCBfirgaQviFXnseEw4PYg'</span>, <span class="hljs-comment">//optional, by default derived from seed</span>
  <span class="hljs-attr">timestamp</span>: <span class="hljs-built_in">Date</span>.now(), <span class="hljs-comment">// optional</span>
  <span class="hljs-attr">fee</span>: <span class="hljs-number">100000</span>, <span class="hljs-comment">//minimal value</span>
  <span class="hljs-attr">chainId</span>: <span class="hljs-string">'W'</span> <span class="hljs-comment">// optional</span>
}

<span class="hljs-keyword">const</span> signedCancelLeaseTx = cancelLease(params, seed)
broadcast(signedCancelLeaseTx);
</div></code></pre>
<p>Транзакция отмены лизинга требует передавать id транзакции отправки в лизинг. Отменять можно только всю транзакцию лизинга целиком. Например, если вы отправите в лизинг 1000 Waves любой ноде одной транзакций, вы не сможете забрать часть этой сумму - отмена может быть только целиком.</p>
<p>Обратите так же внимание, что в данной транзакции указывается <code>chainId</code>, в то время как в транзакции отправки лизинга, такого не требуется. Попробуйте угадать почему.</p>
<p>Ответ прост: в транзакции отправки лизинга есть поле <code>recipient</code>, куда указывается адрес и который и так содержит <code>chainId</code> в себе, а в транзакции отмены такого поля нет, поэтому, чтобы сделать невозможным отправку одной и той же транзакции в разных сетях, приходится указывать байт сети. Но если вы используете библиотеку <code>waves-transactions</code>, то она сама подставит байт сети для Mainnet, так что не переживайте.</p>
<p>Другое отличие отмены лизинга от отправки в лизинг в том, что, отмена начинает действовать сразу же, как попадает в блокчейн, без ожидания 1000 блоков.</p>
<h2 id="alias-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--10">Alias транзакция (type = 10)</h2>
<p>В Waves есть уникальная особенность, которой нет во многих других блокчейнах - наличие алиасов. Использовать адреса для совершения операций порой крайне неудобно, они длинные и их невозможно запомнить, поэтому каждый аккаунт может сделать себе алиас. Он может быть простым и легкозапоминаемым. В любой транзакции в сети Waves в поле <code>recipient</code> можно указывать не только адрес, но и алиас.</p>
<p>В Ethereum есть немного похожая концепция ENS, которая построена по принципам DNS, с разными уровнями (namespace) и управлением через смарт-контракты. В Waves алиасы являются частью протокола и все находятся в глобальном пространстве имен, не имея разделения на домены и поддомены. Один аккаунт может создавать неограниченное количество алиасов с помощью отправки специального типа транзакции:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { alias } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">alias</span>: <span class="hljs-string">'new_alias'</span>,
  <span class="hljs-attr">chainId</span>: <span class="hljs-string">'W'</span>
}

<span class="hljs-keyword">const</span> signedAliasTx = alias(params, seed)
broadcast(signedAliasTx)
</div></code></pre>
<p>Алиас может состоять из:</p>
<ul>
<li>буквы латинского алфавита в нижнем регистре</li>
<li>цифры</li>
<li>точка</li>
<li>нижнее подчеркивание</li>
<li>знак дефиса</li>
<li>знак @</li>
</ul>
<p>Алиас должен быть длиной от 4 до 30 символов. Проблема алиасов в сети Waves в том, что они все находятся в глобальном пространстве и не могут повторяться, поэтому есть аккаунтами с более чем 2000 алиасов - своебразная форма киберсквоттинга в блокчейне.</p>
<h2 id="mass-transfer-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--11">Mass transfer транзакция (type = 11)</h2>
<p>На заре своей истории Waves был известен как блокчейн с очень легким выпуском токенов, и закономерным желанием сообщества стало упрощение следующего шага многих кампаний по выпуску токенов - распределение токенов среди получателей. Для удовлетворения этого спроса была создана транзакция, которая позволяет отправить токены с одного адреса на множество. Есть только 2 ограничения - получаетелей может быть до 100, а отправляется им всем только 1 вид токена (нельзя сделать <code>MassTransfer</code> и отправить первой половине адресов токен <code>A</code>, а второй <code>B</code>).</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { massTransfer } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">transfers</span>: [
    {
      <span class="hljs-attr">amount</span>: <span class="hljs-number">100</span>,
      <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs'</span>,
    },
    {
      <span class="hljs-attr">amount</span>: <span class="hljs-number">200</span>,
      <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3PPnqZznWJbPG2Z1Y35w8tZzskiq5AMfUXr'</span>,
    },
  ],
  <span class="hljs-comment">//senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">//timestamp: Date.now(),</span>
  <span class="hljs-comment">// fee: 100000 + transfers.length * 50000,</span>
}

<span class="hljs-keyword">const</span> signedMassTransferTx = massTransfer(params, seed);
broadcast(signedMassTransferTx);
</div></code></pre>
<p>Кроме удобства работы с такой транзакцией, по сравнению с отправкой 100 транзаций типа <code>Transfer</code>, такая транзакция получается еще и дешевле. Если минимальная комиссия для <code>Transfer</code> составляет 0.001 Waves (100000 Wavelet), то размер минимальной комиссии для <code>MassTransfer</code> вычисляется по формуле:</p>
<p><code>100000 + transfers.length * 50000</code></p>
<p>То есть, отправка 100 <code>Transfer</code> транзакций нам обойдется в 0.1 Waves, в то время как отправка одной <code>MassTransfer</code> со 100 получателями всего лишь в 0.051 Waves - почти в 2 раза дешевле.</p>
<h2 id="data-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--12">Data транзакция (type = 12)</h2>
<p>Особенность Waves, которая делает его крайне удобным блокчейном для работы с данными, является наличие <code>Data</code> транзакций, которые появились в апреле 2018 года и позволили записывать данные в блокчейн в очень удобном формате.</p>
<p>С введением <code>Data</code> транзакций, у каждого аккаунта появилось key-value хранилище, в которое можно записывать данные четырех типов: строки, числа, булевые значения и массивы байт.</p>
<p>Хранилище аккаунта не имеет ограничения по общему размеру данных, которое можно туда записывать, но есть ограничения на:</p>
<ul>
<li>размер одной транзакции записи данных в хранилище не более 140 килобайт. Комиссия за транзакцию зависит от размера транзакции и считается по формуле <code>100000 + bytes.length * 100000</code>.</li>
<li>размер данных на один ключ не более 32 килобайт</li>
<li>размер ключа не более 100 символов. Ключами в хранилище могут быть только строки в формате UTF-8.</li>
</ul>
<p>Давайте посмотрим как записать данные с помощью JavaScript библиотеки:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { data } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">data</span>: [
    { <span class="hljs-attr">key</span>: <span class="hljs-string">'integerVal'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> },
    { <span class="hljs-attr">key</span>: <span class="hljs-string">'booleanVal'</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> },
    { <span class="hljs-attr">key</span>: <span class="hljs-string">'stringVal'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'hello'</span> },
    { <span class="hljs-attr">key</span>: <span class="hljs-string">'binaryVal'</span>, <span class="hljs-attr">value</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>] },
  ],
  <span class="hljs-comment">//senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">//timestamp: Date.now(),</span>
  <span class="hljs-comment">//fee: 100000 + bytes.length * 100000</span>
}

<span class="hljs-keyword">const</span> signedDataTx = data(params, seed);
broadcast(signedDataTx);

</div></code></pre>
<p>Надо понимать, что состояние хранилища со всеми ключами и значениями может прочитать любой пользователь, более того, значение по любому ключу доступно всем смарт-контрактам в сети, будь то dapp, смарт ассет или смарт аккаунт.</p>
<p>Данные по ключу могут перезаписываться неограниченное количество раз, если обратное не указано в контракте аккаунта. В дальнейшем мы рассмотрим, как реализовать на аккаунте read-only пары, которые могут быть записаны только один раз и не могут быть изменены или удалены.</p>
<p>Многие пользователи ожидают, что у ассетов тоже есть свои key-value хранилища, однако это не так. Только аккаунт имеет такое хранилище, поэтому если вам необходимо записывать данные для использования ассетом - записывайте в аккаунт, который выпустил токен, или любой другой аккаунт, все равно можно читать любые ключи любых аккаунтов в коде вашего смарт-ассета.</p>
<p>Другой частый вопрос, можно ли удалить из хранилища ключ. До недавнего времени такое было невозможно, но с релизом Ride v4 это становится возможно. Чтобы сейчас не смешивать и Ride и транзакции, давайте отложим рассмотрение кода Ride до следующего раздела, но сейчас поговорим по получение данных их хранилища аккаунта. Это можно сделать с помощью REST запроса к API ноды:</p>
<ol>
<li>Эндпоинт <code>/addresses/data/{address}?matches={regexp}</code> позволяет получить все данные из хранилища, при необходимости фильтрую ключи по регулярному выражению, передаваемому как параметр <code>matches</code>. Фильтрация по значениям пока не поддерживается в ноде.</li>
<li>Эндпоинт <code>/addresses/data/{address}/{key}</code> позволяет получить значение одного ключа в хранилище одного аккаунта.</li>
</ol>
<p>В библиотеке <code>waves-transactions</code> есть дополнительные методы, которые позволяют делать это без необходимости писать самому запрос к API. Ниже пример получения всего состояния хранилища и значения по одному ключу:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { nodeInteractions } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> address = <span class="hljs-string">'3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs'</span>

<span class="hljs-keyword">const</span> wholeStorage = <span class="hljs-keyword">await</span> accountData(address);
<span class="hljs-keyword">const</span> oneKeyValue = <span class="hljs-keyword">await</span> accountDataByKey(address, <span class="hljs-string">"demoKey"</span>);

<span class="hljs-built_in">console</span>.log(wholeStorage, oneKeyValue);

</div></code></pre>
<p>Как видите, все достаточно несложно. У API ноды Waves есть несколько особенностей, некоторые из которых хорошо бы знать до начала работы, чтобы в самый неподходящий момент не получить ошибку в рантайме. К таким особенностям работы я бы отнес следующее:</p>
<ol>
<li>Нода предназначена в первую очередь для поддержания работы блокчейна, а не оптимальной работы с API, поэтому запросы всего хранилища для аккаунтов с большим количеством данных могут приводить к проблемам. Я бы никогда и никому не рекомендовал запрашивать весь стейт аккаунта никогда, потому что если вы это делаете - вы что-то делаете не так.</li>
<li>Нода возвращает результаты в JSON, но в JSON нет возможности передавать массив байт как есть, поэтому в отличие от других типов данных (строк, чисел и булевых значений), они кодируются в <code>base64</code> представление. На самом деле, при записи данных типа массив байт в блокчейн с помощью <code>waves-transactions</code> он так же конвертирует байты в <code>base64</code> строку и отправляет это, а не массив байт в виде чиел. Вот, например, как выглядит сформированная транзация для отправки в API c помощью <code>POST</code> запроса:</li>
</ol>
<pre class="hljs"><code><div>
</div></code></pre>
<p>Будучи DevRel компании Waves я получал много вопросов относительно потенциально некотролируемого роста размера блокчейна. Многих людей, особенно у которых есть опыт работы с другими блокчейнами, смущает факт возможности записывать много данных по фиксированной и достаточно низкой цене и масштабируемость такого решения. В некоторых случаях (особенно долгосрочного хранения) блокчейн Waves может быть экономически эффективнее, чем хранение в Amazon S3, что потенциально опасно для масштабирования сети. Простого ответа на этот вопрос действительно нет, пока размер блокчейна Waves составляет порядка 40 гигабайт (не ~2.8 ТБ как в Ethereum), так что проблема не актуальна, зато простота записи позволяет делать &quot;блокчейн для людей&quot;, о чем мы говорили в самом начале книги. Проблема станет актуальной только в случае быстрого роста популярности блокчейна Waves, но в таком случае будет расти и цена токенов, соответственно, стоимость хранилища тоже, что будет приводить к меньшему количеству желающих писать в блокчейн большие объемы данных. Там, где технология не могут полностью решить проблему, приходит на помощь экономика, что и будет происходить в случае роста популярности.</p>
<h2 id="setscript-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--13">SetScript транзакция (type = 13)</h2>
<p>Транзакции типа <code>SetSсript</code> мы косвенно затрагивали, когда говорили про смарт-аккаунты. Логику поведения смарт-аккаунта и децентрализованных приложений мы описываем с помощью языка Ride, который компилируется в <code>base64</code> представление одним из доступных способов (JS бибиотека <code>ride-js</code>, API ноды, Java пакет в Maven, online IDE или плагин для Visual Studio Code) и отправляется в составе <code>SetScript</code> транзакции:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { setScript } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE в base64 представлении</span>
  <span class="hljs-comment">//senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">//timestamp: Date.now(),</span>
  <span class="hljs-comment">//fee: 100000,</span>
  <span class="hljs-comment">//chainId: 'W'</span>
}

<span class="hljs-keyword">const</span> signedSetScriptTx = setScript(params, seed)
broadcast(signedSetScriptTx);
</div></code></pre>
<p><code>SetScript</code> транзакция используется только для аккаунтов, чтобы сделать из них Smart Account или dApp, но не для токенов. Установка скрипта с помощью <code>SetScript</code> транзакции меняет поведение аккаунта не только с точки зрения того какие транзакции будут попадать в блокчейн, но и с точки зрения комиссии. Смарт-аккаунт платит на 0.004 Waves больше за каждый вид транзакции, по сравнению с обычным аккаунтом.</p>
<p>Чтобы превратить смарт-аккаунт в обычный аккаунт без скрита, необходимо отправить транзакцию <code>SetScript</code> с параметром <code>script</code> равным <code>null</code>. Но не каждый смарт-аккаунт может снова стать обычным аккаунтов. Скрипт смарт-аккаунта может прямо запрещать делать транзакцию <code>SetScript</code> или накладывать другие ограничения.</p>
<h2 id="setsponsorship-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--14">SetSponsorship транзакция (type = 14)</h2>
<p>Особенности спонсирования транзакций и пример SetSponsorship транзакции мы рассматривали в <a href="../../sections/4-Tokens/4-2-sponsorship.md">разделе 4.2</a>, но давайте кратко вспомнил основную суть.</p>
<p>Создать токена имеет возможность отправить транзакцию, которая включает спонсирование транзакций с использованием этого токена. Пользователи будут платить комиссию в токене, но так как майнеры всегда получают комиссию только в Waves, то фактически Waves будут списываться с аккаунта, выпустившего токен.</p>
<ul>
<li>Пользователь платит комиссию за транзакцию спонсируемым токеном (например, он отправляет 10 токенов, дополнительно платит 1 токен в виде комиссии, в итоге с его аккаунта списывается 11 токенов)</li>
<li>Создатель токена получает комиссию в его токене (1 в нашем примере)</li>
<li>С вашего аккаунта списываются WAVES в необходимом количестве и уходят майнерам (количество спонсируемых токенов и их соотетствие Waves настраивается в момент отправки транзакции SetSponsorship)</li>
</ul>
<p><img src="../../assets/4-2-1-sponsorship.png" alt="How sponsorship works" title="How sponsorship works"></p>
<p>Отправить транзакцию включения спонсирования можно достаточно просто:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { sponsorship } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'A'</span>,
  <span class="hljs-attr">minSponsoredAssetFee</span>: <span class="hljs-number">100</span>
}

<span class="hljs-keyword">const</span> signedSponsorshipTx = sponsorship(params, seed)
</div></code></pre>
<p>Код выше сформирует (но не отправит в блокчейн) транзакцию:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"id"</span>: <span class="hljs-string">"A"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-number">14</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"senderPublicKey"</span>: <span class="hljs-string">"3SU7zKraQF8tQAF8Ho75MSVCBfirgaQviFXnseEw4PYg"</span>,
  <span class="hljs-attr">"minSponsoredAssetFee"</span>: <span class="hljs-number">100</span>,
  <span class="hljs-attr">"assetId"</span>: <span class="hljs-string">"4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC"</span>,
  <span class="hljs-attr">"fee"</span>: <span class="hljs-number">100000000</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1575034734209</span>,
  <span class="hljs-attr">"proofs"</span>: [
    <span class="hljs-string">"42vz3SxqxzSzNC7AdVY34fM7QvQLyJfYFv8EJmCgooAZ9Y69YDNDptMZcupYFdN7h3C1dz2z6keKT9znbVBrikyG"</span>
  ]
}
</div></code></pre>
<p>Чтобы отменить спонсирование транзакций, достаточно отправить транзакцию c полем <code>minSponsoredAssetFee</code> равным <code>null</code>.</p>
<h2 id="setassetscript-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--15">SetAssetScript транзакция (type = 15)</h2>
<p>Данная транзакций по своей сути похожа на <code>SetScript</code> транзакцию, за одним исключением - она позволяет менять скрипт для токена.</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">const</span> { setAssetScript } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE в base64 представлении</span>
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC'</span>,
  <span class="hljs-comment">//senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">//timestamp: Date.now(),</span>
  <span class="hljs-comment">//fee: 100000,</span>
  <span class="hljs-comment">//chainId: 'W'</span>
}

<span class="hljs-keyword">const</span> signedSetAssetScriptTx = setAssetScript(params, seed)
broadcast(signedSetAssetScriptTx);
</div></code></pre>
<p><code>SetAssetScript</code> возможна только для ассетов, на которых уже есть скрипт. Если вы с помощью <code>Issue</code> транзакции выпустили транзакцию, которая не имеет скрипта, то установить на нее скрипт в дальнейшем не удастся.</p>
<p>Установка скрипта на токен увеличивает минимальную комиссию для операций с этим токеном на 0.004 Waves (прямо как в случае со смарт-аккаунтами и децентрализованными приложениями).</p>
<p>Например, минимальная комиссия <code>Transfer</code> транзакции составляет 0.001, но для смарт-ассетов составляет 0.005 Waves. Если мы захотим сделать перевод смарт-ассета со смарт-аккаунта, то придется уже заплатить не менее 0.009 Waves (0.001 базовой стоимости, 0.004 прибавки за выполнение скрипта смарт-аккаунта/децентрализованного приложения и смарт-ассета).</p>
<h2 id="invokescript-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--16">InvokeScript транзакция (type = 16)</h2>
<p><code>InvokeScript</code> транзакция является одной из самых важных транзакций в сети, так как она предназначена для вызова функций в децетрализованных приложениях.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { invokeScript } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)

<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>

<span class="hljs-keyword">const</span> params = {

  <span class="hljs-attr">call</span>: {
    <span class="hljs-attr">args</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'integer'</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> }],
    <span class="hljs-attr">args</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'binary'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'base64:AAA='</span> }],
    <span class="hljs-attr">args</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'string'</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">'foo'</span> }],
    <span class="hljs-attr">args</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-string">'boolean'</span>, <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> }],
    <span class="hljs-attr">function</span>: <span class="hljs-string">'foo'</span>,
  },
  <span class="hljs-attr">payment</span>: [
    {
      <span class="hljs-attr">amount</span>: <span class="hljs-number">16</span>,
      <span class="hljs-attr">assetId</span>: <span class="hljs-string">'73pu8pHFNpj9tmWuYjqnZ962tXzJvLGX86dxjZxGYhoK'</span>},
    {
      <span class="hljs-attr">amount</span>: <span class="hljs-number">10</span>,
      <span class="hljs-attr">assetId</span>: <span class="hljs-literal">null</span>
    }
  ],
  <span class="hljs-attr">dApp</span>: <span class="hljs-string">'3Fb641A9hWy63K18KsBJwns64McmdEATgJd'</span>,
  <span class="hljs-attr">chainId</span>: <span class="hljs-string">'W'</span>,
  <span class="hljs-attr">fee</span>: <span class="hljs-number">500000</span>,
  <span class="hljs-attr">feeAssetId</span>: <span class="hljs-string">'73pu8pHFNpj9tmWuYjqnZ962tXzJvLGX86dxjZxGYhoK'</span>,
  <span class="hljs-comment">//senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">//timestamp: Date.now(),</span>
  <span class="hljs-comment">//fee: 100000,</span>
  <span class="hljs-comment">//chainId:</span>
}

<span class="hljs-keyword">const</span> signedInvokeScriptTx = invokeScript(params, seed)
<span class="hljs-built_in">console</span>.log(signedInvokeScriptTx)

</div></code></pre>
<p>Пример выше вызовет функцию <code>foo</code> децентрализованного приложения на аккаунте с адресом  <code>3Fb641A9hWy63K18KsBJwns64McmdEATgJd</code>. При вызову функции передаются 4 аргумента. Аргументы в <code>InvokeScript</code> не именованные, но их порядок должен совпадать с порядком, объявленным в коде децентрализованного приложения. <code>InvokeScript</code> позволяет так же прикрепить к вызову до 2 видов токенов в качестве платежа. В примере выше в качестве оплаты прикрепляются токен <code>73pu8pHFNpj9tmWuYjqnZ962tXzJvLGX86dxjZxGYhoK</code> и Waves (с <code>assetId=null</code>).</p>
<p><code>InvokeScript</code> наряду с <code>Transfer</code> могут быть спонсированы, поэтому в примере выше вызов контракта оплачивается токеном <code>73pu8pHFNpj9tmWuYjqnZ962tXzJvLGX86dxjZxGYhoK</code>, который должен быть спонсированным.</p>
<p>При работе с некоторыми приложениями может возникать желание отправлять транзакции типа <code>InvokeScript</code> с большими аргументами, но сделать это не получится, так как ограничение на размер транзакции составляет 5кб. Если функции в децентрализованном приложении надо передавать аргументы, которые больше этого ограничения, то возможен следующий сценарий:</p>
<ol>
<li>Отправить <code>Data</code> транзакцию (до ~140кб данных)</li>
<li>При вызове функции с помощью <code>InvokeScript</code> передавать в качестве аргумента ключи, которые были записаны с помощью <code>Data</code> транзакции.</li>
<li>В коде децентрализованного приложения читать значения по переданным ключам и их обрабатывать.</li>
</ol>
<h2 id="updateassetinfo-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F-type--17-stagenet">UpdateAssetInfo транзакция (type = 17) [stagenet]</h2>
<p>Новая транзакция <code>UpdateAssetInfo</code> (type = 17) доступна только в сети Stagenet на момент написания этих строк. Она позволяет обновлять данные о выпущенном токене. В протоколе давно существует транзакция перевыпуска (<code>Reissue</code>), которая позволяет довыпустить токены и запретить перевыпуск в дальнейшем, но возможности изменить название или описание токена раньше не было. Однако смена названия и описания может понадобиться многим проектам - например, при смене названия компании, домена (если он упоминается в описании) или продаже компании/бренда. Чтобы избежать недопониманий, давайте зафиксируем отличия транзакций перевыпуска (<code>Reissue</code>) и <code>UpdateAssetInfo</code>:</p>
<ul>
<li><code>Reissue</code> позволяет довыпустить токен (количество задается создателем) и поменять флаг <code>reissuable</code> (только на false), если в момент выпуска токена создатель поставил <code>reissuable=true</code></li>
<li><code>UpdateAssetInfo</code> позволяет обновить название и описание токена, но не чаще, чем раз в 100 000 блоков.</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { updateAssetInfo } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE в base64 представлении</span>
  <span class="hljs-attr">assetId</span>: <span class="hljs-string">'4uK8i4ThRGbehENwa6MxyLtxAjAo1Rj9fduborGExarC'</span>,
  <span class="hljs-attr">description</span>: <span class="hljs-string">"New description"</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-string">"New name"</span>
  <span class="hljs-comment">//senderPublicKey: 'by default derived from seed',</span>
  <span class="hljs-comment">//timestamp: Date.now(),</span>
  <span class="hljs-comment">//fee: 100000,</span>
  <span class="hljs-comment">//chainId: 'W'</span>
}

<span class="hljs-keyword">const</span> updateAssetInfoTx = updateAssetInfo(params, seed)
broadcast(updateAssetInfoTx);
</div></code></pre>
<h2 id="%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B-%D1%81-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D1%8F%D0%BC%D0%B8">Особенности работы с транзакциями</h2>
<p>При формировании транзакций с использованием библиотек часто хочется указывать минимальное количество параметров, чтобы библиотека сама заполнила все остальные. Библиотека <code>waves-transactions</code> так и делает, предлагаю заполнить только самые важные поля и подставляя остальные параметры по умолчанию. Однако существуют поля, заполнять которые не обязательно, но понимать их и знать об их существовании желательно.</p>
<h3 id="additionalfee">additionalFee</h3>
<p>Для всех типов транзакций есть дополнительное поле <code>additionalFee</code>, который позволяет добавить дополнительную комиссию к значениям по умолчанию. Это может быть полезно в 2 случаях:</p>
<ul>
<li>Указать дополнительную комиссию при работе со смарт-ассетами и смарт-аккаунтами. Например, минимальная комиссия за <code>Transfer</code> транзакция по умолчанию составляет 0.001 Waves и именно это значение укажет библиотека <code>waves-transactions</code>, но в случае работы со смарт-ассетами необходимо дополнительно заплатить 0.004. Библиотека не знает, что транзакция отправляется с использованием смарт-ассета, поэтому разработчику необходимо самому предусматривать дополнительную комиссию. Конечно, можно использовать поле <code>fee</code>, чтобы указать всю комиссию целиком, но использование <code>additionalFee</code> удобнее, ведь не надо самому помнить минимальные комиссии за каждый тип транзакции.</li>
<li>Отправлять транзация с повышенной комиссией для быстрого попадания в блок. Загрузка сети Waves сейчас сильно меньше пропускной способности, поэтому необходимость указывать повышенную комиссию встает крайне редко, но такая возможность существует. В следующей главе мы поговорим про сортировку транзакций в UTX (листе ожидания для попадания в блок).</li>
</ul>
<p>В таблице ниже представлены минимальные комиссии за транзакции разных типов (при отправке с обычного аккаунта и без взаимодействия со смарт-ассетами):</p>
<p><img src="../../assets/5-2-1-transaction-min-fees.png" alt="Min transaction fees" title="Min transaction fees"></p>
<h3 id="chainid">chainId</h3>
<p>В примерах транзакций выше вы могли замечать поле <code>chainId</code>, которое чаще всего было указано как <code>W</code>. Каждая транзакция в сети <code>Waves</code> содержит в себе байт сети либо в прямом виде, либо опосредованно (когда в транзакциях задействован адрес получателя). Байт сети мы рассматривали, когда говорили про адреса в <a href="../../sections/3-Accounts/3-1-keys.md">разделе 3</a>.</p>
<p>Байт сети - уникальный идентификатор сети, который позволяет отличать адреса и транзакции в разных сетях (mainnet, testnet, stagenet). Байты сети для перечисленных выше сетей - <code>W</code>, <code>T</code>, <code>S</code> соответственно. Благодаря байту сети невозможно ошибиться и отправить токены на адрес, которого не может существовать в сети, в которой отправляется транзакция. Если бы не было байта сети, то была бы возможна атака на пользователей, которые используют одну пару приватного и публичного ключа в нескольких сетях (stagenet и mainnet, например). Злоумышленник мог бы скопировать транзакцию из сети stagenet от пользователя и отправить ее в сеть mainnet, произведя действие, которое пользователь не хотел делать в mainnet. Благодаря байту сети такое невозможно.</p>
<h3 id="timestamp">timestamp</h3>
<p>У каждой транзакции есть время его создания, которое прописывается в транзакции и подписывается отправителем наряду с другими полями. <code>waves-transactions</code> по умолчанию поставит время, которое задано в оперциаонной системе, где запускается код. В протоколе Waves ноды синхронизируют время друг с другом с помощью протокола NTP, поэтому отличие между ними составляет не больше 1 секунды. Можно сказать, что сеть Waves знает актуальное время, и актуальное время прописывается в теле блока в момент его создания нодой. Если какой-либо генератор попытается сделать блок &quot;из прошлого&quot; или &quot;из будущего&quot;, то остальные генераторы и валидаторы такой блок не примут.</p>
<p>Что же касается времени транзакции, то оно может отличаться от времени блока не более, чем на 90 минут в прошлое и 120 в будущем. Вы можете отправить транзакцию, в которой <code>timestamp</code> будет из будущего на 120 минут и генераторы попробуют добавить ее в блок, но если отправить со временем, которое больше времени на нодах на 121 минуту, то транзакция уже будет отвергнута.</p>
<p>Параметр <code>timestamp</code> может использоваться для регулирования сколько максимально времени транзакция может находиться в списке ожидания на попадания в блок. Если сеть загружена, транзакции попадают в блок очень медленно и нам не хочется платить большую комиссию, но мы готовы подождать, то можно поставить <code>timestamp</code>, который на 120 минут больше времени на нодах. Такая транзакция будет валидной в течение 210 минут (3 с половиной часа) и только если она не попала в блок в течение этого времени, она будет отвергнута. Может быть и обратная ситуация, когда нам важно, чтобы транзакция могла только быстро попасть в блок или не попасть вовсе. В таком случае, установка <code>timestamp</code> на 85 минут меньше, чем актуальное время, гарантирует, что она будет валидной только 5 минут, и если в течение этих 5 минут не попала в блок, то будет вычищена из UTX и уже никогда не попадет в блок.</p>
<p>При использовании поля <code>timestamp</code> транзакций в коде смарт-контрактов необходимо помнить, что оно может отличаться от настоящего на [-90; +120] минут. В разделе 7 мы поговорим о том, как правильно использовать время, если оно вам все-таки надо в коде контракта.</p>
<h3 id="proofs">proofs</h3>
<p>Поле <code>proofs</code> является массивом, который предназначен для подписей транзакции. Подписей может быть до 8. На самом деле, в этом поле можно хранить не только подписи, но и использовать для передачи в качестве аргументов в смарт-аккауты или децентрализованные приложения. Это особенно может быть полезно при работе со смарт-аккаунтами, которые не могут принимать аргументы.</p>
<h3 id="id">id</h3>
<p>Каждая транзакция в сети имеет уникальный ID, который является хэшом на основе полей транзакции. В сети не может быть 2 одинаковых транзакций с двумя одинаковыми ID. ID транзакции вычисляется <code>waves-transactions</code> автоматически и оно может быть использовано для работы с API - для ожидания попададания в блок или проверки статуса.</p>
<h3 id="version">version</h3>
<p>В сети Waves есть не только много разных типов транзакций, но могут быть несколько разных версий для каждого типа. Например, для типов вроде <code>Transfer</code> или <code>Issue</code> имеют 3 версии. Важно учитывать, что JSON представление транзакций при работе с API может отличаться для разных версий одного и того же типа.</p>
<h2 id="%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9">Подпись транзакций</h2>
<p>У каждой транзакции последних версий может быть не одна подпись, а до 8. В примерах выше мы всегда использовали сид фразу, из которой библиотека <code>waves-transactions</code> сама получала публичный ключ <code>senderPublicKey</code> и подпись в массив <code>proofs</code>. Бывают ситуации, когда отправить необходимо транзакцию с одного аккаунта, а подписать ключом другого (мы рассмотрим такие примеры позже в главе 6). В таком случае, формировать транзакцию нужно с явным указанием <code>senderPublicKey</code> отправителя следующим образом:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { setScript } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)
<span class="hljs-keyword">const</span> seed = <span class="hljs-string">'example seed phrase'</span>
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE в base64 представлении</span>
  <span class="hljs-attr">senderPublicKey</span>: <span class="hljs-string">'4VStEwhXhsv6wQ6PBR5CfEYD8m91zYg2pcF7v17QGSbJ'</span>,
}

<span class="hljs-keyword">const</span> signedSetScriptTx = setScript(params, seed)
</div></code></pre>
<p>Если же необходимо подписать несколькими ключами, то существует 2 варианта это сделать:</p>
<ul>
<li>использовать функцию <code>addProof(tx: ITransaction, seed: string)</code>, которая принимает тело сформированной транзакции и добавляем подпись от сида, передаваемого вторым аргументом</li>
<li>при формировании транзакции передавать массив сид фраз</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> { setScript } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'@waves/waves-transactions'</span>)
<span class="hljs-keyword">const</span> seeds = [<span class="hljs-string">'0 - example seed phrase'</span>, <span class="hljs-string">'1 - example seed phrase'</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'3 - example seed phrase'</span>]
<span class="hljs-keyword">const</span> params = {
  <span class="hljs-attr">script</span>: <span class="hljs-string">'AQa3b8tH'</span>, <span class="hljs-comment">// TRUE в base64 представлении</span>
  <span class="hljs-attr">senderPublicKey</span>: <span class="hljs-string">'4VStEwhXhsv6wQ6PBR5CfEYD8m91zYg2pcF7v17QGSbJ'</span>,
}

<span class="hljs-keyword">const</span> signedSetScriptTx = setScript(params, seeds)
</div></code></pre>
<p>В таком случае, созданная транзакция будет содержать 3 подписи в массиве <code>proofs</code> под индексами 0, 1 и 3, а под индексом 2 будет <code>null</code>:</p>
<pre class="hljs"><code><div>{
  <span class="hljs-attr">"type"</span>: <span class="hljs-number">13</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"senderPublicKey"</span>: <span class="hljs-string">"4VStEwhXhsv6wQ6PBR5CfEYD8m91zYg2pcF7v17QGSbJ"</span>,
  <span class="hljs-attr">"chainId"</span>: <span class="hljs-number">82</span>,
  <span class="hljs-attr">"fee"</span>: <span class="hljs-number">1000000</span>,
  <span class="hljs-attr">"timestamp"</span>: <span class="hljs-number">1587883659092</span>,
  <span class="hljs-attr">"proofs"</span>: [
    <span class="hljs-string">"4cajf7tKFJR2rvzWpsufytU1p1dTtstbnRLg1A89eCgg2ezFRqe1UKyux5vzK1BeFeoiGFpZ8Vu6epzFTdhZQqWe"</span>,
    <span class="hljs-string">"3PVzmWVnS2CJWpXDonCuWGgE48FsxZWQVriwNJXmstxZvqWQaowsebnAC5zca7j71cHQpZxB5yizmhzzKT9cvWXh"</span>,
    <span class="hljs-literal">null</span>,
    <span class="hljs-string">"2d6yyeTzjF5J8frSyuyBf3B2qKyoKuHEJq4X22joghjyeW7nZJBWdQhLVfxaUYQ6GnAhjXA7Mz7FXXkhRz7n5Zh9"</span>
  ],
  <span class="hljs-attr">"id"</span>: <span class="hljs-string">"8btD3NufMo8VApFi4opTPPdfa2ej6w2SFTojCaMcaqQq"</span>,
  <span class="hljs-attr">"script"</span>: <span class="hljs-string">"base64:..."</span>
}
</div></code></pre>
<h1 id="%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-utx">Особенности обработки UTX</h1>
<p>Транзакции в листе ожидания это ни разу не весело, они ведь хотят в блок! Как же определить какая транзакция должна первой попасть в блок. Можно было бы сделать простую очередь и руководствоваться принципом &quot;Кто первый встал, того и тапки&quot;, но такой подход не является оптимальным для майнеров в сети. Им гораздо выгоднее класть в блок транзакции с большей комиссией. Но и тут не все так просто, вы ведь помните, что в Waves существует разные виды транзакций. У каждого вида своя минимальная комиссия, заданная в консенсусе, поэтому обработка в зависимости от размера комиссии тоже не приведет к ожидаемому результату. Например, отправка InvokeScript транзакций с минимальной комиссией в 0.005 Waves будет всегда попадать в блок раньше, чем транзакция Transfer с комиссией в 0.001 Waves. Что же делать?</p>
<p>Первое, что можно придумать, это сортировать транзакции в зависимости от стоимости на байт транзакции. Нода тратит ресурсы на валидацию подписи для транзакции, и чем больше транзакция по размеру, тем больше ресурсов на это потратится. Например, <code>Data</code> транзакция размером в 140 kb будет валидироваться в несколько десятков раз дольше, чем <code>Transfer</code> транзакция размером меньше килобайта. Давайте поговорим на примерах. Скажем, у нас есть 2 транзакции:</p>
<ul>
<li>Data транзакция размером в 100 kb и с комиссией в 0.01 Waves</li>
<li>Transfer транзакция размером в 1kb и с комиссией в 0.001 Waves</li>
</ul>
<p>Какая транзакция будет первой в очереди? Та, которая была получена первой, потому что в пересчете на 1 байт транзакции комиссия у этих 2 транзакций равная.</p>
<p>На схеме ниже показано, как именно нода обрабатывает транзакции до попадания в блок, а так же во время его нахождения там. На схеме вы можете видеть функцию <code>cleanup</code>, которая постоянно выполняется в фоне и проверяет, не стали ли транзакции, находящиеся в UTX, невалидными (истек срок жизни, баланс отправителя стал нулевым из-за другой транзакции и не может оплатить комиссию и т.д.) и нет ли необходимости их оттуда удалить.</p>
<p><img src="../../assets/37F7DE3C-90E8-49FD-BD5D-16779F29D3F0.jpeg" alt="UTX pool details" title="UTX pool details"></p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-6-%D1%8F%D0%B7%D1%8B%D0%BA-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-ride">Глава 6. Язык программирования Ride</h1>
<p>RIDE - это компилируемый статически типизированный функциональный язык программирования с ленивым исполнением, предназначенный для построения децентрализованных приложений. Язык создавался с целью помочь разработчикам писать код без ошибок.</p>
<p>RIDE не является Тьюринг-полным языком. В нем нет циклов (в классическом понимании), рекурсий и предусмотрено много ограничений, которые позволяют делать приложения простыми для понимания и отладки.</p>
<h2 id="%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F">История создания</h2>
<p>Основным идейным вдохновителем создания Ride является Илья Смагин. Язык изначально был нацелен на реализацию простых кейсов вроде мульти-подписи и впервые появился в Mainnet летом 2018, позволяя писать скрипты для создания смарт-аккаунтов. В январе 2019 года на Ride стало возможным писать скрипты для смарт-ассетов, а в июле 2019 уже появилась возможность писать полноценные децентрализованные приложения благодаря релизу под названием Ride4dapps.</p>
<p>Философия языка и его создателей сводится к нескольким простым правилам:</p>
<ol>
<li>Язык программирования - это инструмент для реализации конкретных кейсов. Усложнение языка и добавление новых конструкций делаются только если есть кейсы и бизнесы, которым этого не хватает.</li>
<li>Тьюринг-полнота вместе с масштабируемостью мало достижимы в рамках публичной блокчейн системы, поэтому язык должен быть удобен и без этой характеристики.</li>
<li>Ride - специфичный язык для написания децентрализованных приложений, а не язык общего назначения, поэтому в языке есть специфичные конструкции.</li>
</ol>
<p>Язык испытал большое влияение Scala и F#. Нельзя сказать, что Ride очень сильно похож на какой-то из этих языков, но людям, которые знают эти языки, будет проще начать писать на Ride. В то же время, язык прост и для разработчиков на всех других языках, первичное ознакомление с языком и инструментами занимает обычное около часа. К концу этой главы вы изучите почти весь язык и все основные конструкции.</p>
<p>Несмотря на то, что Ride прост, он дает много возможностей разработчику. Давайте перейдем к синтаксису языка.</p>
<h2 id="hello-world">Hello world</h2>
<pre class="hljs"><code><div>func say() = {
  <span class="hljs-string">"Hello world!"</span>
}
</div></code></pre>
<p>Функции объявляются с помощью <code>func</code>. Функции возвращают типы, но их не нужно объявлять, за вас это сделает компилятор. В примере выше, функция <code>say</code> вернет строку <code>&quot;Hello World!&quot;</code>. В языке нет <code>return</code>, потому что RIDE основан на выражениях (все является выражением), а последний оператор является результатом функции.</p>
<h2 id="%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD">Блокчейн</h2>
<p>RIDE предназначен для использования внутри блокчейна, и нет никакого способа получить доступ к файловой системе.</p>
<p>Функции RIDE могут считывать данные из блокчейна и возвращать транзакции в результате, которые будут записаны в блокчейн.</p>
<h2 id="%D0%BA%D0%BE%D0%BC%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%80%D0%B8%D0%B8">Комментарии</h2>
<pre class="hljs"><code><div># Это комментарий

# В языке нельзя создавать многострочные комментарии

<span class="hljs-string">"Hello world!"</span> # Можно писать комментарии и в таких местах
</div></code></pre>
<h2 id="%D0%B4%D0%B8%D1%80%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D1%8B">Директивы</h2>
<p>Каждый скрипт на Ride должен начинаться с директив для компилятора. Существует 3 возможных типа директив с различными возможными значениями.</p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">DAPP</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}
</div></code></pre>
<p><code>STDLIB_VERSION</code> задает версию стандартной библиотеки. Последняя версия в mainnet - 3, в stagenet - 4.</p>
<p><code>CONTENT_TYPE</code> задает тип файла, над которым вы работаете. На данный момент существуют типы <code>DAPP</code> и <code>EXPRESSION</code>. Тип <code>DAPP</code> позволяет объявлять функции, завершать выполнение скрипта некоторыми транзакциями (изменениями в блокчейне) и использовать аннотации, тогда как <code>EXPRESSION</code> позволяет завершать выполнение скрипта логическим выражением (<code>true</code> или <code>false</code>).</p>
<p><code>SCRIPT_TYPE</code> задает тип сущности, к которой мы хотим добавить скрипт и изменить поведение по умолчанию. Скрипты на Ride можно прикрепить к <code>ACCOUNT</code> или <code>ASSET</code>.</p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">DAPP</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ASSET</span> #-} # тип dApp нельзя использовать для <span class="hljs-type">ASSET</span>
</div></code></pre>
<p>Не все комбинации директив являются правильными. Пример выше не будет работать, ибо тип контента <code>DAPP</code> допустим только для аккаунтов, в то время как тип <code>EXPRESSION</code> доступен для токенов (ассетов) и аккаунтов.</p>
<h2 id="%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">Функции</h2>
<pre class="hljs"><code><div>func greet(name: <span class="hljs-type">String</span>) = {
  <span class="hljs-string">"Hello, "</span> + name
}

func add(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) = {
  a + b
}
</div></code></pre>
<p>Тип должен следовать за именем аргумента.</p>
<p>Как и во многих других языках, функции не могут быть перегружены. Это помогает сохранить код читаемым и простым для изменений.</p>
<p>Функции можно использовать только после их объявления.</p>
<h2 id="%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5">Переменные</h2>
<pre class="hljs"><code><div>let a = <span class="hljs-string">"Bob"</span>
let b = <span class="hljs-number">1</span>
</div></code></pre>
<p>Переменные объявляются и инициализируются с помощью ключевого слова <code>let</code>.  Это единственный способ объявить переменные в RIDE. Все переменные в RIDE являются иммутабельными. Это означает, что вы не можете изменить значение переменной после объявления.</p>
<p>Тип переменной определеляется, а если быть точнее, то выводится (type inference) исходя из значения в правой части.</p>
<p>RIDE позволяет определять переменные внутри любой функции или в глобальной области видимости.</p>
<pre class="hljs"><code><div>a = <span class="hljs-string">"Alice"</span>
</div></code></pre>
<p>Приведенный выше код не будет компилироваться, потому что переменная <code>a</code> не определена. Все переменные в Ride нужно объявлять c помощью ключевого слова <code>let</code>.</p>
<pre class="hljs"><code><div>func lazyIsGood() = {
  let a = <span class="hljs-string">"Bob"</span>
  <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>Функция выше будет скомпилирована и вернет <code>true</code> в качестве результата, но переменная <code>a</code> не будет инициализирована, потому что RIDE ленивый, это означает, что все неиспользуемые переменные не вычисляются.</p>
<pre class="hljs"><code><div>func callable() = {
  <span class="hljs-number">42</span>
}

func caller() = {
  let a = callable()
  <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>Функция <code>callable</code> также не будет вызвана, поскольку переменная <code>a</code> не используется.</p>
<p>В отличие от большинства языков, переиспользование переменных не допускается. Объявление переменной с именем, которое уже используется в родительской области видимости, приведет к ошибке компиляции.</p>
<h2 id="%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B">Базовые типы</h2>
<p>Основные базовые типы показаны ниже:</p>
<pre class="hljs"><code><div><span class="hljs-type">Boolean</span>    #   <span class="hljs-literal">true</span>
<span class="hljs-type">String</span>     #   <span class="hljs-string">"Hey"</span>
<span class="hljs-type">Int</span>        #   <span class="hljs-number">1610</span>
<span class="hljs-type">ByteVector</span> #   base58'...', base64'...', base16'...', fromBase58String(<span class="hljs-string">"..."</span>) etc.
</div></code></pre>
<h3 id="%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B8">Строки</h3>
<pre class="hljs"><code><div>let name = <span class="hljs-string">"Bob"</span>
name + <span class="hljs-string">" is cool!"</span> # строки будут соеденены, ибо используется знак +

name.indexOf(<span class="hljs-string">"o"</span>)  # <span class="hljs-number">1</span>
</div></code></pre>
<p>В RIDE строка - это массив байт, доступный только для чтения. Строковые данные кодируются с помощью UTF-8.</p>
<p>Для обозначения строк можно использовать только двойные кавычки. Строки неизменяемы, как и все другие типы. Это означает, что функция поиска подстроки в строке очень эффективна: копирование не выполняется, дополнительные выделения не требуются.</p>
<p>Все операторы в RIDE должны иметь значения одного и того же типа с обеих сторон. Код ниже не будет компилироваться, потому что <code>age</code> имеет тип <code>Int</code>, а <code>&quot;Bob is &quot;</code> является строкой:</p>
<pre class="hljs"><code><div>let age = <span class="hljs-number">21</span>
<span class="hljs-string">"Bob is "</span> + age # не будет компилироваться
</div></code></pre>
<p>Чтобы заставить код работать, мы должны преобразовать <code>age</code> в <code>String</code>:</p>
<pre class="hljs"><code><div>let age = <span class="hljs-number">21</span>
<span class="hljs-string">"Alice is "</span> + age.toString() # вот так работает!
</div></code></pre>
<h2 id="%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B">Специальные типы</h2>
<pre class="hljs"><code><div><span class="hljs-type">List</span>    # [<span class="hljs-number">16</span>, <span class="hljs-number">10</span>, <span class="hljs-string">"hello"</span>]
<span class="hljs-type">Nothing</span> #
<span class="hljs-type">Unit</span>    # unit
</div></code></pre>
<p>RIDE имеет несколько типов, которые &quot;<strong>выглядят</strong> как <s>утки</s> в Scala, плавают как <s>утки</s> в Scala и крякают как <s>утки</s> в Scala&quot;. Например, типы <code>Nothing</code> и <code>Unit</code>.</p>
<p>В RIDE нет типа <code>null</code>, как во многих других языках. Обычно, встроенные функции возвращают тип <code>Unit</code> вместо <code>null</code>.</p>
<pre class="hljs"><code><div><span class="hljs-string">"String"</span>.indexOf(<span class="hljs-string">"substring"</span>) == unit # <span class="hljs-literal">true</span>
</div></code></pre>
<h3 id="%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B8">Списки</h3>
<pre class="hljs"><code><div>let list = [<span class="hljs-number">16</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1997</span>, <span class="hljs-string">"birthday"</span>]       # коллекция может содержать различные типы данных
let second = list[<span class="hljs-number">1</span>]                        # <span class="hljs-number">10</span> - второе значение из списка

</div></code></pre>
<p>Для правильной работы со списками в RIDE, у них всегда должен быть известен размер, потому что нет циклов и рекурсий.</p>
<p><code>List</code> не имеет полей, но в стандартной библиотеке есть функции, которые позволяют работать с ними проще.</p>
<pre class="hljs"><code><div>let list = [<span class="hljs-number">16</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1997</span>, <span class="hljs-string">"birthday"</span>]

let last = list.getElement(list.size() - <span class="hljs-number">1</span>) # <span class="hljs-string">"birthday"</span>, постфиксный вызов функции size()

let lastAgain = getElement(collection, size(collection) - <span class="hljs-number">1</span>) # то же, что и выше
</div></code></pre>
<p>Функция <code>.size()</code> возвращает длину списка. Обратите внимание, что это значение только для чтения, и оно не может быть изменено.</p>
<pre class="hljs"><code><div>let initList = [<span class="hljs-number">16</span>, <span class="hljs-number">10</span>]            # init value
let newList = cons(<span class="hljs-number">1997</span>, initList) # создает новый список с элементами initLinit и новым значением - [<span class="hljs-number">1997</span>, <span class="hljs-number">16</span>, <span class="hljs-number">10</span>]
</div></code></pre>
<p>Вы можете добавить новый элемент к существующему списку с помощью функции <code>cons</code>. Изначальный список не будет изменен, <code>cons</code> вернет новый список. Нет никакого способа объединить два списка или добавить несколько значений в список.</p>
<!-- TODO: поправить про списки -->
<h3 id="union-%D1%82%D0%B8%D0%BF%D1%8B">Union-типы</h3>
<pre class="hljs"><code><div>let valueFromBlockchain = getString(<span class="hljs-string">"3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf"</span>, <span class="hljs-string">"someKey"</span>) # <span class="hljs-type">Union</span>(<span class="hljs-type">String</span> | <span class="hljs-type">Unit</span>)
</div></code></pre>
<p>Типы Union - это очень удобный способ работы с абстракциями, <code>Union(String | Unit)</code> показывает, что значение является пересечением этих типов.</p>
<p>Если бы в Ride были пользовательские типы, то можно было бы разобрать следующий пример:</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Human</span> </span>: { firstName: <span class="hljs-type">String</span>, lastName: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span>}
<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Cat</span> </span>: {name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span> }
</div></code></pre>
<p><code>Unioin(Human | Cat)</code> является объектом с одним полем <code>age</code>. Обычно <code>Union</code> возвращается в результате вызовов функций, когда в зависимости от параметров рантайм языка мог получить различные типы.</p>
<pre class="hljs"><code><div><span class="hljs-type">Human</span> | <span class="hljs-type">Cat</span> =&gt; { age: <span class="hljs-type">Int</span> }
</div></code></pre>
<p>Мы можем использовать pattern matching, чтобы выяснить настоящий тип:</p>
<pre class="hljs"><code><div>let t = ... # <span class="hljs-type">Union</span>(<span class="hljs-type">Cat</span> | <span class="hljs-type">Human</span>)
let age = t.age                    # <span class="hljs-type">OK</span>
let name = t.name                    # <span class="hljs-type">Compiler</span> error
let name = <span class="hljs-keyword">match</span> t {            # <span class="hljs-type">OK</span>
  <span class="hljs-keyword">case</span> h: <span class="hljs-type">Human</span> =&gt; h.firstName
  <span class="hljs-keyword">case</span> c: <span class="hljs-type">Cat</span>   =&gt; c.name
}
</div></code></pre>
<p>Например, функция <code>getString</code> для чтения строк из хранища аккаунта возвращает <code>Union(String | Unit)</code> потому что некоторые ключи (и их значения соответсвенно) могут не существовать.</p>
<pre class="hljs"><code><div>let valueFromBlockchain = getString(<span class="hljs-string">"3PHHD7dsVqBFnZfUuDPLwbayJiQudQJ9Ngf"</span>, <span class="hljs-string">"someKey"</span>)
let realStringValue = valueFromBlockchain.extract()

# or
let realStringValue2 = getStringValue(<span class="hljs-keyword">this</span>, <span class="hljs-string">"someKey"</span>)
</div></code></pre>
<p>Чтобы получить реальный тип и значение от Union, можно использовать не только pattern matching, но и функцию <code>extract</code>, которая прервет скрипт в случае значения <code>Unit</code>. Другой вариант заключается в использовании специализированных функций, таких как <code>getStringValue</code>, <code>getIntegerValue</code> и др., чье поведение будет идентичным (ошибка если значения нет в хранилище или по заданному ключу хранится другой тип данных).</p>
<h2 id="if">If</h2>
<pre class="hljs"><code><div>let amount = <span class="hljs-number">1610</span>
<span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">42</span>) then <span class="hljs-string">"I claim that amount is bigger than 42"</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">100500</span>) then <span class="hljs-string">"Too big!"</span>
  <span class="hljs-keyword">else</span> <span class="hljs-string">"I claim something else"</span>
</div></code></pre>
<p><code>if</code> операторы довольно просты и похожи на большинство других языков, за исключением двух отличий: <code>if</code> может использоваться как выражение (результат присваивается переменной) и ветвь <code>else</code> всегда обязательна.</p>
<pre class="hljs"><code><div>let a = <span class="hljs-number">16</span>
let result = <span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) then a / <span class="hljs-number">10</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span> #
</div></code></pre>
<h2 id="pattern-matching">Pattern matching</h2>
<pre class="hljs"><code><div>let readOrInit = <span class="hljs-keyword">match</span> getInteger(<span class="hljs-keyword">this</span>, <span class="hljs-string">"someKey"</span>) {
    <span class="hljs-keyword">case</span> a:<span class="hljs-type">Int</span> =&gt; a
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">0</span>
}
</div></code></pre>
<p>Pattern matching - это механизм проверки значения по образцу. RIDE позволяет использовать pattern matching только для предопределенных типов.</p>
<p>Pattern matching в RIDE выглядит так же, как в Scala, но единственным вариантом использования сейчас является получение реального типа от переменной с типом <code>Union</code>. Pattern matching может быть полезен, когда в результате вызова переменной мы можем получить значение с типом <code>Union(Int | Unit)</code> или даже бывает такое <code>Union(Order | ReissueTransaction | BurnTransaction | MassTransferTransaction | ExchangeTransaction | TransferTransaction | SetAssetScriptTransaction | InvokeScriptTransaction | IssueTransaction | LeaseTransaction | LeaseCancelTransaction | CreateAliasTransaction | SetScriptTransaction | SponsorFeeTransaction | DataTransaction)</code>.</p>
<pre class="hljs"><code><div>let amount = <span class="hljs-keyword">match</span> tx { # tx - текущий объект исходящей транзакции в глобальной области видимости для смарт аккаунта
  <span class="hljs-keyword">case</span> t: <span class="hljs-type">TransferTransaction</span> =&gt; t.amount
  <span class="hljs-keyword">case</span> m: <span class="hljs-type">MassTransferTransaction</span> =&gt; m.totalAmount
  <span class="hljs-keyword">case</span> i: <span class="hljs-type">InvokeScriptTransaction</span> =&gt; <span class="hljs-keyword">if</span> (i.payment) i.payment.extract().amount <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">0</span>
}
</div></code></pre>
<p>Приведенный выше код показывает пример использования pattern matching, когда мы хотим получить количество передаваемых токенов в текущей транзакции от заданного аккаунта. В зависимости от типа транзакции, реальное количество передаваемых токенов может храниться в разных полях. Если транзакция типа <code>TransferTransaction</code>, <code>MassTransferTransaction</code> или <code>InvokeScriptTransaction</code>, мы возьмем правильное поле, во всех остальных случаях мы получим 0.</p>
<h2 id="%D1%87%D0%B8%D1%81%D1%82%D1%8B%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-pure-functions">Чистые функции (pure functions)</h2>
<p>Функции RIDE являются чистыми (pure) по умолчанию, что означает, что их возвращаемые значения определяются только их аргументами, и их оценка не имеет побочных эффектов. Честно говоря, относительно &quot;чистоты&quot; функций в Ride было огромное количество споров среди самих разработчиков Ride. Дело в том, что в Ride есть одна переменная в глобальной области видимости - <code>height</code>, которая хранит текущую высоту блокчейна (номер текущего блока, в который попадает данная транзакция). В теории, результат функции зависит не только ее параметров, но и от окружения (этой переменной <code>height</code>), поэтому некоторые скажут, что функции &quot;не полностью чистые&quot; или даже &quot;не чистые совсем&quot;.</p>
<p>В любом случае, RIDE не является чистым функциональным языком, поскольку также существует функция <code>throw ()</code>, которая завершает выполнение скрипта в любой момент. То есть функция может не завершиться вовсе, а не просто завершиться с ошибкой, поэтому все-таки полностью функциональным язык назвать не получится.</p>
<pre class="hljs"><code><div>let a = getInteger(<span class="hljs-keyword">this</span>, <span class="hljs-string">"key"</span>).extract()
<span class="hljs-keyword">throw</span>(<span class="hljs-string">"I will terminate it!"</span>)
let result = <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> then
  <span class="hljs-string">"a is negative"</span>
<span class="hljs-keyword">else</span>
  <span class="hljs-string">"a is positive or 0"</span>
</div></code></pre>
<p>В приведенном выше примере скрипт завершится на строке 2 с сообщением <code>I will terminate it!</code> и никогда не достигнет выражения <code>if</code>.</p>
<h2 id="%D0%B0%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8--%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B-%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0">Аннотации / модификаторы доступа</h2>
<p>Функции могут быть определены только в скрипте с помощью <code>{-# CONTENT_TYPE DAPP #-}</code>. Они могут быть без аннотаций, либо с аннотациями <code>@Callable</code> или <code>@Verifier</code>.</p>
<pre class="hljs"><code><div>func getPayment(i: <span class="hljs-type">Invocation</span>) = {
  let pmt = extract(i.payment)
  <span class="hljs-keyword">if</span> (isDefined(pmt.assetId)) then
    <span class="hljs-keyword">throw</span>(<span class="hljs-string">"This function accetps waves tokens only"</span>)
  <span class="hljs-keyword">else</span>
    pmt.amount
}

<span class="hljs-meta">@Callable</span>(i)
func pay() = {
  let amount = getPayment(i)
  <span class="hljs-type">WriteSet</span>([<span class="hljs-type">DataEntry</span>(i.caller.bytes, amount)])
}
</div></code></pre>
<p>Функции с аннотацией <code>@Callable</code> могут быть вызваны извне блокчейна. Для вызова вызываемых функций необходимо отправить <code>InvokeScript</code> транзакцию.</p>
<p>Аннотации могут &quot;привязывать&quot; некоторые значения к функции. В приведенном выше примере переменная <code>i</code> была привязана к функции <code>pay</code> и хранила всю информацию о факте вызова (публичный ключ, адрес, платеж, прикрепленный к транзакции, комиссию, id транзакции и т.д.).</p>
<p>Функции без аннотаций <strong>не</strong> могут быть вызваны &quot;извне&quot;, только сам скрипт может их вызывать. То есть <code>Callable</code> или <code>Verifier</code> функция начитают выполнение, в ходе которого могут вызвать функцию без аннотации.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Verifier</span>(tx)
func verifier() = {
  <span class="hljs-keyword">match</span> tx {
    <span class="hljs-keyword">case</span> m: <span class="hljs-type">TransferTransaction</span> =&gt; tx.amount &lt;= <span class="hljs-number">100</span> # можно отправить не больше <span class="hljs-number">100</span> токенов
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>
  }
}
</div></code></pre>
<p>Функции с аннотацией <code>@Verifier</code> устанавливают правила для исходящих транзакций децентрализованного приложения (dApp) или смарт-аккаунта. Функции верификатора нельзя вызывать извне, но они выполняются каждый раз, когда предпринимается попытка отправить транзакцию с этого аккаунта.</p>
<p>Функции верификатора должны всегда возвращать значение <code>Boolean</code> в качестве результата, в зависимости от этого транзакция попадет в блокчейн или нет.</p>
<p>Функция верификатора использует переменную <code>tx</code>, которая является объектом со всеми полями текущей исходящей (и проверяемой) транзакции.</p>
<p>В одном скрипте может быть определена только одна функция-верификатор с аннотацией <code>@Verifier</code>.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func callMeMaybe() = {
  let randomValue = getRandomValue()
  [<span class="hljs-type">IntegerEntry</span>(<span class="hljs-string">"key"</span>, randomValue)]
}

func getRandomValue() = {
  <span class="hljs-number">16101997</span> # достаточно рандомное число
}
</div></code></pre>
<p>Этот код не будет компилироваться, потому что функции <strong>без</strong> аннотаций должны быть определены <strong>перед</strong> функциями с аннотациями.</p>
<h3 id="%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Предопределенные структуры данных</h3>
<p>RIDE имеет много предопределенных специфических структур данных для Waves Blockchain, таких как: <code>Address</code>, <code>Alias</code>, <code>IntegerEngry</code>, <code>StringEntry</code>, <code>Invocation</code>, <code>ScriptTransfer</code>, <code>AssetInfo</code>, <code>BlockInfo</code> и тд.</p>
<pre class="hljs"><code><div>let keyValuePair = <span class="hljs-type">StringEntry</span>(<span class="hljs-string">"someKey"</span>, <span class="hljs-string">"someStringValue"</span>)
</div></code></pre>
<p><code>StringEntry</code> это структура данных, которая описывает пару ключ-значение, как в хранилище аккаунта, где значением является строка.</p>
<pre class="hljs"><code><div>let <span class="hljs-type">ScriptTransfer</span> = <span class="hljs-type">ScriptTransfer</span>(<span class="hljs-string">"3P23fi1qfVw6RVDn4CH2a5nNouEtWNQ4THs"</span>, amount, unit)
</div></code></pre>
<p>Все встроенные структуры данных могут быть использованы для проверки типов и pattern matching.</p>
<h2 id="%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F">Результат выполнения</h2>
<pre class="hljs"><code><div><span class="hljs-meta">@Verifier</span>(tx)
func verifier() = {
  <span class="hljs-string">"Returning some string"</span>
}
</div></code></pre>
<p>Expression-скрипты (с директивой <code>{-# CONTENT_TYPE EXPRESSION #-}</code>) наряду с функциями <code>@Verifier</code> должны всегда возвращать логическое выражение. В зависимости от этого значения транзакция будет принята (в случае <code>true</code>) или отклонена (в случае <code>false</code>) блокчейном.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func giveAway(age: <span class="hljs-type">Int</span>) = {

  let callerAddress = i.caller
  let reissuable = <span class="hljs-literal">false</span>
  let assetScript = <span class="hljs-type">Unit</span>
  let decimals = <span class="hljs-number">0</span>
  let amount = <span class="hljs-number">100</span>
  let nonce = <span class="hljs-number">0</span>
  let newAsset = <span class="hljs-type">Issue</span>(assetScript, decimals, <span class="hljs-string">"Description here"</span>, reissuable, <span class="hljs-string">"MyCoolToken"</span>, amount, nonce)


  [
    <span class="hljs-type">ScriptTransfer</span>(callerAddress, age, unit),
    <span class="hljs-type">IntegerEntry</span>(<span class="hljs-string">"ageof_"</span> + callerAddress.toBase58String(), age),
    <span class="hljs-type">BooleanEntry</span>(<span class="hljs-string">"booleanKey"</span>, <span class="hljs-literal">true</span>),
    <span class="hljs-type">StringEntry</span>(<span class="hljs-string">"stringKey"</span>, <span class="hljs-string">"somevalue"</span>),
    <span class="hljs-type">BinaryEntry</span>(<span class="hljs-string">"binaryKey"</span>, base58<span class="hljs-symbol">'3</span>P'),
    <span class="hljs-type">DeleteEntry</span>(<span class="hljs-string">"ScriptTransfer(i.caller, 100, newAsset.calculateAssetId()),"</span>),
    newAsset,
    <span class="hljs-type">ScriptTransfer</span>(i.caller, <span class="hljs-number">100</span>, newAsset.calculateAssetId()),
    <span class="hljs-type">Reissue</span>(base58<span class="hljs-symbol">'81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9</span>W', reissuable, amount),
    <span class="hljs-type">Burn</span>(base58<span class="hljs-symbol">'81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9</span>W', amount)
  ]
}
</div></code></pre>
<p>Каждый, кто вызовет функцию <code>giveAway</code> получит столько Waves, сколько ему лет (количество лет сам пользователь передает в виде аргумента), и dApp будет хранить информацию о факте передачи в своем стейте, кроме этого скрипт запишет в хранилище данного децентрализованного приложения несколько пар ключ-значений (буловое значение, массив байт, строку) и удалит целиком пару с ключом <code>deleteKey</code>. Скрипт так же выпустит новый токен с названием <code>MyCoolToken</code>, отправит 100 таких токенов вызывающему аккаунту, довыпустит 100 токенов с <code>assetId</code> равным <code>81hNyHLFU7Z7PRUeKAfGVPca5CMmFWTxLByHcNAS8i9W</code> и сожжет 100 токенов с таким же <code>assetId</code>.</p>
<p><code>@Callable</code> функции могут заканчиваться 5 типами изменений блокчейна:</p>
<ol>
<li>Изменение состояния key-value хранилища, в том числе добавление и удаление пар</li>
<li>Выпуск токенов</li>
<li>Перевыпуск токенов</li>
<li>Передача токенов</li>
<li>Сжигание токенов</li>
</ol>
<p>Каждый результирующий Issue увеличивает комиссию за вызов такой функции на 1 Waves (если выпускается не NFT токен).</p>
<p>Результирующий массив может содержать до 100 изменений данных в хранилище и 10 операций с токенами (выпуск, сожжение, отправка, перевыпуск).</p>
<h2 id="%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D1%8F">Исключения</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">throw</span>(<span class="hljs-string">"Here is exception text"</span>)
</div></code></pre>
<p><code>throw</code> функция немедленно завершит выполнение скрипта с предоставленным текстом. Нет никаких способов поймать брошенные исключения.</p>
<p>Основная идея <code>throw</code> заключается в том, чтобы остановить выполнение и отправить пользователю информативную обратную связь.</p>
<pre class="hljs"><code><div>let a = <span class="hljs-number">12</span>
<span class="hljs-keyword">if</span> (a != <span class="hljs-number">100</span>) then <span class="hljs-keyword">throw</span> (<span class="hljs-string">"a is not 100, actual value is "</span> + a.toString())
<span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span>(<span class="hljs-string">"A is 100"</span>)
</div></code></pre>
<p><code>throw</code> функция может быть использована для отладки кода при разработке dApps, так как дебаггера для Ride пока не существует.</p>
<h2 id="%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82-%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F">Контекст выполнения</h2>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}

let a = <span class="hljs-keyword">this</span> # Адрес текущего аккаунта
a == <span class="hljs-type">Address</span>(base58<span class="hljs-symbol">'3P9DEDP5VbyXQyKtXDUt2crRPn5B7gs6uj</span>c') # <span class="hljs-literal">true</span> если скрипт выполняется на аккаунте с определенным адресом
</div></code></pre>
<p>RIDE скрипты в блокчейне waves могут быть привязаны к аккаунтам и токенам (директивой <code>{-# SCRIPT_TYPE ACCOUNT | ASSET #-}</code>), и в зависимости от <code>SCRIPT_TYPE</code> ключевое слово <code>this</code> может ссылаться на различные сущности. Для типа скрипта <code>ACCOUNT</code>, <code>this</code> это <code>Address</code></p>
<p>Для типа <code>ASSET</code>, <code>this</code> это тип <code>AssetInfo</code></p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ASSET</span> #-}

let a = <span class="hljs-keyword">this</span> # <span class="hljs-type">AssetInfo</span> для текущего токена, с которым совершается операция
a == assetInfo(base58<span class="hljs-symbol">'5fmWxmtrqiMp7pQjkCZG96KhctFHm9rJkMbq2QbveAH</span>R') # <span class="hljs-literal">true</span> если скрипт выполняется для ассета с указанным <span class="hljs-type">ID</span>
</div></code></pre>
<h2 id="%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81-foldn">Макрос FOLD<N></h2>
<p>Отсутствие Тьюринг полноты (об этом мы поговорим подробнее чуть позже) не позволяет в Ride иметь полноценные циклы, однако в языке есть макрос <code>FOLD</code>, который позволяет выполнять указанную функцию несколько раз и &quot;собрать&quot; результат в одну переменную.</p>
<pre class="hljs"><code><div>func sum(acc:<span class="hljs-type">Int</span>, el:<span class="hljs-type">Int</span>) = acc + el
let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
let sum = <span class="hljs-type">FOLD</span>&lt;<span class="hljs-number">5</span>&gt;(arr, <span class="hljs-number">0</span>, sum) # result: <span class="hljs-number">15</span>
</div></code></pre>
<p>Параметр в угловых скобках (5 в примере выше) задает сколько максимум раз будет вызвана функция <code>sum</code>. Каждый новый вызов будет передавать в качестве аргумента следующий элемент массива <code>arr</code>. Второй параметр макроса <code>FOLD</code> задает начальное значение. Функция <code>sum</code> принимает 2 аргумента:</p>
<ul>
<li><code>acc</code> - cумма с предыдущего шага</li>
<li><code>el</code> - следующий элемент массива</li>
</ul>
<p><code>sum</code> будет вызываться со следующими параметрами:</p>
<pre class="hljs"><code><div>sum(0, 1)  # 1
sum(1, 2)  # 3
sum(3, 3)  # 6
sum(6, 4)  # 10
sum(10, 5) # 15
</div></code></pre>
<p><code>FOLD&lt;N&gt;</code> является макросом, то есть синтаксическим сахаром. Интерпретатор Ride ничего не знает про <code>FOLD</code>, потому что в момент компиляции <code>FOLD</code> превращается в подобный код:</p>
<pre class="hljs"><code><div>let result = {
   let size = arr.size()
   <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) then acc0 <span class="hljs-keyword">else</span> {
      let acc1 = function(acc0, arr[<span class="hljs-number">0</span>])
      <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>) then acc1 <span class="hljs-keyword">else</span> {
         let acc2 = function(acc1, arr[<span class="hljs-number">1</span>])
         <span class="hljs-keyword">if</span>(size == <span class="hljs-number">2</span>) then acc2 <span class="hljs-keyword">else</span> {
            let acc3 = function(acc2, arr[<span class="hljs-number">2</span>])
            <span class="hljs-keyword">if</span>(size == <span class="hljs-number">3</span>) then acc3 <span class="hljs-keyword">else</span> {
               let acc4 = function(acc3, arr[<span class="hljs-number">3</span>])
               <span class="hljs-keyword">if</span>(size == <span class="hljs-number">4</span>) then acc4 <span class="hljs-keyword">else</span> {
                  let acc5 = function(acc4, arr[<span class="hljs-number">4</span>])
                  <span class="hljs-keyword">if</span>(size == <span class="hljs-number">5</span>)
                     then acc5
                     <span class="hljs-keyword">else</span>
                       <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Too big array, max 5 elements"</span>)
}}}}}}
</div></code></pre>
<p>Выглядит намного хуже, чем <code>FOLD&lt;N&gt;</code>. Параметр <code>N</code> всегда должен являться целым числом выше 0 и является обязательным. То есть, разработчик должен знать максимальный размер списка, который будет обрабатываться с помощью <code>FOLD</code>.</p>
<p>Если в <code>FOLD&lt;N&gt;</code> передать массив размерностью больше, чем <code>N</code>, то будет выброшено исключение.</p>
<p>Не все операции, возможные с другими циклами, можно реализовать с помощью <code>FOLD</code>.</p>
<h2 id="%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">Процесс разработки</h2>
<p>Разработка любого приложения начинается с идеи, и децентрализованные приложения тут не исключения, однако, когда дело доходит до кода, хорошо бы иметь четкую последовательность шагов, как реализованную в коде идею запустить и дать на суд ощественности. В случае с децентрализованными приложениями на Ride, полный жизненный цикл выглядит следующим образом:</p>
<ol>
<li>Написанный код на Ride компилируется в base64 представление. Скомпилированный вариант скрипта может содержать мета информацию о скрипте (например, типы аргументов <code>@Callable</code> функций стираются во время компиляции, но могут быть сохранены как мета информация). Существует 2 компилятора для Ride - на JavaScript и на Scala. Скомпилировать код можно с помощью разных инструментов - онлайн IDE, REST API ноды, библиотеки <code>surfboard</code> или <code>ride-js</code>, расширение для Visual Studio Code. Об этих инструментах мы поговорим чуть позже в этом разделе.</li>
<li>Скомпилированный скрипт отправляется в блокчейн в составе транзакции - <code>SetAssetScript</code> или <code>Issue</code> для смарт-ассетов, <code>SetScript</code> для смарт-аккаунтов и децентрализованных приложений или. Все эти транзакции имеют поле <code>script</code>, который принимает скомпилированный код в <code>base64</code> представлении.</li>
<li>После попадания транзакции со скриптом в блок, поведение аккаунта или ассета меняется в соответствии с тем, что написано в коде.</li>
<li>В случае со смарт-ассетами, смарт-аккаунтами и функциями <code>@Verifier</code>, код контракта будет исполняться каждый раз, когда аккаунт со скриптом отправляет транзакцию или совершается транзакция с токеном со скриптом.</li>
<li>В случае с <code>@Callable</code> функциями, их выполнение начинается в тот момент, когда любой пользователь вызывает функцию с помощью <code>InvokeScript</code> транзакции.</li>
<li>Обновление скрипта на новый возможно и для токенов и для аккаунтов в том случае, когда это не запрещено кодом установленного скрипта.</li>
</ol>
<h1 id="%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D1%81%D0%BC%D0%B0%D1%80%D1%82-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-waves">Особенности смарт-контрактов в Waves</h1>
<p>Смарт-контракты и децентрализованные приложения в Waves отличаются от таковых в Ethereum и многих других блокчейнах. Давайте рассмотрим основные отличия и их причины.</p>
<h2 id="%D0%BF%D0%BE%D0%B4%D1%81%D1%87%D0%B5%D1%82-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8">Подсчет сложности</h2>
<p>Все функции и операции в Ride, в том числе операции сложения, вычитания, деления, ветвления, а так же функции стандартной библиотеки имеют сложность. Сложность каждой операции выражается в условных единицах (назовем <code>complexity</code>, иначе придется называть <code>попугаи</code>). Например, операция сложения имеет complexity 1, а функция проверки подписи <code>sigVerify()</code> имеет complexity 200.</p>
<p>Так как в каждом скрипте есть много вариантов исполнения из-за ветвлений, то <code>complexity</code> скрипта считается как сложность самой сложной ветки. Если вы используете, например, online IDE, то он будет показывать сложность скрипта в режиме реального времени.</p>
<p>В Ride есть ограничение на максимальную сложность скрипта, и она разная для разных типов функций. Для функций <code>@Verifier</code>, смарт-аккаунтов и смарт-ассетов максимальная сложность скрипта составляет 3000 единиц, а для функций <code>@Callable</code> наиболее сложная ветка может иметь 4000 единиц. В отличие от других языков смарт-контрактов, например, Solidity в Ethereum, сложность скрипта всегда известна заранее, так как отсутствует Тьюринг-полнота. В случае Ethereum, довольно часто бывает, что мы используем цикл в коде, но не знаем сколько итераций будет в этом цикле в момент исполнения (код может читать коллекцию произвольной длины и итерировать по ней). Другой возможный в Ethereum сценарий - использование рекурсии. В Ride и Waves такое невозможно, так как отсутсвуют полноценные циклы - макрос <code>FOLD</code> заранее ограничивает максимальное количество исполнений, а рекурсий как таковых просто нет.</p>
<p>Заранее известная сложность избавляет от такой проблемы в Ethereum как <code>Out of gas</code>. Все, кто писал смарт-контракты и делал децентрализованные приложения на Solidity сталкивались с такой ситуацией, когда транзакция стала невалидной из-за того, что &quot;закончился газ&quot;. В Waves такая ситуация попросту невозможна.</p>
<p>Кроме ограничения по максимальной сложности контракта, так же есть ограничение на максимальный размер контракта, на момент написания оно составляет 32 кб. То есть код децентрализованного приложения не может быть больше 32 кб.</p>
<h2 id="%D0%BE%D1%82%D1%81%D1%83%D1%82%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D1%82%D1%8C%D1%8E%D1%80%D0%B8%D0%BD%D0%B3-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D1%8B">Отсутствие Тьюринг полноты</h2>
<p>Ride является <em>не</em> Тьюринг полным языком, но не потому, что сделать Тьюринг полноту сложно или долго, а потому что у такого подхода есть свои плюсы. Блокчейн является не самой высокопроизводительной системой, ведь все транзакции выполняется на каждой ноде, а на сетевые коммуникации уходит большое количество ресурсов. Есть различные подходы к масштабированию, например, шардинг, создание сайдчейнов и тд, но все они являются копромиссами - при увеличении пропускной способности всегда страдает уровень децентрализации или безопасность. Именно это утверждает блокчейн трилемма. Из 3 характеристик блокчейн - децентрализации, скорости и безопасности, полностью обеспечить можно только 2. Или другими словами, необходимо выбирать одну грань у треугольника:</p>
<p><img src="../../assets/6-2-1-the-blockchain-trilemma.jpeg" alt="The blockchain trilemma" title="The blockchain trilemma"></p>
<p>Как вы возможно помните, в ценностях Waves всегда быть максимально дружелюбной платформой для разработчиков и пользователей, поэтому скорость работы не должна быть узким местом, но в то же время блокчейн Waves не позволит делать десятки тысяч транзакций в секунду, так как блокчейн должен оставаться безопасным и децентрализованным.</p>
<p>Отсутствие Тьюринг-полноты позволяет Waves предлагать оптимальное сочетание этих 3 характеристик:</p>
<ol>
<li>Из-за отсутствия сложных скриптов, нода Waves может быть запущена на виртуальной машине за $40 в любом публичном облаке, что способствует децентрализации</li>
<li>Простота скриптов так же позволяет блокчейну иметь достаточную пропускную способность, чтобы даже при среднесуточном количестве транзакций в <a href="http://dev.pywaves.org/txs/">100 000</a>, не было конкуренции за попадание в блок и, соответственно, высоких комиссий.</li>
<li>Отсутствие Тьюринг-полноты делает смарт-контракты безопаснее. Ride является в какой-то мере DSL (domain specific language) или предметно-ориентированным языком, а не языком общего назначения, и именно DSL применяются в сферах, где требуется максимальная безопасность. Подробнее про это я рассказывал на одной из конференций в Сан-Франциско, с записью выступления вы можете ознакомиться <a href="https://www.youtube.com/watch?v=gMcif_ADWak">здесь</a>.</li>
</ol>
<p>Таким образом, отсутствие Тьюринг-полноты несет в себе массу преимуществ, однако, это влияет на опыт разработки, давайте рассмотрим каким именно образом.</p>
<h2 id="%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B8%D1%8F-%D0%BE%D1%82%D1%81%D1%83%D1%82%D1%81%D1%82%D0%B2%D0%B8%D1%8F-%D1%82%D1%8C%D1%8E%D1%80%D0%B8%D0%BD%D0%B3-%D0%BF%D0%BE%D0%BB%D0%BD%D0%BE%D1%82%D1%8B">Последствия отсутствия Тьюринг полноты</h2>
<p>Отсуствие Тьюринг полноты иногда не позволяет реализовать весь необходимый функционал в рамках одной функции, поэтому часто в Waves приходится разбивать логику децентрализованного приложения на несколько функций и последовательно вызывать их с помощью нескольких <code>InvokeScript</code> транзакций. Например, одно из самых сложных приложений в сети Waves - стейблкоин <a href="https://neutrino.at">Neutrino</a> состоит из 5 контрактов.</p>
<p>Контракты не могут напрямую вызывать друг друга (как в Ethereum), но они могут общаться друг с другом благодаря сохранению данных и промежуточных состояний в key-value хранилища. Любой контракт может читать хранилище любого другого контракта или аккаунта, поэтому логика обработки сложных вычислений часто представляет из себя следующее:</p>
<ol>
<li>Функция 1 децентрализованного приложения A вызывается с помощью <code>InvokeScript</code> транзакции, результат выполнения записывается в хранилище аккаунта A.</li>
<li>Функция 1 децентрализованного приложения B, вызванная с помощью <code>InvokeScript</code> транзакции, читает данные, записыванные в хранилище приложения А и использует для вычисления своего результата.</li>
</ol>
<p>Возможность чтения состояния хранилища другого аккаунта в Waves является мощнейшим инструментом, позволяющим композировать логику, строить приложения, которые опираются на другие, уже существующие.</p>
<h2 id="%D0%BE%D1%81%D0%BE%D0%B1%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-utx">Особенности обработки UTX</h2>
<p>В разделе 5 мы разбирали как именно происходит сортировка транзакций в UTX пуле, однако в тот момент мы опустили некоторые детали. Сейчас, когда вы знакомы с концепцией сложности скрипта, давайте разберемся во всех деталях.</p>
<p>Как мы уже говорили, сортировка транзакций в очереди на попадание в блок происходит по размеру комисси на 1 байт транзакции, однако есть и второй параметр, который необходимо учитывать - сложность исполнения скрипта. Задача майнера в том, чтобы максимизировать прибыль, получаемую с комиссий, поэтому майнеру может быть не выгодно валидировать транзакции со скриптом и тратить на них драгоценное время, когда можно положить в блок много транзакций без скрипта, просто проверив подпись. В данный момент <code>complexity</code> никак не учитывается при сортироке транзакций в UTX, однако, в дальнейшем такой параметр обязательно должен появиться.</p>
<p>В блокчейне Waves есть несколько параметров, которые ограничивают размеры блока, то есть, косвенно ограничивают максимальную пропускную способность:</p>
<ul>
<li>до 1 мегабайта транзакций в блоке (около 6000 транзакций)</li>
<li>ограничение на максимальную суммарную сложность скриптов в блоке равна 1 000 000 (не более 250 транзакций вызова скрипта с максимальной сложностью). При достижении этого лимита в блок будут укладываться только транзакции, не связанные с исполнением скриптов, и ровно до тех пор, пока не будет достигнут лимит по размеру в 1 мегабайт.</li>
</ul>
<p>Важно понимать, что эти параметры могут быть пересмотрены в будущем, если это будет необходимо для обслуживания всех пользователей. Однако это приведет к возрастанию системных требований к нодам.</p>
<h1 id="%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%B0%D1%8F-%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B0-ride">Стандартная библиотека Ride</h1>
<p>Стандартная библиотека Ride включается себя относительно небольшой набор функций, многие из которых связаны с криптографией (хэш функции, функции проверки подписей и т.д.). Давайте рассмотрим самые часто используемые и какие особенности есть у этих функций.</p>
<p>Первые версии Ride были предназначены для таких простых смарт-аккаунтов как мультиподпись, замораживания средств и работа с эскроу, поэтому стандартная библиотека была минимальной. Давайте разберем базовый пример смарт-контракта - мультиподпись.</p>
<h2 id="%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C-2-%D0%B8%D0%B7-3">Мультиподпись 2 из 3</h2>
<p>Основная идея мультиподписи 2 из 3 в том, что на каком-то аккаунте мы аккумулируем средства, которыми управляют 3 других аккаунта. Решение о переводе средств с аккаунта со средствами может быть принято при условии согласия хотя бы 2 управляющих аккаунтов. Согласение в терминах блокчейна и криптографии обозначает наличие подписи от заданных публичных ключей. Допустим, Alice, Bob и Cooper управляют аккаунтом с мультиподписью и только при наличии подписи хотя бы 2 из них, средства с аккаунта могут быть переведены.</p>
<p>Первое, что нам необходимо сделать - заранее определить 3 публичных ключа, которые могут подписывать транзакции с аккаунта со средствами. Публичные ключи представляю из себя массивы байт, которые могут быть представлены в Ride 3 видами примитивов - <code>base16''</code>, <code>base58''</code>, <code>base64''</code>. Cтандартным представлением для ключей является <code>base58''</code>.</p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}

<span class="hljs-meta">@Verifier</span>(tx)
func verify() = {
    #define public keys
    let alicePubKey  = base58<span class="hljs-symbol">'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpM</span>M'
    let bobPubKey    = base58<span class="hljs-symbol">'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VD</span>F'
    let cooperPubKey = base58<span class="hljs-symbol">'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5c</span>D'
    <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>Обратите внимание, что в результате функции будет возвращено значение <code>true</code>, которое будет разрешать все транзакции с этого аккаунта, без каких бы то ни было подписей. Но не пугайтесь, это промежуточное состояние нашего скрипта, а <code>true</code> (или <code>false</code>) в виде возвращаемого значения необходимо, чтобы онлайн IDE не показывало нам ошибку компиляции скрипта. Продолжим реализацию нашего скрипта мультиподписи.</p>
<p>В стандартной библиотеке Ride есть функция <code>sigVerify</code>, которая позволяет проверить подпись сообщения. Она принимает 3 аргумента:</p>
<ul>
<li>сообщение</li>
<li>подпись</li>
<li>публичный ключ</li>
</ul>
<p>И возвращает булевое значение (<code>true</code> - если подпись соответствует публичному ключу и сообщению, <code>false</code> в ином случае).</p>
<p>Публичные ключи в нашем примере уже объявлены, осталось найти еще 2 аргумента - сообщение и подписи транзакций. У объекта текущей исходящей транзакции <code>tx</code> есть поле <code>bodyBytes</code>, которое содержит подписываемое сообщение. Также у объекта <code>tx</code> есть поле <code>proofs</code>, которое содержит подписи транзакций в виде списка. Простейшая проверка подписи сообщения будет выглядет следующим образом:</p>
<pre class="hljs"><code><div>    sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], base58<span class="hljs-symbol">'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpM</span>M')
</div></code></pre>
<p>Проверка подписей для Alice, Bob и Cooper может выглядеть следующим образом:</p>
<pre class="hljs"><code><div>    (sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], alicePubKey) &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">1</span>], bobPubKey))
    ||
    (sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], alicePubKey) &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">2</span>], cooperPubKey))
    ||
    (sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">1</span>], bobPubKey) &amp;&amp; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">2</span>], cooperPubKey))
</div></code></pre>
<p>Однако более изящным способом является проверка подписи и запись в переменную 1 или 0 в зависимости от результата. Сложив эти 3 переменные и сравнив убедившись, что она больше 2, мы можем быть уверены, что как минимум 2 подписи были корректными.</p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}

<span class="hljs-meta">@Verifier</span>(tx)
func verify() = {
    #define public keys
    let alicePubKey  = base58<span class="hljs-symbol">'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpM</span>M'
    let bobPubKey    = base58<span class="hljs-symbol">'2KwU4vzdgPmKyf7q354H9kSyX9NZjNiq4qbnH2wi2VD</span>F'
    let cooperPubKey = base58<span class="hljs-symbol">'GbrUeGaBfmyFJjSQb9Z8uTCej5GzjXfRDVGJGrmgt5c</span>D'

    #check whoever provided the valid proof
    let aliceSigned  = <span class="hljs-keyword">if</span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], alicePubKey  )) then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
    let bobSigned    = <span class="hljs-keyword">if</span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">1</span>], bobPubKey    )) then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>
    let cooperSigned = <span class="hljs-keyword">if</span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">2</span>], cooperPubKey )) then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>

    #sum up every valid proof to get at least <span class="hljs-number">2</span>
    aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number">2</span>

}
</div></code></pre>
<p>Массив <code>proofs</code> всегда длиной 8, однако, в этом массиве значения могут отсуствовать в любом месте. То есть, при отправке транзакции, подписи могут лежать как в первых 3 полях массива, так и в последних трех или под индексами 1, 4 и 5. В следующем разделе мы рассмотрим как использовать <code>FOLD&lt;N&gt;</code>, чтобы не подразумевать наличие ключей в каких-то полях, а проверять все варианты.</p>
<p>Кроме функции проверки подписи <code>sigVerify</code> существует функция проверки <code>RSA</code> - <code>rsaVerify</code>. <code>SigVerify</code> которая работает с подписью для кривой Curve25519 (ED25519 c X25519 ключами, в дальнейшем для простоты будем называть &quot;подпись Waves&quot;). Подпись <code>RSA</code> отличается детерменированностью, другими словами, для одного и того же сообщения и приватного ключа может быть неограниченное количество валидных подписей Waves и только одна подпись <code>RSA</code>.</p>
<h2 id="zk-snarks">zk-SNARKs</h2>
<p>В Ride еще одна функция верификации данных - <code>groth16Verify</code>. Эта функция предназначаена для верификации <a href="https://en.wikipedia.org/wiki/Non-interactive_zero-knowledge_proof">доказательств с нулевым разграшелением</a>. Цель доказательств с нулевым разглашением заключается в том, чтобы проверяющий мог удостовериться в том, что проверяемый обладает знанием секретного параметра, называемого свидетельством, удовлетворяющим некоторым отношениям, не раскрывая свидетельство проверяющему или кому-либо еще. Функция <code>groth16Verify</code> схожа с теми криптопримитивами, которые используются в блокчейне Zcash. Пример использования <code>groth16Verify</code> для прототипа децентрализованного приложения, анонимизирующего отправителя средств, можно найти в репозитории <a href="https://github.com/wavesplatform/anonymous-transactions-prototype">Anonymous transactions prototype</a>.</p>
<h2 id="%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81-%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%B0%D0%BC%D0%B8">Работа с примитивами</h2>
<p>В Ride существует 4 основных примитивных типа данных:</p>
<ul>
<li>числа (только integer)</li>
<li>булевые значения (boolean)</li>
<li>строки (string)</li>
<li>массивы байт (byte vector)</li>
</ul>
<p>Для 2 последних типов (string и byte vector) существуют функции, облегчающие с ними работу. Например, функция <code>drop(data: ByteVector|String, n: Integer)</code> может удалять первые N байт или символов из массива байт или строки соответственно. Функция <code>take(data: ByteVector|String, n: Integer)</code> может наоборот оставить только первые N байт. Если необходимо взять байты или символы не с начала, а с конца, то существуют функции <code>dropRight</code> и <code>takeRight</code>. А для еще большего удобства есть функция <code>size()</code>.</p>
<p>Работа со строками в Ride стала удобнее с выходом стандартной библиотеки версии 3, которая привнесла следующие функции:</p>
<ul>
<li><code>contains(substring: String)</code> - проверка входит ли подстрока в строку</li>
<li><code>indexOf(substring: String)</code> - возвращает индекс первого вхождения подстроки</li>
<li><code>lastIndexOf(substring: String)</code> - возвращает индекс последнего вхождения подстроки</li>
<li><code>split(delimiter: String)</code> - разбивает строку по разделителю и возвращает массив строк</li>
<li><code>size()</code> - возвращает количество символов в строке</li>
</ul>
<h2 id="%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">Преобразования типов</h2>
<p>Частая необходимость в программировании на строго типизированных языках - преобразования типов. Для этого в Ride существует огромное количество функций, которые позволяют сделать <code>toBytes</code>, <code>toInt</code>, <code>toString</code>, <code>toUtf8String</code> (для произвольного массива байт). Существует и более специфические функции вроде <code>toBase16String</code>, <code>toBase58String</code>, <code>toBase64String</code>, которые преобразуют массив байт в строку в одном из представлений - <code>HEX</code>, <code>base58</code> или <code>base64</code>.</p>
<p>Одним из наиболее часто используемых типов в коде на Ride является <code>Address</code>, и для удобства работы с ним существует функция <code>addressFromString</code>.</p>
<h2 id="%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8%D0%B7-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD%D0%B0">Получение данных из блокчейна</h2>
<p>В скриптах на Ride достаточно часто приходится работать не только с параметрами вызываемой функции или отправляемой транзакции, но и с данными из блокчейна, которые можно разделить на 2 категории:</p>
<ol>
<li>Данные о сущностях в блокчейне (балансы аккаунтов, информация о токенах или блоках)</li>
<li>Данные из key-value хранилища аккаунта</li>
</ol>
<p>Наиболее часто используемые функции из первой категории это <code>assetInfo(assetId: ByteVector)</code> и <code>blockInfoByHeight(N: Integer)</code>. Первая возвращает информацию о токене с указанным <code>assetId</code>. В том числе такие параметры как публичный ключ создателя аккаунта или название и описание. Вторая функция возвращает информацию о блоке с указанным номером. Для получения информации о текущем (последнем) блоке, можно использовать глобальную переменную <code>lastBlock</code>, которая так же содержит в себе структуру с информацией о блоке. Самым полезным параметром блока можно точно назвать <code>timestamp</code>, который содержит время генерации блока и явлется самым лучшим полем, чтобы ориентироваться на время в коде своего децентрализованного приложения.</p>
<p>Вторая категория функция позволяет читать данные из хранилища любого аккаунта (не только текущего, на котором выполняется скрипт). Как вы могли догадаться, существует 4 функции для чтения разных типов данных - <code>getInteger</code>, <code>getBinary</code>, <code>getBoolean</code>, <code>getString</code>. Каждая функция в качестве аргумента принимает адрес и ключ - <code>address: Address, key: String</code>. Для чтения с аккаунта, на котором выполняется скрипт, достаточно в качестве первого аргумента передать <code>this</code>. Все функции возвращают <code>Union(T|Unit)</code>, так как указанного ключа может не существовать. Если вы уверены, что функция будет существовать, то вы можете использовать функции <code>getIntegerValue</code>, <code>getBinaryValue</code>, <code>getBooleanValue</code> и <code>getStringValue</code>. Отличие последних заключается в том, что в случае отсутствия ключа они вернут исключение и выполнение функции прекратится.</p>
<p>Если вы все-таки используете <code>getInteger</code>, <code>getBinary</code>, <code>getBoolean</code> или <code>getString</code>, то в Ride есть функции, которые позволяют извечь данные из <code>Union</code> или вернуть значение по умолчанию или ошибку:</p>
<ul>
<li><code>value()</code> и <code>extract()</code> - получают данные из переменной или возвращают ошибку без описания <code>throw()</code></li>
<li><code>valueOrElse(a: T|Unit, b: T)</code> - возвращают данные из переменной, если там не <code>Unit</code>, иначе возвращают второй аргумент</li>
<li><code>valueOrErrorMessage(a: T|Unit, b: String)</code> - возвращают данные из переменной, если там не <code>Unit</code>, иначе выкидывают ошибку с сообщением <code>b</code></li>
</ul>
<p>Полезной может быть и функция <code>isDefined()</code>, которая проверяет, что ее аргумент не является <code>Unit</code> (напомню, что <code>Unit</code> можно считать аналогом <code>null</code>).</p>
<h2 id="%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0-%D1%81%D0%BE-%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0%D0%BC%D0%B8">Работа со списками</h2>
<p>Списки в Ride могут быть объявлены с помощью квадратных скобок <code>[]</code> и содержать любые типы данных. Некоторые функции стандартной библиотеки (например, <code>split</code> для строк) возвращают списки как результат выполнения. Для удобства работы с ними в стандартной библиотеке есть функции:</p>
<ul>
<li><code>cons</code> - добавляет новый элемент в начало массива</li>
<li><code>size</code> - возвращает количество элементов в массиве</li>
<li><code>getElemenet</code> - возвращает элемент массива под заданным индексом</li>
<li><code>median</code> - возвращает медианное значение, если в массиве содержатся числовые значения</li>
</ul>
<p>В текущей версии стандартной библиотеки нет таких функций как <code>sum</code>, <code>max</code> или <code>min</code>, так как они легко вычисляются с помощью <code>FOLD</code>.</p>
<blockquote>
<p>Важно: список <code>proofs</code> в полях транзакции всегда имеет размерность 8, вне зависимости от того, сколько на самом деле элементов он содержит.</p>
</blockquote>
<p>Кроме функций стандартной библиотеки, в Ride есть так же операторы для работы со списками:</p>
<ul>
<li><code>:+</code> - оператор для добавления элемента в конец списка</li>
<li><code>++</code> - оператор для конкатенации списков</li>
</ul>
<h2 id="%D0%B4%D1%80%D1%83%D0%B3%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8">Другие функции</h2>
<p>В этой книге мы не будем рассматривать все доступные функции, однако упомянуть о еще 2 категориях функций считаю нужным. Многое в блокчейне завязано на функциях хэширования, и такие функции есть и в Ride - <code>keccak256</code>, <code>blake2b256</code> и <code>sha256</code>.</p>
<p>Вторая категория функций, которые очень часто бывают полезны  - математические функции <code>pow</code> для возведения степени, <code>log</code> для вычисления логарифма и <code>fraction(value: Int, numerator: Int, denominator: Int)</code>, которая перемножает первые 2 аргумента и делит на третий, позволяя избежать переполнения целочисленной переменной.</p>
<h2 id="%D1%81%D0%B5%D0%BC%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B0-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B9">Семейства функций</h2>
<p>Как вы помните, у каждой функции в Ride есть <code>complexity</code>, которая определяет ее сложность. Для некоторых функций в Ride существуют аналоги, которые имеют меньшую <code>complexity</code> за счет того, что имеют лимит на размер аргумента. Например, функция <code>sigVerify</code> имеет сложность 200 и максимальный размер первого аргумента составляет 150 kb, однако в стандартной библиотеке есть функции <code>sigVerify_16kb</code>, <code>sigVerify_32kb</code>, <code>sigVerify_32kb</code>, <code>sigVerify_128kb</code>, со значениями <code>complexity</code> 100, 110, 125 и 150 соотественно. Если вы уверены, что ваш аргумент не может быть болше, чем указанные в названии функции значения, то вы можете использовать их и ваш скрипт будет иметь меньшую сложность.</p>
<p>Не только <code>sigVeriry</code> является семейством функций, но еще и, например функции хэширования, <code>rsaVerify</code> и <code>groth16Verify</code>. Полный список семейств функций вы можете всегда найти в документации.</p>
<h1 id="%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%B4%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9">Инструменты для разработки децентрализованных приложений</h1>
<p>Для удобства разработки децентрализованных приложений на Waves существует большое количество разных инструментов. Начать стоит, в первую очередь, с обозревателя блокчейна, который расположен по адресу <a href="https://wavesexplorer.com">wavesexplorer.com</a> и позволяет анализировать данные в блоках, все транзакции и UTX как в основной сети, так и в stagenet и testnet.</p>
<p>Однако, если мы говорим про разработку децентрализованных приложений, а не просто использование, то встает несколько основных вопросов:</p>
<ol>
<li>В какой среде писать код для смарт-аккаунтов, смарт-ассетов и децентрализованных приложений?</li>
<li>Как тестировать написанный код? Какие есть варианты для автоматического тестирования и ручного?</li>
<li>Как отлаживать код?</li>
<li>Как деплоить?</li>
</ol>
<p>Давайте разберем по порядку какие есть инструменты для этого.</p>
<h2 id="%D1%81%D1%80%D0%B5%D0%B4%D0%B0-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">Среда разработки</h2>
<p>Самым простым вариантом начать писать код, тестировать и работать с аккаунтами, является использование онлайн IDE, который доступен по адресу <a href="https://ide.wavesplatform.com/">https://ide.wavesplatform.com</a>. В нем есть подсветка синтаксиса Ride, умные подсказки, вывод типов, компилятор, консоль для работы с библиотекой <code>waves-transactions</code> и даже REPL (read-eval-print loop) Ride, который позволяет выражения на Ride исполнять прямо в браузере. Так же есть примеры кода на Ride, примеры интеграционных тестов на JavaScript, возможность управления аккаунтами и отправки транзакций с помощью веб-интерфейса. Онлайн IDE отлично подходит для тестирования контрактов в stagenet и testnet. Токены Waves для этих сетей можно бесплатно получить с помощью крана в wavesexplorer по адресам <code>https://wavesexplorer.com/stagenet/faucet</code> и <code>https://wavesexplorer.com/testnet/faucet</code>, но не более 10 Waves каждые 10 минут.</p>
<p>Однако, для более профессиональной разработки контрактов, рекомендую использовать другие инструменты.</p>
<p>Расширение <a href="https://marketplace.visualstudio.com/items?itemName=wavesplatform.waves-ride">RIDE для Visual Studio Code</a> является первым необходимым инструментом для профессиональной разработки с использованием блокчейна Waves. Установка этого расширения позволяет получить подсветку синтаксиса и подсказки для файлов с расширением <code>.ride</code>.</p>
<p><img src="../../assets/6-4-0-vs-code-ext-in-store.png" alt="Visual Studio Code Extention for Ride" title="Visual Studio Code Extention for Ride"></p>
<p>Кроме подсветски синтаксиса, расширение добавлеяет в VS Сode еще и интерактивную консоль (прямо как в онлайн IDE), которая позволяет запускать функции из <code>waves-transactions</code>, <code>waves-crypto</code> и еще несколько специализированных.</p>
<p><img src="../../assets/6-4-1-vc-code-ext.png" alt="Visual Studio Code Extention for Ride" title="Visual Studio Code Extention for Ride"></p>
<h2 id="%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D0%B5">Локальное окружение</h2>
<p>Во время разработки можно взаимодействовать с нодами из stagenet или testnet, которые доступны по адресам <code>http://nodes-stagenet.wavesnodes.com/</code> и <code>https://nodes-testnet.wavesnodes.com/</code>, однако наиболее удобным вариантом является использование приватного блокчейна из одной единственной ноды.
Запустить такой блокчейн можно при условии наличия установленного Docker. Запуск осуществляется простой командой:</p>
<pre class="hljs"><code><div>docker run -d -p 6869:6869 wavesplatform/waves-private-node
</div></code></pre>
<p>После запуска команды, локальный блокчейн будет запущен в виде Docker контейнера, API ноды будет доступен по адресу <code>http://localhost:6869/</code>, а все 100 миллионов токенов будут на балансе аккаунта с сид фразой <code>waves private node seed with waves tokens</code>.</p>
<p><img src="../../assets/6-4-2-local-node.png" alt="Local node with API" title="Local node with API"></p>
<p>Подробную информацию о Docker образе с этой нодой вы можете найти в <a href="https://github.com/wavesplatform/private-node-docker-image">этом репозитории</a>.</p>
<p>Преимуществами такого подхода являются:</p>
<ul>
<li>Уменьшенное время блока: в testnet и stagenet блоки генерируются раз в минуту, тогда как в вашей приватной сети будут каждые 10 секунд. Это позволяет экономить время во время прогонов интеграционных тестов.</li>
<li>Контроль над всеми токенами и отсутствие необходимости запрашивать токены с использованием крана</li>
<li>Полный контроль над домой и работоспособностью API. Команда Waves Protocol старается обеспечить максимальную доступность публичных узлов, однако не всегда это возможно и в некоторых случаях API для stagenet или testnet могут быть недоступны.</li>
<li>Ответы API публичных нод кэшируются, что может вызывать неожиданные ошибки.</li>
</ul>
<p>После запуска ноды вы так же можете запустить локальный обозревательно блокчейна, который будет работать с вашей нодой. Делается это так же с помощью разворачивания Docker образа:</p>
<pre class="hljs"><code><div>docker run -d -e API_NODE_URL=http://localhost:6869 -e NODE_LIST=http://localhost:6869 -p 3000:8080 wavesplatform/explorer
</div></code></pre>
<p>Обратите внимание, что при разворачивании указывается адрес API нашей ноды с приватным блокчейном.</p>
<p>После разворачивания образа, обозревательно станет доступен по адресу <code>http://localhost:3000</code>:</p>
<p><img src="../../assets/6-4-3-local-explorer.png" alt="Local explorer" title="Local explorer"></p>
<h2 id="%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%B4%D0%B0">Тестирование кода</h2>
<p>На момент написания этих строк существует возможность написания только интеграционных тестов для децентрализованных приложений на Ride. Инструментов для Unit тестов пока нет. Интеграционное тестирование в случае с Ride подразумевает, что написанный код компилируется, разворачивается с помощью <code>SetScript</code>, <code>SetAssetScript</code> или <code>Issue</code> транзакции на ассете или аккаунте и выполняются транзакции, которые проверяют корректность поведения скрипта. Другими словами, идет непосредственно работа с блокчейном (не эмуляцией!) и отправляются настоящие транзакции.</p>
<p>Интеграционные тесты могут быть написаны на Java с использованием библиотеки <a href="https://github.com/msmolyakov/paddle">Paddle</a> или на [JavaScript] с использованием онлайн IDE или библиотеки <code>surfboard</code>.</p>
<p>Surfboard можно установить из npm (при условии наличия у вас node.js и npm) слдующей командой:</p>
<pre class="hljs"><code><div>npm install -g @waves/surfboard
</div></code></pre>
<p>После этого у вас станет доступна команда <code>surfboard</code>. Команда <code>surfboard init</code> позволит инициализировать новый проект, который будет содержать конфигурационный файл и директории для тестов (<code>./test</code>) и скриптов на Ride (<code>./ride</code>). Конфигурационный файл позволяет задать настройки для работы с разными типами сетей, параметры аккаунтов и т.д.</p>
<p><img src="../../assets/6-4-4-surfboard.png" alt="Surfboard" title="Surfboard"></p>
<p>В директории <code>./test</code> можно создавать любые файлы с расширением <code>.js</code> и писать в них интеграционные тесты с использованием тестового фреймворка <code>Mocha</code>. Кроме непосредственно самой <code>Mocha</code> в тестовом файле доступны функции из <code>waves-transactions</code> и несколько дополнительных функций и переменных:</p>
<ul>
<li><code>setupAccounts({[key: string]: number})</code> - позволяет в начале скрипта создать новые аккаунты и перечислить на них с мастер сида тоокена</li>
<li><code>compile(file: File): String</code> - позволяет скомпилировать содержимое файла</li>
<li><code>file(path: String): File</code> - позволяет получить содержимое файла</li>
<li><code>accounts</code> - объект, в которой хранятся сиды созданных функцией <code>setupAccounts</code> аккаунтов</li>
</ul>
<p>Описание этих и других функций доступно <a href="https://wavesplatform.github.io/js-test-env/globals.html">в документации</a>. Примеры тестов вы можете найти в онлайн IDE или в репозитории <a href="https://github.com/wavesplatform/ride-examples">ride-examples</a>.</p>
<p>Запуск тестов в директории можно запустить с помощью команды <code>surfboard test</code>, если же хочется запустить конкретный файл, а не все файлы в директории <code>./test</code>, то можно выполнить <code>surfboard test my-scenario.js</code>.</p>
<h2 id="%D0%BE%D1%82%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0-%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B2-ride">Отладка скриптов Ride</h2>
<p>Для отладки скриптов Ride принято искользовать 2 основных приема.</p>
<p>В онлайн IDE и Surfboard есть REPL, который позволяет ввести код и срзу же получить результат. REPL позволяет не только выполнять базовые операции, но и объявлять переменные, работать с настоящим блокчейном (например, читать стейт аккаунтов), вызывать функции стандартной библиотеки</p>
<p><img src="../../assets/6-4-5-surfboard-repl.png" alt="Surfboard REPL" title="Surfboard REPL"></p>
<p>В более сложных ситуациях, когда у вас уже есть полноценный скрипт, который необходимо отлаживать, на помощь приходит функция <code>throw()</code> из стандартной библиотеки Ride, которая позволяет выбросить ошибку и текстовое описание к ней.</p>
<h2 id="%D1%80%D1%83%D1%87%D0%BD%D0%BE%D0%B5-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9">Ручное тестирование приложений</h2>
<p>Если вам по душе больше ручное тестирование или вы хотите поиграться с приложениями, уже развернутыми в сети, вы можете воспользоваться веб-сайтом <a href="https://waves-dapp.com/">https://waves-dapp.com</a>. Вы можете просто указать адрес аккаунта нужного децентрализованного приложения и Waves-Dapp покажет все доступные функции, какие параметры они принимают и позволит вызвать любую из них. Инструмент может быть полезен и для тестирования своего приложения, когда у вас нет интерфейса или тестов для некоторых функций, или, вам необходимо поменять настройки вашего приложения.</p>
<p><img src="../../assets/6-4-6-waves-dapp.png" alt="Waves Dapp" title="Waves dapp"></p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-7-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D1%83%D0%BC-%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-web3-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">Глава 7. Практикум: пишем Web3 приложения</h1>
<p>Лучший способ выучить язык - начать на нем писать. Заставить вас писать я не могу, поэтому предложу вам второй по крутизне вариант - читать как пишется код! Мы разберем несколько примеров контрактов, начнем с относительно простых, и закончим на достаточно сложных и разухабистых. Первым проектом, который будем писать является приложение Billy.</p>
<h2 id="%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-billy">Описание Billy</h2>
<p>Billy - децентрализованное приложение на базе бота для корпоративного мессенджера Slack. Вы можете найти подробную информацию о том, как работает Billy, на официальном сайте проекта - <a href="https://iambilly.app">https://iambilly.app</a>. Но давайте я коротко расскажу о том из каких частей он состоит и как именно в нем используется блокчейн.</p>
<p>Billy является проектом для мотивации сотрудников компании. В ходе работы у нас возникает много ситуаций, когда мы помогаем коллегам или они помогают нам. И далеко не всегда такая помощь входит в рабочие обязанности коллеги. Чтобы стимулировать помощь вы можете добавить Billy в Slack одной кнопкой на официальном сайте проекта. Billy генерирует уникальный адрес для каждого сотрудника компании и сохраняет их в базе данных. Каждый месяц бот начисляет на сгенерированные адреса 500 &quot;Спасибо&quot;-токенов, которые могут быть потрачены с помощью этого бота. Для этого сотрудники компании могут отправлять специальные команды боту (<code>10 спасибо @username</code>) или реагировать на сообщения с использованием специальных emoji.</p>
<p><img src="../../assets/7-2-1-emoji.png" alt="Emoji reaction" title="Emoji reaction"></p>
<p>Неиспользованный остаток из 500 спасибо-токенов за месяц сгорают в конце этого месяца. Заработанные спасибо-токены не сгорают и могут быть использованы для 3 целей:</p>
<ul>
<li><strong>Перевод другим пользователям в благодарность.</strong> Полученные токены можно переводить в любое время своим коллегам.</li>
<li><strong>Покупка товаров во внутреннем магазине.</strong> Внутренний магазин позволяет сотрудникам компании (или уполномоченным лицам) предлагать товары и услуги в обмен на спасибо-токены.</li>
<li><strong>Для участия в голосованиях и crowdfunding компаниях.</strong> Каждый пользователь может указать цель, для которой собирает токены (например, проведение внутренного митапа) или руководство компании может инициировать голосования, где каждый токен будет считаться одним голосом, то есть более &quot;полезный&quot; и активный сотрудник может больше влиять на итоги голосования. Кроме необходимого количества токенов у каждой кампании есть срок окончания сбора и срок реализации. Механика работы голосования схожа с DAO - децентрализованной автономной организацией.</li>
</ul>
<p>Видео-демонстрацию работы бота вы можете найти на официальном сайте проекта - <a href="https://iambilly.app">https://iambilly.app</a>. Система максимально скрывает для пользователей все, что касается блокчейна. При необходимости пользователь может запросить свою <code>seed</code> фразу и использовать токены вне Slack, однако по умолчанию все детали реализации для него скрыты, чтобы не создавать лишних барьеров.</p>
<blockquote>
<p><strong>Billy предоставляется бесплатно для всех компаний, поэтому, лучше всего понять его механику можно очень быстро и просто - добавьте в Slack и начните использовать.</strong></p>
</blockquote>
<h2 id="%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Реализация</h2>
<p>Преждем чем перейти к реализации идеи, давайте опишем все требования к сущностям в блокчейне в более формальном виде:</p>
<ol>
<li>Для каждой команды в Slack выпускается уникальный токен, который будет является внутренней валютой команды</li>
<li>Для каждого участника команды создается отдельный аккаунт, на котором хранятся только токены этой команды</li>
<li>Токены команды могут переводиться только между членами команды, поэтому список адресов членов команды нам необходимо где-то хранить</li>
<li>Любой член команды может сжечь свои токены</li>
<li>Участие в голосовании осуществляется через вызовы функций децентрализованного приложения с приложенными токенами команды</li>
<li>За каждое голосование, пользователь получает уникальный NFT токен, который подтверждает голос</li>
</ol>
<p>Система является комплексной и должна включать в себя несколько скриптов. Первый логичной шаг - выпуск токена для команды, является достаточной простой операцией отправки <code>Issue</code> транзакции (мы рассматривали пример в главе 5). Мы не хотим, чтобы пользователи системы должны были оплачивать комиссии за переводы в Waves и покупать для этого Waves, поэтому мы используем функционал спонсирования. Это позволит пользователям платить за транзакции в токенах &quot;Спасибо&quot;, в то время как настоящие Waves комиссии будут списываться с аккаунта администратора команды.</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">const</span> adminSeed = <span class="hljs-string">'...'</span>;
    <span class="hljs-keyword">const</span> issueTx = issue({
        <span class="hljs-attr">name</span>: <span class="hljs-string">`Thanks`</span>,
        <span class="hljs-attr">description</span>: <span class="hljs-string">'Say thank you to all of your teammates in Slack. By Billy.'</span>,
        <span class="hljs-attr">decimals</span>: <span class="hljs-number">0</span>,
        <span class="hljs-attr">quantity</span>: <span class="hljs-number">100000000</span>,
        <span class="hljs-attr">reissuable</span>: <span class="hljs-literal">false</span>
    }, adminSeed);

    <span class="hljs-keyword">await</span> broadcast(issueTx);
    <span class="hljs-keyword">await</span> waitForTx(issueTx.id);
    <span class="hljs-keyword">const</span> sponsorshipTx = sponsorship({
        <span class="hljs-attr">assetId</span>: issueTx.id,
        <span class="hljs-attr">minSponsoredAssetFee</span>: <span class="hljs-number">1</span>
    }, adminSeed);
    <span class="hljs-keyword">await</span> broadcast(sponsorshipTx);
</div></code></pre>
<p>Мы используем функцию <code>waitForTx</code> из библиотеки <code>waves-transactions</code>, чтобы убедиться, что транзакция выпуска токена попала в блокчейн и только потом отправить транзакцию спонсирования.</p>
<p>Использование спонсирования некоторым образом ограничивает наши возможности по остальным требованиям, так как спонсирование не может быть использовано вместе со смарт-ассетами. То есть, на уровне токена мы не можем заложить ограничение на перевод токенов только другим членам команды. В дальнейшем, с реализацией <a href="https://forum.wavesplatform.com/t/wep-2-customizable-sponsorship/15880">WEP-2 Customizable sponsorship</a> станет возможно включать спонсирование для смарт-ассетов, но в данный момент мы можем найти и другое решение. Например, мы можем на аккаунт каждого члена команды поставить скрипт (и сделать смарт-аккаунт), который будет проверять есть ли получатель токенов в списке коллег и позволять или запрещать транзакцию.</p>
<p>Список адресов членов команды необходимо так же хранить где-то в блокчейне. Так как у нас будет децентрализованное приложение для совершения покупок и голосования, мы туда же можем добавить функционал управления списком членов команды. Давайте сделаем децентрализованное приложение, которое позволяет добавить или удалить человека из списка. Функция добавления в список будет принимать адрес в качесте аргумента и добавлять в хранилище пару ключ-значение, где ключом будет адрес, а значением - <code>true</code>. Функция удаления будет обновлять запись в хранилище и переводить значение для указанного адреса в <code>false</code>.</p>
<pre class="hljs"><code><div>
{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">DAPP</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}

let adminPublicKey = base58'...'

func addToWhiteList(address: <span class="hljs-type">String</span>) = {
    let userInTheList = getBoolean(<span class="hljs-keyword">this</span>, address)
    let newValue = <span class="hljs-keyword">match</span> userInTheList {
        <span class="hljs-keyword">case</span> b: <span class="hljs-type">Boolean</span> =&gt; {
            <span class="hljs-keyword">if</span> b then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"User is already in the list and enabled"</span>)
            <span class="hljs-keyword">else</span> <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">if</span> i.callerPublicKey != adminPublicKey then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Only admin can call this function"</span>) <span class="hljs-keyword">else</span>
    [
        [<span class="hljs-type">BooleanEntry</span>(address, newValue)]
    ]
}

<span class="hljs-meta">@Callable</span>(i)
func removeFromWhiteList(address: <span class="hljs-type">String</span>) = {
    <span class="hljs-keyword">if</span> i.callerPublicKey != adminPublicKey then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Only admin can call this function"</span>)
    <span class="hljs-keyword">else</span> [<span class="hljs-type">BooleanEntry</span>(address, <span class="hljs-literal">false</span>)]
}
</div></code></pre>
<p>Давайте напишем код смарт-аккаунта, который будет устанавливаться для каждого члена команды:</p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}

# указываем id токена, который мы выпустили для данной команды
let assetId = base58'...'
# адрес аккаунта, на котором будет децентрализованное приложение и список аккаунтов членов команды
let whiteListAddress = <span class="hljs-string">"..."</span>

<span class="hljs-keyword">match</span> tx {
    # Любой член команды может сжечь свои токены
    <span class="hljs-keyword">case</span> b: <span class="hljs-type">BurnTransaction</span> =&gt; {
        sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], tx.senderPublicKey)
    }

    # Обновление этого скрипта возможно при наличии <span class="hljs-number">2</span> подписей - члена команды
    # и администратора команды, с аккаунта которого выпускается токен для команды
    <span class="hljs-keyword">case</span> s: <span class="hljs-type">SetScriptTransaction</span> =&gt; {
        let assetIssuerPublicKey = assetInfo(assetId).extract().issuerPublicKey
        sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], tx.senderPublicKey) &amp;&amp;
        sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">1</span>], assetIssuerPublicKey)
    }

    # Токены команды могут переводиться только между членами команды, другие токены могут
    # переводиться при наличии подписи аккаунта
    <span class="hljs-keyword">case</span> t: <span class="hljs-type">TransferTransaction</span> =&gt; {
        # Если переводимый токен НЕ токен команды, то проверяем подпись
        <span class="hljs-keyword">if</span> t.assetId != assetId then sigVerify(t.bodyBytes, t.proofs[<span class="hljs-number">0</span>], t.senderPublicKey) <span class="hljs-keyword">else</span>
        {
            # получаем адрес получателя токенов в виде строки
            let recipientAddress = addressFromRecipient(t.recipient).toString()

            # переводим адрес децентрализованного приложения команды в тип <span class="hljs-type">Address</span>
            let whiteListAddressValue = addressFromStringValue(whiteListAddress)

            # читаем значение из хранилища децентрализованного приложения команды по ключу
            # равному текстовому представлению адреса получателя текущей транзакции
            let addressIsAllowed = getBoolean(whiteListAddressValue, recipientAddress)

            # проверяем, что полученное из хранилища значение == <span class="hljs-literal">true</span>
            # иначе (если <span class="hljs-literal">false</span> или <span class="hljs-type">Unit</span>) то записываем <span class="hljs-literal">false</span> в переменную
            let addressInWhiteList = <span class="hljs-keyword">match</span> addressIsAllowed {
                <span class="hljs-keyword">case</span> b: <span class="hljs-type">Boolean</span> =&gt; b == <span class="hljs-literal">true</span>
                <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>
            }

            # если адрес получателя есть в списке сотрудников
            # или токены переводятся на децентрализованное приложение команды, то
            # проверяем подпись транзакции (должна быть подписана ключом аккаунта)
            <span class="hljs-keyword">if</span> ((addressInWhiteList || recipientAddress == whiteListAddress)) then {
                <span class="hljs-keyword">if</span> (sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], tx.senderPublicKey))
                then <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Signature is required"</span>)
            }<span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You can send this token only to white-listed addresses"</span>)
            }
        }
    }

    # Если вызывается функция децентрализованного приложения
    # то позволяем вызывать только приложение команды
    <span class="hljs-keyword">case</span> i: <span class="hljs-type">InvokeScriptTransaction</span> =&gt; {
        # получаем адрес вызываемого приложения в виде строки
        let dappCalledAddress = addressFromRecipient(i.dApp).toString()

        # если адрес вызываемого приложения равен адресу приложения команды, то 
        # требуем подпись пользователя
        # иначе запрещаем вызов
        <span class="hljs-keyword">if</span> (dappCalledAddress != whiteListAddress) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You can call only dApp with address "</span> + whiteListAddress + <span class="hljs-string">", but you're trying to call "</span> + dappCalledAddress) <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">if</span> (sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], tx.senderPublicKey) == <span class="hljs-literal">false</span>) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Transaction should be signed with users key"</span>) <span class="hljs-keyword">else</span>
        <span class="hljs-literal">true</span>
    }

    # Запрещаем все остальные типы транзакций, в том числе обмен, выпуск токена и т.д.
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Bad transaction type"</span>)
}

</div></code></pre>
<p>Описанные выше скрипты позволят удовлетворить следующие требования:</p>
<ol>
<li>Для каждой команды в Slack выпускается уникальный токен, который будет является внутренней валютой команды</li>
<li>Для каждого участника команды создается отдельный аккаунт, на котором хранятся токены этой команды</li>
<li>Токены команды могут переводиться только между членами команды, поэтому список адресов членов команды нам необходимо где-то хранить</li>
<li>Любой член команды может сжечь свои токены</li>
</ol>
<p>Однако, есть еще 2 требования, которые нам необходимо выполнить:</p>
<ol>
<li>Участие в голосовании осуществляется через вызовы функций децентрализованного приложения с приложенными токенами команды</li>
<li>За каждое голосование, пользователь получает уникальный NFT токен, который подтверждает голос</li>
</ol>
<p>Голосование и сбор средств на цель (далее будем называть кампанией по сбору средств) может инициировать любой член команды. Для этого необходимо вызвать функцию децентрализованного приложения, указав:</p>
<ul>
<li>уникальный идентификатор</li>
<li>время окончания сбора средств/голосования</li>
<li>срок реализации проекта</li>
<li>сумма сбора, при которой кампания считается успешной</li>
</ul>
<p>Мы не будем указывать название или описание в децентрализованном приложении, чтобы не раскрывать внутреннюю информацию. Данные о кампании (название, описание) могут храниться в централизованной базе данных, доступной сотрудникам компании.</p>
<p>Если сбор средств был успешным, то есть собранная сумма больше указанной в момент создания кампании, то токены должны быть заблокированы на контракты до момента наступления срока исполнения. После наступления срока исполнения, инвесторы начинают голосование по факту реализации проекта. Если проект был реализован по мнению большинства инвесторов, то токены разблокируются на контракте и создатель кампании получает их, иначе токены навсегда остаются на контракте. Такая схема позволяет избегать случаев, что кто-то собирает токены и не реализует обещанное. Давайте по шагам будем реализовывать наше приложение.</p>
<p>Функция начала кампании сбора средств и голосования может быть следующей:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func startFunding(id: <span class="hljs-type">Int</span>, fundraisingEndTimestamp: <span class="hljs-type">Int</span>, implmenetationEndTimestamp: <span class="hljs-type">Int</span>, targetSum: <span class="hljs-type">Int</span>) = {
    # текущее время
    let lastBlockTimestamp = lastBlock.timestamp

    # Время окончания кампании не может быть меньше, чем <span class="hljs-number">60</span> секунд
    <span class="hljs-keyword">if</span> (fundraisingEndTimestamp - lastBlockTimestamp - <span class="hljs-number">60</span> &lt; <span class="hljs-number">0</span>) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"End time should at least 60 seconds more than the last block time"</span>) <span class="hljs-keyword">else</span>

    # Время окончания сбора средств не может быть меньше срока релизации проекта
    <span class="hljs-keyword">if</span> (implmenetationEndTimestamp &lt; fundraisingEndTimestamp) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Implementation end time should more or equal to endTimestamp"</span>) <span class="hljs-keyword">else</span>

    # Идентификатор кампании должен быть уникальным
    <span class="hljs-keyword">if</span> (isDefined(getInteger(<span class="hljs-keyword">this</span>, keyFunding(id)))) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Funding with the same ID already exists"</span>) <span class="hljs-keyword">else</span>

    # Минимальная сумма токенов для сбора равна <span class="hljs-number">1000</span> 
    <span class="hljs-keyword">if</span> (targetSum &lt; <span class="hljs-number">1000</span>) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You cannot fundraise less than 1000 tokens"</span>)
    <span class="hljs-keyword">else</span> {
        let fundingPrefix = <span class="hljs-string">"funding_"</span> + id.toString()
        [
            # сохраняем на какой высоте была начата кампания
            <span class="hljs-type">IntegerEntry</span>(fundingPrefix, height),
            # сохраняем время окончания кампании
            <span class="hljs-type">IntegerEntry</span>(fundingPrefix + <span class="hljs-string">"_timestamp"</span>, fundraisingEndTimestamp),
            # сохраняем дату исполнения проекта
            <span class="hljs-type">IntegerEntry</span>(fundingPrefix + <span class="hljs-string">"_impl_timestamp"</span>, implmenetationEndTimestamp),
            # сохраняем значение цели (количество собираемых токенов), при которых кампания считается успешной
            <span class="hljs-type">IntegerEntry</span>(fundingPrefix + <span class="hljs-string">"_targetSum"</span>, targetSum),
            # создаем ключ, в котором постоянно будем хранить актуальное количество поступивших на цель токенов, и записываем <span class="hljs-number">0</span> как начальное значение
            <span class="hljs-type">IntegerEntry</span>(fundingPrefix + <span class="hljs-string">"_raised"</span>, <span class="hljs-number">0</span>),
            # создаем ключ, в котором будем хранить количество голосов за то, что проект был реализован, и записываем <span class="hljs-number">0</span> как начальное значение
            <span class="hljs-type">IntegerEntry</span>(fundingPrefix + <span class="hljs-string">"_release_votes"</span>, <span class="hljs-number">0</span>),
            # сохраняем публичный ключ создателя кампании (в виде строки для удобства чтения в обозревателе)
            <span class="hljs-type">StringEntry</span>(fundingPrefix + <span class="hljs-string">"_owner"</span>, i.callerPublicKey.toBase58String(),
            # создаем ключ, в котором будем хранить получил ли создатель цели свои токены после голосования, и записываем <span class="hljs-literal">false</span> как начальное значение
            <span class="hljs-type">BooleanEntry</span>(keyReleasedTokens(id), <span class="hljs-literal">false</span>)
        ]
    }
}

</div></code></pre>
<p>Мы создаем много ключей, которые будем использовать в других функциях тоже, поэтому имеет смысл веделить их в отдельные функции, чтобы не повторяться и не допускать опечаток:</p>
<pre class="hljs"><code><div>func keyFunding (id: <span class="hljs-type">Int</span>) = <span class="hljs-string">"funding_"</span> + id.toString()
func keyEndTimestamp(id: <span class="hljs-type">Int</span>) = keyFunding(id) + <span class="hljs-string">"_timestamp"</span>
func keyImplEndTimestamp(id: <span class="hljs-type">Int</span>) = keyFunding(id) + <span class="hljs-string">"_impl_timestamp"</span>
func keyTargetSum(id: <span class="hljs-type">Int</span>) = keyFunding(id) + <span class="hljs-string">"_targetSum"</span>
func keyOwner(id: <span class="hljs-type">Int</span>) = keyFunding(id) + <span class="hljs-string">"_owner"</span>
func keyRaised(id: <span class="hljs-type">Int</span>) = keyFunding(id) + <span class="hljs-string">"_raised"</span>
func keyReleaseVotes(id: <span class="hljs-type">Int</span>) = keyFunding(id) + <span class="hljs-string">"_release_votes"</span>
func keyReleasedTokens(id: <span class="hljs-type">Int</span>) = keyFunding(id) + <span class="hljs-string">"_released"</span>
</div></code></pre>
<p>Все члены команды, кроме создателя кампании, могут отдавать свои токены на реализацию проекта или как голоса, однако вклад одного пользователя не может быть больше 33% от необходимой суммы. Для этого они должны вызвать метод приложения, передать уникальный идентификатор кампании и прикрепить токены в качестве платежа</p>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Callable</span>(i)
func fund(id: <span class="hljs-type">Int</span>) = {
    # получаем приклепленный платеж, если его нет, будет выброшено исключение
    let pmt = i.payments[<span class="hljs-number">0</span>].extract()

    # получаем параметры кампании
    let targetSum = getIntegerValue(<span class="hljs-keyword">this</span>, keyTargetSum(id))
    let endTimestamp = getIntegerValue(<span class="hljs-keyword">this</span>, keyEndTimestamp(id))
    let owner = getStringValue(<span class="hljs-keyword">this</span>, keyOwner(id))

    # получаем количество собранных токенов на текущий момент
    let raised = getIntegerValue(<span class="hljs-keyword">this</span>, keyRaised(id))

    # получаем количество токенов, которые текущий пользователь уже отправлял на эту цель
    # в случае отсутствия, получаем <span class="hljs-number">0</span>
    let alreadyFundedByUser = <span class="hljs-keyword">match</span> getInteger(<span class="hljs-keyword">this</span>, keyUserFunded(id, i.callerPublicKey.toBase58String())){
        <span class="hljs-keyword">case</span> v: <span class="hljs-type">Int</span> =&gt; v
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">0</span>
    }

    # проверяем, что прикрепленные токены действительно являются токенами организации
    <span class="hljs-keyword">if</span> (pmt.assetId != thanksTokenId) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You have to attach proper tokens with id: "</span> + thanksTokenId.toBase58String()) <span class="hljs-keyword">else</span>

    # проверяем, что создатель кампании не пытается сам профинансировать кампанию
    <span class="hljs-keyword">if</span> (owner == i.callerPublicKey.toBase58String()) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You cannot fund your own target"</span>) <span class="hljs-keyword">else</span>

    # проверяем, что время окончания сбора средств еще не наступило
    <span class="hljs-keyword">if</span> (endTimestamp &gt; lastBlock.timestamp) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"This target is finished already"</span>) <span class="hljs-keyword">else</span>

    # проверяем, что вклад пользователя в цель менее <span class="hljs-number">33</span>% после этой транзакции
    <span class="hljs-keyword">if</span> (((alreadyFundedByUser + pmt.amount) &gt; targetSum / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>)) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You cannot fund more than 33% of the whole sum which is "</span> + ((targetSum / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>) - alreadyFundedByUser).toString())
    <span class="hljs-keyword">else</span> {
        [
            # сохраняем новое количество токенов, которые получены от текущего вызывабющего аккаунта на эту кампанию
            <span class="hljs-type">IntegerEntry</span>(keyUserFunded(id, i.callerPublicKey.toBase58String()), alreadyFundedByUser + pmt.amount),
            # обновляем сумму собранных токенов на текущий момент
            <span class="hljs-type">IntegerEntry</span>(keyRaised(id), raised + pmt.amount)
        ]
    }
}
</div></code></pre>
<p>Мы уже реализовали функционал создания кампании и его финансирования, однако если сбор средств был успешным, то есть собранная сумма больше указанной в момент создания кампании, то токены должны быть заблокированы на контракты до момента наступления срока исполнения. После наступления срока исполнения, инвесторы начинают голосование по факту реализации проекта. Если проект был реализован по мнению большинства инвесторов, то токены разблокируются на контракте и создатель кампании получает их, иначе токены навсегда остаются на контракте. Давайте реализуем функцию, которую могут вызвать инвесторы кампании и подтвердить, что проект был реализован. Отсутствие голоса будем считать голосом &quot;Против&quot;.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func voteForRelease(id: <span class="hljs-type">Int</span>) = {

    # получаем параметры кампании
    let endTimestamp = getIntegerValue(<span class="hljs-keyword">this</span>, keyEndTimestamp(id))
    let implEndTimestamp = getIntegerValue(<span class="hljs-keyword">this</span>, keyImplEndTimestamp(id))
    let votePower = getIntegerValue(<span class="hljs-keyword">this</span>, keyUserFunded(id, i.callerPublicKey.toBase58String()))
    let targetSum = getIntegerValue(<span class="hljs-keyword">this</span>, keyTargetSum(id))
    let raised = getIntegerValue(<span class="hljs-keyword">this</span>, keyRaised(id))
    let released = getBooleanValue(<span class="hljs-keyword">this</span>, keyReleasedTokens(id))
    let owner = keyOwner(id)

    # получаем количество токенов инвесторов, которые уже проголосовали <span class="hljs-string">"За"</span>
    let votedPower = getIntegerValue(<span class="hljs-keyword">this</span>, keyReleaseVotes(id))


    # проверяем, что срок реализации кампании уже прошел
    <span class="hljs-keyword">if</span> (implEndTimestamp &gt; lastBlock.timestamp) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"This target is not finished yet"</span>) <span class="hljs-keyword">else</span>

    # проверяем, что кампания была успешной и собрала необходимую сумму
    <span class="hljs-keyword">if</span> (raised &lt; targetSum) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"This target didn't reach target"</span>) <span class="hljs-keyword">else</span>

    # проверяем, что голосование по этой кампании уже не завершено
    <span class="hljs-keyword">if</span> (released) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"This target was released already"</span>) <span class="hljs-keyword">else</span>

    # проверяем, что текущий инвестор уже не голосовал за кампанию
    <span class="hljs-keyword">if</span> (isDefined(getBoolean(<span class="hljs-keyword">this</span>, keyUserVoted(id, i.callerPublicKey.toBase58String())))) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You already voted for the target"</span>) <span class="hljs-keyword">else</span>

    # если количество уже проголосовавших <span class="hljs-string">"За"</span> и голос текущего инвестора в сумме
    # больше <span class="hljs-number">50</span>%, передаем токены создателю кампании и фиксируем факт окончания
    # иначе увеличиваем количество токенов инвесторов, которые уже проголосовали <span class="hljs-string">"За"</span>
    <span class="hljs-keyword">if</span> ((votedPower + votePower) &gt; (raised / <span class="hljs-number">2</span>)) then {
        # создатель кампании получает <span class="hljs-number">80</span>% собранной суммы
        # остальные <span class="hljs-number">20</span>% удерживаются приложением в качестве комиссии
        let ownerPrize = raised - (raised / <span class="hljs-number">1</span> / <span class="hljs-number">5</span>)
        [
            <span class="hljs-type">IntegerEntry</span>(keyReleaseVotes(id), votedPower + votePower),
            <span class="hljs-type">BooleanEntry</span>(keyReleasedTokens(id), <span class="hljs-literal">true</span>),
            <span class="hljs-type">ScriptTransfer</span>(addressFromPublicKey(owner.toBytes()), ownerPrize, thanksTokenId)
        ]
    }<span class="hljs-keyword">else</span> {
        [
            <span class="hljs-type">IntegerEntry</span>(keyReleaseVotes(id), votedPower + votePower)
        ]
    }
}
</div></code></pre>
<p>Если все-таки кампания не была успешной и не собрала необходимое количество токенов, то необходимо дать инвесторам возможность забрать свои средства:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func refundUser(id: <span class="hljs-type">Int</span>) = {
    # получаем параметры кампании
    let endTimestamp = getIntegerValue(<span class="hljs-keyword">this</span>, keyEndTimestamp(id))
    let targetSum = getIntegerValue(<span class="hljs-keyword">this</span>, keyTargetSum(id))
    let raised = getIntegerValue(<span class="hljs-keyword">this</span>, keyRaised(id))

    # получаем количество токенов, которые были отправлены текущим инвестором
    let fundedAmount = getIntegerValue(<span class="hljs-keyword">this</span>, keyUserFunded(id, i.callerPublicKey.toBase58String()))

    # проверяем, что срок сбора средств кампании уже завершился
    <span class="hljs-keyword">if</span> (endTimestamp &gt; lastBlock.timestamp) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"This target time is not finished yet"</span>) <span class="hljs-keyword">else</span>

    # проверяем, что кампания НЕ собрала необходимое количество средств
    <span class="hljs-keyword">if</span> (raised &gt; targetSum) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"This target raised enough tokens"</span>) <span class="hljs-keyword">else</span>

    # проверяем, что текущий инвестор действительно поддерживал кампанию
    <span class="hljs-keyword">if</span> (fundedAmount == <span class="hljs-number">0</span>) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You have no power here"</span>) <span class="hljs-keyword">else</span>
        [
            # обнуляем количество токенов от текущего инвестора
            <span class="hljs-type">IntegerEntry</span>(keyUserFunded(id, i.callerPublicKey.toBase58String()), <span class="hljs-number">0</span>)
            # возвращаем инвестору токены
            <span class="hljs-type">ScriptTransfer</span>(i.caller, fundedAmount, thanksTokenId)
        ]
}

</div></code></pre>
<h2 id="%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B9-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81">Пользовательский интерфейс</h2>
<p>Мы реализовали основной код на Ride, однако, чтобы это работало, необходимо большое количество работы с точки зрения взаимодействия с пользователей. Чтобы понять как работает приложение для коненчного пользователя, посмотрите видео-демонстрацию на сайте проекта - <a href="https://iambilly.app">https://iambilly.app</a>. Или установите Billy для своего Slack и начните использовать - это бесплатно.</p>
<h1 id="oraculus">Oraculus</h1>
<h2 id="%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD-%D0%B8-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%B8%D0%B7-%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BC%D0%B8%D1%80%D0%B0">Блокчейн и данные из реального мира</h2>
<p>Блокчейн отлично работает с данными внутри себя, но не имеет никакого представления о том, что проиходжит за границами его консенсуса, а ведь там вся жизнь. Блокчейн не может сходить во внешний API и получить данные оттуда, потому что должна быть детерменированность операций. Если каждая нода будет ходить во внешний API в разное время, то какая-то может получить один результат, вторая - другой, третья - вообще получить ошибку, в итоге ноды блокчейна никогда не придут к консенсусу, ведь нельзя понять, какой ноде надо довериться. Чтобы решить эту проблему, вместо модели pull (когда ноды ходят за данными в реальный мир) принято применять модель push, когда есть какие-то поставщики данных, которые сохраняют данные в блокчейне, а дальше любые децентрализованные приложения в блокчейне используют эти данные. Сущности, которые сохраняют данные в блокчейне называются оракулами. Но с оракулами есть одна проблема - они централизованные, то есть мы доверяем одной сущности, которая поставляет нам какие-то данные. В общем случае, система является настолько централизованной, насколько централизованна самая &quot;плохая&quot; часть. То есть, децентрализованное приложение, которое использует для принятие критичных решений одного оракула на самом деле является централизованным приложением. Почему? Логика простая - повлияв на поведение одной сущности (оракула) можно добиться нужного поведения от такого приложения.</p>
<blockquote>
<p>Если децентрализованное приложение опирается на данные одного оракула, то такое приложение не является децентрализованным.</p>
</blockquote>
<p>Идея сделать децентрализованных оракулов лежит на поверхности, но простого решения у этой проблемы нет, поэтому ее часто называют &quot;проблемой оракулов&quot;. Давайте рассмотрим, что можно с этим сделать.</p>
<h2 id="%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%B5%D0%B9%D1%88%D0%B8%D0%B9-%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82-%D0%B4%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%BE%D1%80%D0%B0%D0%BA%D1%83%D0%BB%D0%BE%D0%B2">Простейший вариант децентрализованных оракулов</h2>
<p>Самым простым решением является мультиподпись, когда нескольько разных пользователей должны придти к консенсусу и подписать одни и те же данные. Например, мы хотим получать данные о курсе USD/EUR и у нас есть 5 оракулов, которые должны договориться о цене (каким-то образом за пределами блокчейна), подписать транзакцию и отправить ее в сеть на специальный аккаунт, который примет эту транзакцию только при наличии не менее 3 подписей из 5. Простейший контракт для такого случая выглядел бы так:</p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">3</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}

# array of <span class="hljs-number">5</span> public keys
let pks = [base58'', base58'', base58'', base58'', base58'']

# inner fold step <span class="hljs-keyword">for</span> each signature
func signedBy(pk:<span class="hljs-type">ByteVector</span>) = {
   # is signed by the public key or not
   func f(acc: <span class="hljs-type">Boolean</span>, sig: <span class="hljs-type">ByteVector</span>)
      = acc || sigVerify(tx.bodyBytes, sig, pk)
   <span class="hljs-type">FOLD</span>&lt;<span class="hljs-number">8</span>&gt;(tx.proofs, <span class="hljs-literal">false</span>, f)
}

# outer fold step <span class="hljs-keyword">for</span> each public key
func signedFoldStep(acc:<span class="hljs-type">Int</span>, pk:<span class="hljs-type">ByteVector</span>)
   = acc + (<span class="hljs-keyword">if</span>(signedBy(pk)) then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)

# comparing total number of correct signatures
# to required number of correct signatures
<span class="hljs-type">FOLD</span>&lt;<span class="hljs-number">5</span>&gt;(pks, <span class="hljs-number">0</span>, signedFoldStep) &gt;= <span class="hljs-number">3</span>
</div></code></pre>
<blockquote>
<p>Обратите внимание, эта функция является мультиподписью 3 из 5. В предыдущей главе мы рассматривали 2 из 3. В отличие от того примера, скрипт выше не делает допущений какая подпись где находится в массиве <code>proofs</code>, а проверяет каждое поле из <code>proofs</code> относительно каждого публичного ключа.</p>
</blockquote>
<p>У такого решения вопроса есть несколько проблем:</p>
<ul>
<li>В случае отсутствия консенсуса у оракулов, данные просто не будут поставлены в блокчейн</li>
<li>Отсутствует экономическая мотивация у поставщиков данных</li>
<li>Заранее заданный и ограниченный список оракулов</li>
</ul>
<p>Для решения этих проблем можно сделать полноценное децентрализованное приложение, которое будет из себя представлять маркетплейс, на котором встречаются 2 стороны:</p>
<ol>
<li>Приложения, которым нужны данные</li>
<li>Оракулы, которые готовы поставлять данные в обмен на вознаграждение</li>
</ol>
<p>Давайте сформулирует основные функциональные требования к такому приложению и реализуем его, используя Ride и блокчейн Waves.</p>
<h2 id="%D0%B4%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B9-%D0%BE%D1%80%D0%B0%D0%BA%D1%83%D0%BB-%D0%BA%D0%B0%D0%BA-dapp">Децентрализованный оракул как dApp</h2>
<p>Основные принципы работы децентрализованных оракулов должны быть следующими:</p>
<ul>
<li>Каждый желающий владелец любого децентрализованного приложения должен быть в состоянии запросить данные в определенном формате и с определенным вознаграждением для оракулов</li>
<li>Каждый желающий должен быть в состоянии зарегистрировать своего оракула и отвечать на запросы, зарабатывая таким образом</li>
<li>Все действия оракулов должны быть доступны для аудита</li>
</ul>
<h3 id="%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Запрос данных</h3>
<p>Любой аккаунт в блокчейне может &quot;отправить запрос&quot; оракулам. При отправке запроса необходимо прикладывать награду для оракулов за предоставление корректных данных (в токенах Waves). При задании вопросы обходимо указывать следуюшие параметры:</p>
<ul>
<li><code>id</code> - уникальный идентификатор каждого вопроса, генерируется задающим вопрос. Требование - отсутствие такого же ключа у dApp, не больше 64 символов.</li>
<li><code>question</code> - непосредственно задаваемый вопрос. Вопрос формируется в специальном формате для каждого типа данных, в начале вопроса должен стоять тип данных, после разделителя <code>//</code> идут мета данные в формате JSON. Например, для типа данных <code>Temperature</code> вопрос выглядит следующим образом: <code>Temperature//{&quot;lat&quot;: &quot;55.7558&quot;, &quot;lon&quot;: &quot;37.6173&quot;, &quot;timestamp&quot;: 150000000000, &quot;responseFormat&quot;: &quot;NN.NN&quot;}</code>.</li>
<li><code>consensusType</code> - правило агрерации данных. Для строковых типов данных контракт предусматривает возможность только консенсуса (полное совпадение ответов), в то время как для числовых может быть <code>median</code> или <code>average</code>.</li>
<li><code>minOraclesCount</code> - минимальное количество оракулов, которые должны предоставить данные, чтобы можно было получить итоговый консенсус-результат. Значение не может быть меньше 3.</li>
<li><code>maxOraclesCount</code> - максимальное количество оракулов, которые могут ответить на вопрос. Не больше 6.</li>
<li><code>oraclesWhiteList</code> - список оракулов (публичные ключи через запятые), которые должны предоставить данные. Если значение параметра равно пустой строке, то любой оракул может ответить на запрос данных</li>
<li><code>tillHeight</code> - дедлайн до достижения консенсуса. Если до этого времени консенсус между оракулами не был достигнут (не набралось количество ответов &gt; <code>minOraclesCount</code>), то отправитель запроса может забрать награду.</li>
</ul>
<p>Формат типа запросов данных оставим на усмотрение отправителей запросов и оракулов, но в качестве примера предлагают следующие:</p>
<ul>
<li><code>Temperature//{&quot;lat&quot;: &quot;55.7558&quot;, &quot;lon&quot;: &quot;37.6173&quot;, &quot;timestamp&quot;: 150000000000, &quot;responseFormat&quot;: &quot;NN.NN&quot;}</code></li>
<li><code>Pricefeed//{&quot;pair&quot;: &quot;WAVES/USDN&quot;, &quot;timestamp&quot;: 150000000000, &quot;responseFormat&quot;: &quot;NN.NNNN&quot;}</code></li>
<li><code>Sports//{&quot;event&quot;: &quot;WC2020&quot;, &quot;timestamp&quot;: 150000000000, &quot;responseFormat&quot;: &quot;%s&quot;}</code></li>
<li><code>Random//{&quot;round&quot;: 100, &quot;responseFormat&quot;: &quot;%s&quot;}</code></li>
</ul>
<h3 id="%D1%81%D0%B1%D0%BE%D1%80-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%BE%D0%B2-%D0%BE%D1%80%D0%B0%D0%BA%D1%83%D0%BB%D0%BE%D0%B2">Сбор ответов оракулов</h3>
<p>Любой аккаунт Waves может зарегистрироваться как оракул определенного типа данных. Для этого будет достаточно вызвать метод децентрализованного приложения и передать в качестве аргумента тип поставляемых данных. Пример вызова может выглядеть следующим образом - <code>registerAsOracle(&quot;Temperature&quot;)</code>. В этот момент в стейте dApp будет зафиксировано в какой момент произошла регистрация оракула в качестве поставщика определенного типа данных и записано следующее: <code>{oraclePublicKey}_Temperature={current_height}</code>.</p>
<p>Ответ оракулов осуществляется с помощью метода <code>response(id: String, data: String)</code> и <code>responseNumber(id: String, data: Integer)</code> .</p>
<h3 id="%D0%BF%D0%BE%D0%B4%D1%81%D1%87%D0%B5%D1%82-%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82%D0%BE%D0%B2">Подсчет результатов</h3>
<p>Для подсчета результатов необходимо вызвать метод <code>getResult(id: String)</code>. Подсчет результатов возможен только в том случае, когда ответили больше оракулов, чем указано в <code>minOraclesCount</code>. При выборе правильного ответа используется не простое большинство, а рейтинги оракулов. Рейтинг формируется по следующей логике:</p>
<ul>
<li>каждый оракул имеет рейтинг 100 при регистрации</li>
<li>за каждый ответ, который в итоге стал результатом запроса, оракул получает +1 рейтинга, за каждый неверный -1</li>
</ul>
<p>Давайте представим, что на запрос <code>Sports//{&quot;event&quot;: &quot;WorldCup2020&quot;, &quot;timestamp&quot;: 150000000000, &quot;responseFormat&quot;: &quot;%s&quot;}</code> ответили 5 оракулов со следующими рейтингами и ответами:</p>
<ol>
<li>Oracle0, рейтинг = 102, ответ = &quot;France&quot;</li>
<li>Oracle1, рейтинг = 200, ответ = &quot;Croatia</li>
<li>Oracle2, рейтинг = 63, ответ = &quot;France&quot;</li>
<li>Oracle3, рейтинг = 194, ответ = &quot;France&quot;</li>
<li>Oracle4, рейтинг = 94, ответ = &quot;Croatia&quot;</li>
</ol>
<p>Итоговый результат будет <code>France</code>, ведь суммарный рейтинг оракулов с таким ответом составляет 359, в то время как рейтинг оракулов, ответивших <code>Croatia</code> 294.</p>
<p>В результате процедуры подсчета голосов рейтинги оракулов <code>Oracle0</code>, <code>Oracle2</code> и <code>Oracle3</code> будут увеличены на 1 и они смогут забрать вознаграждение, в то время как рейтинги <code>Oracle1</code> и <code>Oracle4</code> уменьшены на единицу и они не получат вознаграждения.</p>
<h2 id="%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F">Реализация</h2>
<p>Давайте шаг за шагом начнем реализацию такого децентрализованного приложения. Логичнее всего начать с метода регистрации оракулов, который будет принимать в качестве аргумента тип предоставляемых оракулом данных. Если один оракул с одним публичным ключом предоставляет несколько типов данных, то он должен регистрироваться несколько раз.</p>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Callable</span>(i)
func registerAsOracle(dataType: <span class="hljs-type">String</span>) = {
    let neededKey = i.callerPublicKey.toBase58String() + <span class="hljs-string">"_"</span> + dataType
    let ratingKey = i.callerPublicKey.toBase58String() + <span class="hljs-string">"_rating"</span>

    let currentRating = <span class="hljs-keyword">match</span> getInteger(<span class="hljs-keyword">this</span>, ratingKey) {
        <span class="hljs-keyword">case</span> v: <span class="hljs-type">Int</span> =&gt; v
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-number">100</span>
    }
    <span class="hljs-keyword">match</span> (getString(i.caller, neededKey)) {
        <span class="hljs-keyword">case</span> data:<span class="hljs-type">String</span> =&gt; <span class="hljs-keyword">throw</span>(<span class="hljs-string">"This oracle is registered already"</span>)
        <span class="hljs-keyword">case</span> _ =&gt; {
            [
                <span class="hljs-type">StringEntry</span>(neededKey, toString(height)),
                <span class="hljs-type">IntegerEntry</span>(ratingKey, currentRating)
            ]
        }
    }
}
</div></code></pre>
<p>Следующим логичным шагом будет реализация функционала по отправке запросов на предоставление данных. Как мы уже описывали ранее, запрос на предоставление данных должен включать в себя следующие аргументы:</p>
<ul>
<li><code>id</code> - уникальный идентификатор каждого вопроса.</li>
<li><code>question</code> - непосредственно задаваемый вопрос в заранее оговоренном формате.</li>
<li><code>consensusType</code> - правило агрерации данных, <code>consensus</code>, <code>median</code> или <code>average</code>.</li>
<li><code>minOraclesCount</code> - минимальное количество оракулов.</li>
<li><code>maxOraclesCount</code> - максимальное количество оракулов.</li>
<li><code>oraclesWhiteList</code> - список оракулов (публичные ключи через запятые или пустая строка)</li>
<li><code>tillHeight</code> - дедлайн до достижения консенсуса.</li>
</ul>
<p>Функция должна записывать в стейт контракта параметры запроса, сумму вознаграждения, а так же публичный ключ отправителя запроса и ключи, по которым в дальнейшем будем записывать количество ответов, сами ответы, публичные ключи ответивших оракулов и флаг завершения запроса.</p>
<p>В момент запроса данных необходимо проверять аргументы на следующие условия:</p>
<ul>
<li>Если задан white-list оракулов, то длина строки с их публичными адресами не должна быть больше 1000 символов (функция <code>checkOraclesWhiteListLengthLt1000</code>)</li>
<li>Уникальный идентификатор запроса должен быть не более 32 символов (функция <code>checkRequestIdLt32</code>)</li>
<li>Идентификатор запроса не должен быть раньше использован (функция <code>checkIdIsNotUsed</code>)</li>
<li>У каждого запроса должно быть вознаграждение в токенах Waves (функция <code>checkPaymentInWavesGt0</code>)</li>
<li>Минимальное количество оракулов должно быть не менее 3, а максимальное не более 6 (функция <code>checkOraclesCountGt3Lt6</code>)</li>
<li>Значение минимального количества должно быть меньше либо равно, чем значение максимального количества (функция <code>checkOraclesWhiteListCountGtMinCount</code>)</li>
</ul>
<p>Все листинга кода ниже включают в себя вызовы вспомогательных функций, которые в этой статье не показываются, однако вы модете найти их в репозитории <a href="https://github.com/wavesplatform/ride-examples">Ride examples</a></p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func request(id: <span class="hljs-type">String</span>, question: <span class="hljs-type">String</span>, minResponsesCount: <span class="hljs-type">Int</span>, maxResponsesCount: <span class="hljs-type">Int</span>, oraclesWhiteList: <span class="hljs-type">String</span>, tillHeight: <span class="hljs-type">Int</span>) = {
        let whiteList = checkOraclesWhiteListLengthLt1000(oraclesWhiteList)
        let checkedRequestIdLt64 = checkRequestIdLt32(id)
        let requestId = checkIdIsNotUsed(checkedRequestIdLt64)
        let paymentAmount = checkPaymentInWavesGt0(i.payments[<span class="hljs-number">0</span>].extract())
        let minCount = checkOraclesCountGt3Lt6(minResponsesCount, maxResponsesCount)
        let maxCount = checkOraclesWhiteListCountGtMinCount(oraclesWhiteList, minCount, maxResponsesCount)
        let callerPubKey = toBase58String(i.callerPublicKey)
        [
            <span class="hljs-type">StringEntry</span>(keyQuestion(requestId), question),
            <span class="hljs-type">StringEntry</span>(keyOraclesWhiteList(requestId), whiteList),
            <span class="hljs-type">StringEntry</span>(keyRequesterPk(requestId), callerPubKey),
            <span class="hljs-type">StringEntry</span>(keyResponders(requestId), <span class="hljs-string">""</span>),
            <span class="hljs-type">StringEntry</span>(requestId, question),
            <span class="hljs-type">IntegerEntry</span>(keyMinResponsesCount(requestId), minCount),
            <span class="hljs-type">IntegerEntry</span>(keyMaxResponsesCount(requestId), maxCount),
            <span class="hljs-type">IntegerEntry</span>(keyResponsesCount(requestId), <span class="hljs-number">0</span>),
            <span class="hljs-type">IntegerEntry</span>(keyTillHeight(requestId), tillHeight),
            <span class="hljs-type">IntegerEntry</span>(keyRequestHeight(requestId), height),
            <span class="hljs-type">IntegerEntry</span>(keyPayment(requestId), paymentAmount),
            <span class="hljs-type">BooleanEntry</span>(keyRequestIsDone(id), <span class="hljs-literal">false</span>)
        ]
}

</div></code></pre>
<p>Отлично! Теперь у нас есть функции регистрации оракулов и отправки запросов от пользователей. Давайте теперь реализуем функционал отправки ответа от одного оракула.</p>
<h3 id="%D0%BE%D1%82%D0%B2%D0%B5%D1%82-%D0%BD%D0%B0-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85">Ответ на запрос данных</h3>
<p>Каждый оракул может ответить на запрос, если нет ограничений в виде white-list и запрос уже не закончился (по количеству ответов или длительности). В момент ответа на запрос, публичный ключ оракула и его ответ записываются в хранилище децентрализованного приложения, для этого в момент отправки запроса были созданы ключи <code>{id}_responders</code> и <code>{id}_responses</code>. Данный в этих ключах хранятся в виде строк с разделителем <code>;</code>.</p>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Callable</span>(i)
func response(id: <span class="hljs-type">String</span>, data: <span class="hljs-type">String</span>) = {

    # Шаг <span class="hljs-number">0</span> - проверка валидности предоставленных даннх
    let requestId = checkIdExists(id)
    let checkedData = checkDataIllegalCharacters(data)

    # Шаг <span class="hljs-number">1</span> - проверка состояния запроса (количества ответов уже)
    let currentResponsesCount = getResponsesCount(id)
    let newResponsesCount = checkNewResponsesCount(currentResponsesCount, id)

    # Шаг <span class="hljs-number">2</span> - проверка на вхождение оракула в white list и не ответил ли он уже на запрос
    let oraclePubKey = i.callerPublicKey.toBase58String()
    let oracleIsAllowed = checkOracleInWhiteList(oraclePubKey, id) == <span class="hljs-literal">true</span> || checkOracleResponded(oraclePubKey, id) == <span class="hljs-literal">false</span>
    let maxHeight = getIntegerValue(<span class="hljs-keyword">this</span>, keyTillHeight(id))
    let isDone = getBooleanValue(<span class="hljs-keyword">this</span>, keyRequestIsDone(id)) == <span class="hljs-literal">true</span>
    let requestIsActive = maxHeight &gt; height || isDone

    <span class="hljs-keyword">if</span> (oracleIsAllowed == <span class="hljs-literal">false</span>) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Oracle is not in the white list or already responded"</span>) <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">if</span> (requestIsActive == <span class="hljs-literal">false</span>) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Request is not active anymore due to max height ("</span> + maxHeight.toString() + <span class="hljs-string">"/"</span> + height.toString() + <span class="hljs-string">") or it is just done ("</span> + isDone.toString() + <span class="hljs-string">")"</span>)
    <span class="hljs-keyword">else</span> {

        let currentResponders = getResponders(id)
        let currentResponses = getResponses(id)

        let newResponders = <span class="hljs-keyword">if</span> currentResponders == <span class="hljs-string">""</span> then oraclePubKey
            <span class="hljs-keyword">else</span> currentResponders + <span class="hljs-string">";"</span> + oraclePubKey
        let newResponses = <span class="hljs-keyword">if</span> currentResponses == <span class="hljs-string">""</span> then checkedData
            <span class="hljs-keyword">else</span> currentResponses + <span class="hljs-string">";"</span> + checkedData


        let currentResponsePoints = getCurrentResponsePoints(id, checkedData)

        let oracleRating = getOracleRating(oraclePubKey)

        let newResponsePoint = currentResponsePoints + <span class="hljs-keyword">if</span> oracleRating &lt; <span class="hljs-number">200</span> then oracleRating / <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> log(oracleRating, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-type">HALFEVEN</span>)


        [
            <span class="hljs-type">IntegerEntry</span>(keyCurrentResponsePoints(requestId, checkedData), newResponsePoint),
            <span class="hljs-type">IntegerEntry</span>(keyResponsesCount(requestId), newResponsesCount),
            <span class="hljs-type">StringEntry</span>(keyResponseFromOracle(requestId, oraclePubKey), checkedData),
            <span class="hljs-type">StringEntry</span>(keyResponders(requestId), newResponders),
            <span class="hljs-type">StringEntry</span>(keyResponses(requestId), newResponses),
            <span class="hljs-type">BooleanEntry</span>(keyTookPayment(requestId, oraclePubKey), <span class="hljs-literal">false</span>),
            # <span class="hljs-type">StringEntry</span>(keyOneResponse(requestId, i, checkedData), newResponders),newResponsePoint)
        ]
    }
}
</div></code></pre>
<p>Так же во время ответа мы увеличиваем счетчик количества ответивших на запрос и какое количество баллов набирает данный ответ (баллы равны сумме рейтингов оракулов).</p>
<h3 id="%D1%81%D0%B1%D0%BE%D1%80-%D1%80%D0%B5%D0%B7%D1%83%D0%BB%D1%8C%D1%82%D0%B0%D1%82%D0%BE%D0%B2">Сбор результатов</h3>
<p>После отправки своих данных оракулами, должно быть подведение итогов, вырадающееся в выборе итогового результата (консенсусного решения, среднего или медианы) и изменении рейтингов оракулов. В этой функции мы так же могли бы выплатить сразу часть вознагрждения ответившим правильно, но в виду ограничения по сложности контракта в 4000, сделать в рамках одной функции не получится. Однако мы можем записать в хранилище аккаунта, кто имеет право забрать часть вознаграждения и позволить самим оракулам вызвать специальную функцию получения вознаграждения. Напомню, что только оракулы, чей ответ совпал с итоговым (или все оракулы с ответом в пределах 10% от результата если запрашивалось среднее или медиана) имеют право забрать часть ознаграждения.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func getResult(id: <span class="hljs-type">String</span>) = {
    <span class="hljs-keyword">if</span> (keyIsDefined(id) == <span class="hljs-literal">false</span>) then throwIdError(id) <span class="hljs-keyword">else</span> {
        let responsesCount = getResponsesCount(id)
        let minResponsesCount = getMinResponsesCount(id)
        <span class="hljs-keyword">if</span> (responsesCount &lt; minResponsesCount) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Minimum oracles count not reached yet"</span>) <span class="hljs-keyword">else</span> {
            let result = calculateResult(id)
            let ratingsDiff = getOracleRatingsDiff(id, result)
            let resultKey = keyResult(id)
            let resultDataEntry = <span class="hljs-type">StringEntry</span>(resultKey, result)
            let dataToWrite = cons(resultDataEntry, ratingsDiff)

            dataToWrite
        }
    }
}
</div></code></pre>
<h3 id="%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D0%BE%D0%B7%D0%BD%D0%B0%D0%B3%D1%80%D0%B0%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F">Получение вознаграждения</h3>
<p>Функция получения вознаграждения для оракула должна позволять забрать средства только один раз и проверять, что этот оракул действительно отвечал на запрос и ответ его считается корректным.</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func takeReward(id: <span class="hljs-type">String</span>) = {
    <span class="hljs-keyword">if</span> (keyIsDefined(id) == <span class="hljs-literal">false</span>) then throwIdError(id) <span class="hljs-keyword">else</span> {
        let paymentValue = getIntegerValue(<span class="hljs-keyword">this</span>, keyPayment(id))
        let oraclePubKey = i.callerPublicKey.toBase58String()
        let oracleResponseKey = keyResponseFromOracle(id, oraclePubKey)
        let oracleResponse = getStringValue(<span class="hljs-keyword">this</span>, oracleResponseKey)

        let resultKey = keyResult(id)
        let resultDataEntry = getStringValue(<span class="hljs-keyword">this</span>, resultKey)

        let alreadyTookKey = keyTookPayment(id, oraclePubKey)
        let alreadyTookPayment = getBooleanValue(<span class="hljs-keyword">this</span>, alreadyTookKey)

        let responsesCount = getResponsesCount(id)

        <span class="hljs-keyword">if</span> (oracleResponse == resultDataEntry &amp;&amp; alreadyTookPayment == <span class="hljs-literal">false</span>) then {
            let paymentAmount = paymentValue / responsesCount
            [
              <span class="hljs-type">BooleanEntry</span>(alreadyTookKey, <span class="hljs-literal">true</span>),
              <span class="hljs-type">ScriptTransfer</span>(i.caller, paymentAmount, unit)
          ]
        }<span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Already took payment or provided data was not valid"</span>)
        }

    }
}
</div></code></pre>
<p>На этом основной функционал контракта для консенсуса оракулов готов. Примеры в виде тестов как работать с таким контрактом вы можете найти в репозитории <a href="https://github.com/wavesplatform/ride-examples/branch/refactor">Ride examples</a></p>
<h2 id="%D0%B2%D0%BE%D0%B7%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B0%D0%B7%D0%B2%D0%B8%D1%82%D0%B8%D1%8F">Возможности для развития</h2>
<p>Релизованный функционал является простейшим вариантом работы децентрализованных оракулов. Мы решили проблемы, которые были обозначены в начале:</p>
<ul>
<li>В блокчейне всегда будут данные, даже если не все оракулы достигнут консенсуса</li>
<li>У участников процесса появляется экономическая и репутационная мотивация участвовать в предоставлении данных</li>
<li>Список оракулов может быть максимально широким, но в то же время его можно ограничить для своего запроса, если мы не хотим получать данные от любых оракулов, а только тех, которым мы доверяем.</li>
</ul>
<p>Благодаря тому, что форматы запросов являются типизированными, предоставление ответов можно автоматизировать, например, в виде браузерного расширения, которое следит за запросами на адресе децентрализованного приложения и отвечает на данные, если тип запращиваемых данных поддерживается расширением. Можно представить сценарий, когда пользователи с открытым браузером могут зарабатывать на предоставлении данных, при этом не делая ничего для этого своими руками.</p>
<p>Во многих случаях данные необходимы не разово, а в виде постоянного потока. В нашем децентрализованном приложении функциональность подписки на данные не реализована, но мы будем рады участию нашего сообщества в доработке этого примера. Pull requests are welcome!</p>
<h1 id="%D1%81%D0%BC%D0%B0%D1%80%D1%82-%D0%B0%D1%81%D1%81%D0%B5%D1%82%D1%8B-%D0%B8-%D0%BF%D1%80%D0%B8%D1%87%D0%B5%D0%BC-%D1%82%D1%83%D1%82-%D0%B3%D0%BE%D1%80%D1%8F%D1%87%D0%B0%D1%8F-%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%88%D0%BA%D0%B0">Смарт ассеты и причем тут горячая картошка</h1>
<p>Смарт-ассеты являются крайне мощным инструментом, которые при правильном использовании могут позволить быстро и просто реализовать ограничения по работе с токеном. Давайте разработаем токен-игру, которая называется &quot;горячая картошка&quot;.</p>
<h2 id="%D1%87%D1%82%D0%BE-%D0%B7%D0%B0-%D0%BA%D0%B0%D1%80%D1%82%D0%BE%D1%88%D0%BA%D0%B0-%D0%B8-%D0%BF%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B3%D0%BE%D1%80%D1%8F%D1%87%D0%B0%D1%8F">Что за картошка и почему горячая?</h2>
<p>Возможно, вы слышали про игру <a href="https://en.wikipedia.org/wiki/Hot_potato">горячая картошка</a>, которая возникла аж в 1888 году, но если вдруг не слышали, коротко объясню правила. Участники игры собираются в небольшой круг и бросают друг другу маленький предмет, параллельно с этим играет какая-либо музыка. В какой-то момент музыка прекращает играть и игрок, держащий предмет в этот момент, выбывает игры. В следующем раунде все начинается заново, пока не останется только 1 игрок.</p>
<h2 id="hotpotatotoken">HotPotatoToken</h2>
<p>Давайте реализуем токен с похожей механикой:</p>
<ul>
<li>Когда пользователь получает токен, у него есть 5000 минут, чтобы передать его кому-то еще. По истечении этого периода токен все еще может быть отправлен кому-то, но только если комиссия за транзакцию будет больше 1 Waves. Или токен может быть сожжен, но в виде комиссии придется заплатить уже 5 Waves.</li>
<li>Так как генерация нового аккаунта не стоит ничего, то давайте добавим условие, что отправить &quot;горячую картошку&quot; можно только на аккаунт, у которого больше 10 Waves на балансе</li>
<li>У пользователя одновременно может быть только одна горячая картошка</li>
<li>Все перечисленные выше ограничения не касаются аккаунта, который выпустил токен</li>
</ul>
<p>Давайте объявим основные переменные нашего скрипта. В отличие от смарт-аккаунта, который можно реализовать с помощью функции <code>@Verifier</code>, у смарт-ассета код должен быть в виде <code>EXPRESSION</code>:</p>
<pre class="hljs"><code><div>
{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">4</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ASSET</span> #-}

# на аккаунте, получающем горячую картошку, не может быть меньше этой суммы
let minimumWavesBalance = <span class="hljs-number">10</span>_00_000_000

# Количество миллисекунд, в течение которых минимальная комиссия будет стандартной (<span class="hljs-number">0.005</span> <span class="hljs-type">Waves</span> с обычного аккаунта)
let moveTimeInMs = <span class="hljs-number">5000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>

# Комиссия для отправки по истечению moveTimeInMs
let minimalFeeToMove = <span class="hljs-number">1</span>_00_000_000

# Комиссия для сожжения токена
let minimalFeeToBurn = <span class="hljs-number">5</span>_00_000_000
</div></code></pre>
<p>Возможно, вы обратили внимание на знак нижнего подчеркивания в числах <code>_</code>, который поддерживается в Ride в числах для упрощения чтения. Восемь нолей отделены от остальных цифр, так как Waves имеет 8 знаков после запятой и так легче сразу увидеть количество целых токенов Waves.</p>
<p>В глобальной области видимости доступна переменная <code>tx</code>, которая хранит информацию о текущей обрабатываемой транзакции. Так как <code>tx</code> является <code>Union</code> от всех возможных типов транзакций, то нам в коде необходимо использовать pattern matching. У нас будут разные условия для <code>Tranfer</code>, <code>Burn</code> и всех остальных типов транзакций.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">match</span> (tx) {
    # временно оставим проверку <span class="hljs-type">Tranfer</span> транзакций в таком виде
    <span class="hljs-keyword">case</span> t:<span class="hljs-type">TransferTransaction</span> =&gt; {
        <span class="hljs-literal">false</span>
    }
    # Мы позволяем сжигать только если комиссия больше <span class="hljs-number">5</span> <span class="hljs-type">Waves</span>
    # или отправителем является аккаунт, выпустивший токен
    <span class="hljs-keyword">case</span> b: <span class="hljs-type">BurnTransaction</span> =&gt; {
        <span class="hljs-keyword">if</span> (b.fee &gt;= minimalFeeToBurn || tx.senderPublicKey == <span class="hljs-keyword">this</span>.issuerPublicKey) then <span class="hljs-literal">true</span>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You have to pay 5 WAVES to burn this token"</span>)
        }
    }
    # все другие типы транзаций разрешены для создателя токены и запрещены для всех остальных
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-keyword">if</span> tx.senderPublicKey == <span class="hljs-keyword">this</span>.issuerPublicKey then <span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You only can transfer this token"</span>)
  }
</div></code></pre>
<p>В коде выше мы реализовали проверку, что если транзакцией, выполняемой с токеном, явлется <code>Burn</code>, то должно выполняться одно из условий - отправителем является аккаунт, выпустиший этот токен или комиссия больше минимального значения для сжигания (в нашем случае 5 Waves). Мы использовали ключевое слово <code>this</code>, которое в контексте смарт-ассета обозначает тип <code>Asset</code> и содержит информацию о текущем ассете.</p>
<blockquote>
<p>Обратите внимание, при проверке отправителя транзакции мы проверяем только совпадение публичных ключей и не проверяем, что предоставлена правильная подпись от заданного публичного ключа, так как <strong>массив proofs недоступен в скрипте смарт-ассета</strong>. Проверка подписей является прерогативой аккаунта, а не ассета.</p>
</blockquote>
<p>В скрипте выше мы запретили все <code>Transfer</code> транзации, но логика &quot;горячей картошки&quot; подразумевает, что мы должны их разрешать, если токен был получен менее 5000 минут назад или комиссия выше 1 Waves. Прежде чем мы начнем писать код, необходимо понять как мы будем проверять факт получения токена менее 5000 минут назад. К сожалению, в Ride нет функции, которая позволила бы нам найти такую функцию. Более того, в Ride практически нет никаких функций, которые позволяют смотреть в историю транзакций. Мы могли бы требовать предоставлять в массиве <code>proofs</code> id транзакции получения картошки, ведь как вы помните, в <code>proofs</code> можно передавать до 8 аргументов, но <code>proofs</code> недоступен в коде смарт-ассета. Решением будет требовать предоставлять id транзакции получения картошки в качестве <code>attachment</code> к <code>Tranfer</code> транзакции.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">match</span> (tx) {
    <span class="hljs-keyword">case</span> t:<span class="hljs-type">TransferTransaction</span> =&gt; {

        # Если отправителем токена является аккаунт, выпустивший его, то проверки не нужны
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.issuerPublicKey == t.senderPublicKey) then <span class="hljs-literal">true</span>
        <span class="hljs-keyword">else</span> {
            # для вычисления сколько времени прошло с момента получения токена
            # в attachment должен быть указан id транзакции получения
            let txId = t.attachment

            # получаем баланс по токену <span class="hljs-type">HotPotato</span>, чтобы проверить, что у получателя уже нет <span class="hljs-string">"горячей картошки"</span>
            let currentRecipientHasPotato = assetBalance(t.recipient, t.assetId) &gt; <span class="hljs-number">0</span>

            # получаем баланс токенов <span class="hljs-type">Waves</span>, чтобы убедиться, что на аккаунте не меньше <span class="hljs-number">10</span> <span class="hljs-type">Waves</span>
            let currentRecipientWavesBalance = wavesBalance(t.recipient)

            # Если у пользователя уже есть горячая картошки, то выкидываем исключение
            <span class="hljs-keyword">if</span> (currentRecipientHasPotato) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"The recipient already has a hot potator"</span>)
            # Если у пользователя меньше <span class="hljs-number">10</span> <span class="hljs-type">Waves</span>, то выкидываем исключение
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (currentRecipientWavesBalance &lt; minimumWavesBalance) then <span class="hljs-keyword">throw</span>(<span class="hljs-string">"Recipient is too poor"</span>) <span class="hljs-keyword">else</span> {

                # Получаем информацию о транзакции, с которой текущий отправитель получил свою картошку
                let transaction = transferTransactionById(t.assetId.value()).valueOrErrorMessage(<span class="hljs-string">"Can't find incoming transaction"</span>)

                # Получаем номер блока, в котором текущий отправитель получил свою картошку
                let receivedBlockNumber = transactionHeightById(transaction.id).valueOrErrorMessage(<span class="hljs-string">"Can't find incoming tx block number"</span>)

                # Получаем всю информацию о блоке, в которой текущий отправитель получил свою картошку
                let receivedBlockTimestamp = blockInfoByHeight(receivedBlockNumber).value().timestamp

                # Проверяем, что пользователь получил свой свою горячую картошку меньше, чем <span class="hljs-number">5000</span> минут назад
                let receivedAssetInLastNMs = (lastBlock.timestamp - receivedBlockTimestamp) &lt;= moveTimeInMs &amp;&amp; t.assetId == transaction.assetId

                # Проверяем, является ли комиссия больше <span class="hljs-number">1</span> <span class="hljs-type">Waves</span>
                let feeMore1Waves = t.fee &gt;= minimalFeeToMove

                # Если транзакция получена больше <span class="hljs-number">5000</span> блоков назад И комиссия меньше <span class="hljs-number">1</span> <span class="hljs-type">Waves</span>
                # Бросаем исключение
                # Иначе разрешаем транзакцию
                <span class="hljs-keyword">if</span> (!receivedAssetInLastNMs &amp;&amp; !feeMore1Waves) then {
                    <span class="hljs-keyword">throw</span>(<span class="hljs-string">"You got potato long time ago, now you have to pay 1 WAVES fee"</span>)
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-literal">true</span>
                }
            }
        }
    <span class="hljs-keyword">case</span> burn: <span class="hljs-type">BurnTransaction</span> =&gt; {...}
    <span class="hljs-keyword">case</span> _ =&gt; ...
  }
</div></code></pre>
<p>Мы реализовали весь необходимый функционал, используя несколько функций и переменные стандартной библиотеки:</p>
<ul>
<li><code>transferTransactionById(txId: ByteVector)</code> позволяет получить информацию о <code>Transfer</code> транзакции по ее Id. Предвосхищая вопросы сразу скажу, что такой же функции для других типов транзакций не существует.</li>
<li><code>blockInfoByHeight(n: Int)</code> позволяет получить информацию о блоке по ее номеру</li>
<li><code>lastBlock</code> - содержит всю информацию о текущем (последнем) блоке</li>
</ul>
<h1 id="%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B5-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8">Лучшие практики разработки</h1>
<p>Как вы могли уже заметить, разработка децентрализованных Web3 приложений может быть местами нетривиальным занятием, которое отличается от обычной разработки приложений во многих аспектах:</p>
<ul>
<li><strong>Цена ошибки</strong>. Ошибка в децентрализованных приложениях часто может приводить к потере средств, иногда потере средств пользователей</li>
<li><strong>Открытость кода</strong>. Даже если вы не хотите, чтобы ваш код был доступен другим пользователям и разработчикам, он будет лежать в блокчейне и всегда остается возможность его декомпилировать (в Waves, например, это делается крайне просто даже в обозревателе блокчейна)</li>
<li><strong>Большое количество взаимосвязанных элементов</strong>. Одни децентрализованные приложения могут описаться на логику других</li>
<li><strong>Возможные обновления протокола</strong>. Например, обновление протокола Waves до 1.2 и активация feature 14 (в случае его принятия в mainnet), полностью меняют логику работы с транзакциями вызовов скриптов. Фактически, у приложения может меняться окружение. Сложно такое представить в обычной разработке.</li>
</ul>
<p>Давайте разберемся какие ошибки чаще всего допускают разработчики и что надо делать, чтобы их избежать.</p>
<h2 id="%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D1%8F%D0%B9%D1%82%D0%B5-%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D1%8C">Всегда проверяйте подпись</h2>
<p>Одна из самых распространенных ошибок разработчиков - использовать в скриптах смарт-аккаунтов или функции <code>@Verifier</code> децентрализованных приложений конструкцию проверки <code>case _ =&gt; true</code>. Например, можно подумать, что следующий скрипт запрещает только <code>Transfer</code> транзакции и разрешает все остальные:</p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">3</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}

<span class="hljs-keyword">match</span> (tx) {
    <span class="hljs-keyword">case</span> t:<span class="hljs-type">TransferTransaction</span> =&gt; <span class="hljs-literal">false</span>
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>Но дьявол кроется в деталях. Такой скрипт полностью запрещает делать с аккаунта <code>Transfer</code> транзакции и резраешает все остальные виды транзакции <strong>любому пользователю</strong>. Любой человек или даже просто скрипт сможет сделать транзакцию с этого аккаунта, просто указав в транзакции поле <code>senderPublicKey</code> публичный ключ аккаунта и <strong>не указав ни одной подписи.</strong></p>
<p><strong>Всегда проверяйте</strong> наличие подписи и ее корректность:</p>
<pre class="hljs"><code><div>{-# <span class="hljs-type">STDLIB_VERSION</span> <span class="hljs-number">3</span> #-}
{-# <span class="hljs-type">CONTENT_TYPE</span> <span class="hljs-type">EXPRESSION</span> #-}
{-# <span class="hljs-type">SCRIPT_TYPE</span> <span class="hljs-type">ACCOUNT</span> #-}

<span class="hljs-keyword">match</span> (tx) {
    <span class="hljs-keyword">case</span> t:<span class="hljs-type">TransferTransaction</span> =&gt; <span class="hljs-literal">false</span>
    <span class="hljs-keyword">case</span> _ =&gt; sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number">0</span>], tx.senderPublikey)
}
</div></code></pre>
<p>Быть внимательным надо не только в mainnet, но и в testnet, потому что и там и там есть есть скрипты, которые смотрят все транзакции в блокчейне и если находят аккаунты с такой уязвимостью, выводят все токены с такого аккаунта.</p>
<h2 id="%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B9%D1%82%D0%B5-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D1%83-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-verifier-%D0%B8-callable">Понимайте разницу между @Verifier и @Callable</h2>
<p>Некоторые разработчики децентрализованных приложений допускают ошибку при проектировании своего dApp, ошибочно погалая, что <code>@Verifier</code> проверяет <strong>входящие</strong> транзакции на адрес dApp. Например, встречаются такие скрипты:</p>
<pre class="hljs"><code><div><span class="hljs-meta">@Callable</span>(i)
func foo() = {
    [<span class="hljs-type">StringEntry</span>(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>)]
}

<span class="hljs-meta">@Verifier</span>(tx)
func verify = {
    <span class="hljs-keyword">match</span> (tx){
        <span class="hljs-keyword">case</span> i: <span class="hljs-type">InvokeScriptTransaction</span> =&gt; <span class="hljs-literal">true</span>
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-literal">false</span>
    }
}
</div></code></pre>
<p>Но такой скрипт занимается не тем, что разрешает вызывать методы данного аккаунта, а <strong>разрешает вызывать с аккаунта этого децентрализованного приложения вызывать другие даже без предоставления подписи.</strong> То есть, любой пользователь сможет вызвать другой аккаунт и передать туда все токены с аккаунта этого приложения. Не надо забывать, что аккаунт децентрализованного приложения остается аккаунтом, кооторый сам тоже может делать какие-то действия и отправлять транзакции и эти действия контролируются функцией <code>@Verifier</code>.</p>
<h2 id="%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D1%8F%D0%B9%D1%82%D0%B5-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%B4-%D0%BE%D1%82%D0%BF%D1%80%D0%B0%D0%B2%D0%BA%D0%BE%D0%B9">Проверяйте транзакции перед отправкой</h2>
<p>Транзакции вызовов скрипта могут завершаться ошибкой, но раньше такие транзакции просто не попадали в блокчейн, с выходом Waves 1.2 (на момент написания этих строка пока только в stagenet) это ситуация изменилась. Теперь <code>InvokeScript</code> транзакции и транзакции, связанные с использованием смарт-ассетов, попадают в блокчейн даже если возвращают ошибку, и пользователь платит за них комиссию.</p>
<p>Убедиться на 146%, что транзакция успешно выполнится полностью и попадет в блокчейн невозможно, так как состояние блокчейна меняется достаточно быстро, новые транзакции появляются в UTX, попадают в блоки и могут менять ветку, по которой пойдет скрипт. Максимизировать вероятность, что транзакция успешно выполнится можно с помощью предварительной валидации. В REST API ноды есть метод <a href="https://nodes.wavesplatform.com/api-docs/index.html#/debug/validate"><code>debug/validate</code></a>, который принимает транзакцию и валидирует ее. Метод возвращает какой был бы результат выполнения скрипта транзакции, если бы она добавлялась в блок прямо сейчас.</p>
<p>Используйте этот метод для предварительной валидации, прежде чем отправить транзакцию с помощью метода <code>broadcast</code>.</p>
<blockquote>
<p>Важно: данный метод API требует ключ, который невозможно получить для публичных нод, поэтому используйте ноду, чей API Key вы знаете.</p>
</blockquote>
<h2 id="%D0%B1%D1%83%D0%B4%D1%8C%D1%82%D0%B5-%D0%B2%D0%BD%D0%B8%D0%BC%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B-%D1%81-%D0%BA%D0%BB%D1%8E%D1%87%D0%B0%D0%BC%D0%B8">Будьте внимательны с ключами</h2>
<p>В разработке децентрализованных приложений много операций совершается с key-value хранилищем аккаунта. Ключи в хранилище часто являются композитными, например, <code>voting_12_vote_3MEEsWQtsS5WV2SczdEvipY3Ch5LuSHuLWa</code>, который может хранить голос аккаунта <code>3MEEsWQtsS5WV2SczdEvipY3Ch5LuSHuLWa</code> в голосовании с <code>id=12</code>. Формирование ключа для такой записи в хранилище может быть реализовано в Ride следующим образом:</p>
<pre class="hljs"><code><div>func keyVoteByAddress(votingId: <span class="hljs-type">Int</span>, address: <span class="hljs-type">String</span>) = <span class="hljs-string">"voting_"</span> + votingId + <span class="hljs-string">"_vote_"</span> + address
</div></code></pre>
<p>Часто встречается ошибка, что в формировании ключа допускают ошибку, что записывают в один ключ, а пытаются читать из другого ключа. Например, забаывают символ <code>_</code> в одном из мест. Чтобы избегать такой ошибки, всегда используйте отдельные функции для формирования ключа, вместо copy&amp;paste. Ну и, конечно, пишите тесты для ваших приложений.</p>
<h2 id="%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B9%D1%82%D0%B5-%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E">Используйте значения по умолчанию</h2>
<p>Другой распространенной ошибкой, связанной в том числе с ключами в хранилще, является попытка чтения значений значений из переменных с типом <code>Union(T|Unit)</code> с помощью <code>value()</code> или <code>extract()</code> в тех местах, где можно было бы использовать значения по умолчанию. Например, если функция пытается прочитать голос пользователя из хранилища, но может быть ситуация, что голоса пока нет, используйте функцию <code>valueOrElse</code> или pattern matching:</p>
<pre class="hljs"><code><div>
let <span class="hljs-type">NONE</span> = <span class="hljs-string">"NONE"</span>

func keyVoteByAddress(votingId: <span class="hljs-type">Int</span>, address: <span class="hljs-type">String</span>) = <span class="hljs-string">"voting_"</span> + votingId + <span class="hljs-string">"_vote_"</span> + address


<span class="hljs-meta">@Callable</span>(i)
func vote(id: <span class="hljs-type">Int</span>) =&gt; {
    let voteKey = keyVoteByAddress(id, i.caller.toBase58String())
    let vote = getString(<span class="hljs-keyword">this</span>, voteKey).valueOrElse(<span class="hljs-type">NONE</span>)

    # альтернативный вариант

    let vote = <span class="hljs-keyword">match</span> getString(<span class="hljs-keyword">this</span>, voteKey){
        <span class="hljs-keyword">case</span> s: <span class="hljs-type">String</span> =&gt; s
        <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">NONE</span>
    }

    <span class="hljs-keyword">if</span> (vote == <span class="hljs-type">NONE</span>) then ...
    <span class="hljs-keyword">else</span> ...
}
</div></code></pre>
<p>Стоит так же учитывать, что функции вашего приложения могут вызываться не только из вашего пользовательского интерфейса, но кем угодно и как угодно, поэтому значения по умолчанию могут помочь и им.</p>
<h2 id="%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D1%82%D0%B5-%D0%BF%D0%BE%D0%B4-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D0%B5%D0%BC-%D0%B2%D0%B0%D1%88%D0%B8-%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8">Держите под контролем ваши транзакции</h2>
<p>В работе реальных децентрализованных приложений относительно часто встречаются случаи, когда необходимо выполнять несколько зависимых транзакций последовательно. Например, если вы используете схему <a href="https://en.wikipedia.org/wiki/Commitment_scheme">коммит-раскрытие</a>, то фаза раскрытия может быть только после фазы коммита. Если вы отправите транзакцию раскрытия до того, как транзакция коммита попадет в блокчейн, то ваш скрипт вернет ошибку, пользователь заплатит комиссию и не получит ожидаемый результат.</p>
<p>В блокчейне Waves могут быть редкие ситуации, когда происходит форк в блокчейне и последний блок или микроблок откатывается, что может вести к нарушению последовательности зависимых транзакций. Например, если отоправить транзакцию для фазы коммита, дождаться пока она попадет в последний (жидкий) блок и сразу же отправить транзакцию раскрытия, то может быть ситуация, когда последний блок или микроблок откатится, транзакция коммита &quot;выпадет&quot; из блокчейна. Это приведет к тому, что транзакция для фазы раскрытия станет невалидной.</p>
<p>Если вы используете функцию <code>waitForTx</code> из библиотеки <code>waves-transactions</code>, то она ожидает только попадания в последний жидкий блок, что может приводить к проблемам. Если у вас есть зависимые транзакции, то более безопасным способом будет использовать функцию <code>waitForTxWithNConfirmations</code> и ждать 1-2 подтверждения после попадания первой транзакции в блок.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-8-%D0%BB%D1%83%D1%87%D1%88%D0%B8%D0%B5-%D0%B4%D1%80%D1%83%D0%B7%D1%8C%D1%8F-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0">Глава 8. Лучшие друзья разработчика</h1>
<p>Как говорит моя девушка, у разработчиков нет друзей, но мы то знаем, что это не так, потому что лучшие друзья разработчика - инструменты для разработки.</p>
<p>В ходе разработки Web3 приложений необходимо постоянно взаимодействовать с нодами блокчейна, как для получения информации, так и для отправки данных в виде транзакции. С другой стороны, создание Web3 приложений подразумевает взаимодействие с пользователем, в том числе запросы подписей транзакуий для совершения действий или проверки состояния аккаунтов и т.д.</p>
<p>В экосистеме Waves существует несколько ресурсов и инструментов, которые могут быть полезны для этих целей, давайте рассмотрим их.</p>
<h2 id="node-rest-api">Node REST API</h2>
<p>Как вы возможно помните из главы 2 про конфигурирование ноды (на самом деле наверняка забыли за эти 100+ страниц), нода Waves имеет встроенный REST API для получения и отправки данных. Многие другие блокчейны используют JSON RPC, а не REST, но именно наличие REST позволяет максимально упростить общение с нодой. По умолчанию REST API ноды выключен в конфигурации, но есть публичные ноды, которые позволяют делать запросы на получение данных и отправку транзаций:</p>
<ul>
<li><code>nodes.wavesplatform.com</code> для mainnet</li>
<li><code>nodes-testnet.wavesplatform.com</code> для testnet</li>
<li><code>nodes-stagenet.wavesplatform.com</code> для stagenet</li>
</ul>
<p>REST API ноды разделен на 2 большие части - публичную часть, которая доступна без ключа, и приватную, которая доступна только при передаче API Key. API Key публичных нод Waves получить нельзя (в подавляющем большинстве случаев это и не требуется), но если вам все-таки нужны методы, требующие ключа, то вам необходимо поднимать свою ноду.</p>
<blockquote>
<p>Обратите внимание, что в конфигурационном файле указывается хэш API Key (как правильно получить хэш описано <a href="https://docs.wavesprotocol.org/en/waves-node/node-configuration#how-to-generate-hash-of-the-api-key">тут</a>), а при вызове методов передается сам API Key в открытом виде.</p>
</blockquote>
<p>Во многих библиотеках для Waves на разных языках программирования (о них мы говорим ниже), есть поддержка методов общения с API ноды. Все из них поддерживают метод <code>broadcast</code>, которая отправляет подписанную транзакцию в сеть через REST API. Но некоторые библиотеки имеют и другие полезные функции, например, в <code>waves-transactions</code> есть функции для запроса состояния key-value хранилища любого аккаунта целиком или конкретного ключа (<code>accountData</code> и <code>accountDataByKey</code>), функция для для запроса баланса или информации о скрипте конкретного аккаунта по его адресу (<code>balance</code>, <code>assetBalance</code> и <code>scriptInfo</code>), функции ожидания какой-то высоты блокчейна и ожидания попадания транзакции в блок (<code>waitForHeight</code>, <code>waitForTx</code>, <code>waitForTxWithNConfirmations</code>) и т.д.</p>
<p>REST API ноды достаточно сильно ограничен в плане фильтров и поиска транзакций по полям, но для такого рода операций лучше использовать дата-сервисы</p>
<h2 id="data-service-api">Data service API</h2>
<p>Дата-сервисы доступны по адресу <code>https://api.wavesplatform.com/v0/docs/</code> для использования в mainnet или <code>https://api-test.wavesplatform.com/v0/docs/</code> для testnet, но также вы можете использовать и на своих мощностях, развернув из репозитория проекта - <code>https://github.com/wavesplatform/data-service</code>.</p>
<p>Дата сервисы постоянно выкачивают информацию о данных в блокчейне (блоках и транзакциях) и сохраняют в реляционную базу данных (Postgresql), чтобы обеспечивать большую гибкость поиска (благодаря индексированию). Если вы все-таки захотите использовать дата-сервисы на своих серверах, учтите, что реляционная база данных с блокчейном Waves занимает более 250 гигабайт.</p>
<p>Дата сервисы так же могут сохранять информацию по торгам на DEX, например, информацию об истории операций в различных парах, биржевые свечи и т.д.</p>
<h2 id="%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA%D0%B8-%D0%B4%D0%BB%D1%8F-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%B2-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F">Библиотеки для языков программирования</h2>
<p>В рамках этой книги все примеры были с использованием JavaScript и библиотек <code>waves-transactions</code> и <code>waves-crypto</code>, но кроме них существуют библиотеки и для других языков программирования:</p>
<ul>
<li>JavaScript/TypeScript - <a href="https://github.com/wavesplatform/waves-transactions">waves-transactions</a></li>
<li>Python - <a href="https://github.com/PyWaves/PyWaves/">PyWaves</a></li>
<li>PHP - <a href="https://github.com/deemru/WavesKit">WavesKit</a></li>
<li>C# - <a href="https://github.com/wavesplatform/WavesCS">WavesCS</a></li>
<li>Go - <a href="https://github.com/wavesplatform/gowaves">GoWaves</a></li>
<li>Java - <a href="https://github.com/wavesplatform/WavesJ">WavesJ</a></li>
<li>Kotlin - <a href="https://github.com/wavesplatform/WavesSDK-android">WavesSDK</a></li>
<li>Swift - <a href="https://github.com/wavesplatform/WavesSDK-iOS">WavesSDK</a></li>
</ul>
<p>Библиотеки выше поддерживают последние обновления протокола и имеют во многом похожие примитивы. Относительно сильно отличается библиотека <code>PyWaves</code>.</p>
<p>Кроме перечисленных выше, существуют библиотеки для C, Rust и Elixir, однако они не поддерживают подписание все типы транзакций (или их последние версии) и активно ищут мейнтейнеров.</p>
<h2 id="%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BA-%D0%BD%D0%BE%D0%B4%D0%B5---grpc-%D0%B8-matcher">Расширения к ноде - gRPC и Matcher</h2>
<p>Версия ноды Waves на Scala (напомню, что есть так же версия на Go) позволяет расширять функционал ноды. Расширения имеют возможность подписываться на различные события в блокчейне и реализовывать любой функционал на базе этого. Например, <a href="https://github.com/wavesplatform/dex">Matcher</a>, который является сердцем децентрализованной биржи, использует функционал расширения для общения с нодой и получения актуального состояния балансов и блокчейна. Другой пример расширения - <a href="https://docs.wavesprotocol.org/en/waves-node/extensions/grpc-server/">gRPC сервер</a>, который позволяет общаться с нодой не по текстовому REST, а по бинарному <a href="https://en.wikipedia.org/wiki/GRPC">gRPC</a>, что в некоторых случаях может быть в разы быстрее.</p>
<p>Еще один пример расширения для ноды - <a href="https://github.com/msmolyakov/waves-node-tools-extension">Waves Node Tools Extension</a> за авторством Максима Смолякова, которое автоматизирует выплаты вознаграждения лизерам ноды. Если у вас есть лизинговый пул и люди отправляют токены к вам в лизинг в расчете на получения доли с зарабатываемого нодой, то вы можете использовать это расширение. Расширение фиксирует приходы лизингов, моменты майнинга блоков данной нодой и вклад каждого лизера в генерящий баланс на момент создания блока и, в дальнейшем, распределяет заработанные токены лизерам, удерживая комиссию владельца ноды. Расширение даже может уведомлять владельца ноды о таких событиях как сгенерированный блок или момент выплат с помощью вызова веб-хук.</p>
<p>Установка расширения для ноды обычно состоит из 2 шагов:</p>
<ul>
<li>установка <code>.deb</code> пакета или скачивания <code>.jar</code> файла с логикой расширения</li>
<li>обновления конфигурации ноды с указанием названия пакета расширени</li>
</ul>
<p>В конфигурационном файле ноды так же могут задаваться параметры расширения. Например, установка расширения Waves Node Tools Extension подразумевает установку <code>.deb</code> пакета и добавление в конфигурационный файл следующих строк:</p>
<pre class="hljs"><code><div># добавление расширения в список расширений ноды
waves.extensions += &quot;im.mak.nodetools.NodeToolsExtension&quot;

# настройки расширения Waves Node Tools Extension
node-tools {
  webhook {
    url = &quot;SPECIFY YOUR ENDPOINT&quot; # example: &quot;https://example.com/webhook/1234567890&quot;
    method = &quot;POST&quot;
    headers = [] # example: [ &quot;Content-Type: application/json; charset=utf-8&quot;, &quot;Authorization: Basic dXNlcjpwYXNzd29yZA==&quot; ]
    body = &quot;%s&quot; # example for Integram: &quot;&quot;&quot;{&quot;text&quot;:&quot;%s&quot;}&quot;&quot;&quot;
  }
}
</div></code></pre>
<h1 id="%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F-%D1%81-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%BC">Взаимодействия с пользователем</h1>
<p>Во всех примерах до этого мы рассматривали либо статичные сид фразы прямо в коде либо генерировали сид фразы для пользователей, однако в реальной разработке Web3 приложений нам чаще необходимо взаимодействовать с пользователем, при этом, запрашивать у него сид фразу или приватный ключ мы не можем, так как это совершенно не безопасно. Имея приватный ключ или сид фразу пользователя, можно делать любые действия с его аккаунтом, поэтому децентрализованные приложения запрашивают подпись для каждого конкретного действия.</p>
<p>Давайте сравним логику работы обычного приложения и Web3 приложения, чтобы нагляднее понять разницу в логике. Начнем с обычного веб-приложения, логика работы которого сводится к следующим шагам:</p>
<ol>
<li>Веб браузер запрашивает некий URL</li>
<li>Веб сервер передает в виде ответа HTML, CSS, JavaScript и данные</li>
<li>Пользователь видит отрисованную страницу с данными</li>
<li>Пользователь совершает какие-либо действия (нажатия на кнопки, отправка форм), после которых логика приложения (JavaScript) делает XHR (AJAX) запросы на сервер</li>
<li>Веб сервер отвечает новой порцией HTML, CSS, JavaScript и данных</li>
</ol>
<p><img src="../../assets/8-1-0-web2-app.png" alt="Web2 app" title="Web2 app"></p>
<p>Логика работы Web3 приложения другая:</p>
<ol>
<li>Веб браузер запрашивает некий URL</li>
<li>Веб сервер передает в виде ответа HTML, CSS, JavaScript и данные</li>
<li>JavaScript код запрашивает дополнительные данные у блокчейн ноды</li>
<li>Пользователь видит отрисованную страницу с данными</li>
<li>Пользователь совершает какие-либо действия для чтения (нажатия на кнопки, отправка форм), после которых логика приложения (JavaScript) делает XHR (AJAX) запросы на сервер <strong>и/или к ноде блокчейна</strong></li>
<li>Веб сервер отвечает новой порцией HTML, CSS, JavaScript и данных</li>
<li>Для случаев <strong>записи и обновления данных</strong>, перед отправкой запроса к ноде блокчейна, клиентский код на JavaScript <strong>запрашивает подпись пользователя</strong></li>
</ol>
<p><img src="../../assets/8-1-0-web3-app.png" alt="Web3 app" title="Web3 app"></p>
<p>Существует несколько способов работы с ключами пользователей, и самым распространенным является использование браузерных расширений. В экосистеме Waves принято использование расширения Waves Keeper, которое хранит позволяет подписывать действия пользователя.</p>
<h2 id="waves-keeper">Waves Keeper</h2>
<p>Waves Keeper позволяет пользователям управлять своими аккаунтами:</p>
<ol>
<li>Создавать новые аккаунты со случайной сид фразой или добавлять уже созданные</li>
<li>Отображать балансы токена Waves на каждом аккаунте</li>
<li>Подписывать транзакции и другие данные с использованием</li>
<li>Работать с разными сетями (mainnet, stagenet, testnet или ваша собственная приватная).</li>
</ol>
<p>Waves Keeper доступен для пользователей Google Chrome, Firefox, Edge, Opera, Brave. Ссылки на скачивание вы можете найти <a href="https://wavesprotocol.org/protocol/keeper">на странице продукта на сайте протокола</a>.</p>
<p>В отличие от расширений для других протоколов, например, Metamask для Ethereum, Waves Keeper не является полноценным кошельком, так как не позволяет смотреть историю транзакций или создать транзакцию (только подписать ее).</p>
<div style="text-align: center">
<img src="../../assets/8-1-0-keeper.png" style="max-width: 60%; max-height: 400px">
</div>
<blockquote>
<p>Waves Keeper - безопасный способ управления ключами и взаимодействия с децентрализованными приложениями</p>
</blockquote>
<p>Сид фразы в Waves Keeper хранятся в локальном хранилище расширения в зашифрованном с помощью пароля виде и не доступны для веб сайтов, однако им доступен объект <code>WavesKeeper</code> в глобальной области видимости, который предоставляет API для работы с ключами. Давайте рассмотрим основные методы, которые могут быть полезны при интеграции Waves Keeper в ваш пользовательский интерфейс.</p>
<p>Объект <code>WavesKeeper</code> содержит следующие методы:</p>
<pre class="hljs"><code><div>WavesKeeper = {
  <span class="hljs-attr">auth</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">publicState</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signAndPublishCancelOrder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signAndPublishOrder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signAndPublishTransaction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signCancelOrder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signOrder</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signTransaction</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signRequest</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signTransactionPackage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">signCustomData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">verifyCustomData</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">notification</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">encryptMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">decryptMessage</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">resourceIsApproved</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">resourceIsBlocked</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{},
  <span class="hljs-attr">on</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>{}
}
</div></code></pre>
<p>Большинство методов являются асинхронными и возвращают <code>Promise</code>. Примеры использования некоторых методов доступны на демо-странице <a href="https://kardanovir.github.io/WavesKeeper/">на моем Github</a>.</p>
<p>Метод <code>auth</code> является одним из наиболее часто используемых и позволяет запросить у пользователя информацию о его активном аккаунте. В момент вызова необходимо передать информацию о приложении и данные для подписи. Waves Keeper вернет нам не только информацию об аккаунте, но и подписанные данные из поля <code>data</code>, что позволит в коде нашего приложения валидировать подпись и убедиться, что у пользователя есть ключ от аккаунта с указанным публичным ключом и адресом, а не пытается сломать нашу логику, например, заменяя глобавльный объект <code>WavesKeeper</code>.</p>
<pre class="hljs"><code><div>WavesKeeper.auth({<span class="hljs-attr">name</span>: <span class="hljs-string">'MyApp'</span>, <span class="hljs-attr">data</span>: <span class="hljs-string">'Custom data to Sign'</span>, <span class="hljs-attr">icon</span>: <span class="hljs-string">'https://docs.wavesplatform.com/_theme/brand-logo/waves-docs-logo.png'</span>})
  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
    <span class="hljs-comment">// res будет содержать информацию об аккаунте</span>
  })
  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>{<span class="hljs-built_in">console</span>.log(err)});

</div></code></pre>
<p>После вызова метода будет возвращен <code>Promise</code>, которые успешно разрешится, если пользователь даст разрешение на предоставление доступа, или завершится ошибкой, если отказал в доступе.</p>
<p>В переменной <code>res</code> будет содержаться объект:</p>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">"data"</span>:<span class="hljs-string">"Custom data to Sign"</span>,
    <span class="hljs-attr">"prefix"</span>:<span class="hljs-string">"WavesWalletAuthentication"</span>,
    <span class="hljs-attr">"host"</span>:<span class="hljs-string">"localhost"</span>,
    <span class="hljs-attr">"name"</span>:<span class="hljs-string">"MyApp"</span>,
    <span class="hljs-attr">"icon"</span>:<span class="hljs-string">"https://docs.wavesplatform.com/_theme/brand-logo/waves-docs-logo.png"</span>,
    <span class="hljs-attr">"timestamp"</span>:<span class="hljs-number">1543175910353</span>,
    <span class="hljs-attr">"address"</span>:<span class="hljs-string">"3PKqkMWvjjwjqbVSu8eL48dNfzWc3ifaaWi"</span>,
    <span class="hljs-attr">"publicKey"</span>:<span class="hljs-string">"4WLcUznGiQXCoy2TnCohGKzDR8c14LFUGezvLNu7CVPA"</span>,
    <span class="hljs-attr">"signature"</span>:<span class="hljs-string">"4s2nz8RxT29UwbJoNjPWxYwjsXYeoaMWK4dDM5eQN5gRmeZWGrN1HbpsirhTzWMJFAGtzzw4U78RNRKeEtwficwR"</span>
}
</div></code></pre>
<p>Вместе с адресом аккаунта Keeper возвращает публичный ключ аккаунта, префикс и подпись. Чтобы окончательно убедиться, что у пользователя есть этот аккаунт, необходимо проверить подпись <code>префикс + данные</code> для этого публичного ключа и проверить, что этот публичный ключ преобразуется именно в такой адрес.</p>
<pre class="hljs"><code><div>
<span class="hljs-keyword">import</span> { address, stringToBytes, verifySignature } <span class="hljs-keyword">from</span>  <span class="hljs-string">'@waves/ts-lib-crypto'</span>

<span class="hljs-keyword">const</span> res = {
    <span class="hljs-string">"data"</span>:<span class="hljs-string">"Custom data to Sign"</span>,
    <span class="hljs-string">"prefix"</span>:<span class="hljs-string">"WavesWalletAuthentication"</span>,
    ...,
    <span class="hljs-string">"address"</span>:<span class="hljs-string">"3PKqkMWvjjwjqbVSu8eL48dNfzWc3ifaaWi"</span>,
    <span class="hljs-string">"publicKey"</span>:<span class="hljs-string">"4WLcUznGiQXCoy2TnCohGKzDR8c14LFUGezvLNu7CVPA"</span>,
    <span class="hljs-string">"signature"</span>:<span class="hljs-string">"4s2nz8RxT29UwbJoNjPWxYwjsXYeoaMWK4dDM5eQN5gRmeZWGrN1HbpsirhTzWMJFAGtzzw4U78RNRKeEtwficwR"</span>
}

<span class="hljs-keyword">const</span> signedBytes = stringToBytes(res.prefix + res.data)

verifySignature(res.publicKey, signedBytes, res.signature) &amp;&amp; address({<span class="hljs-attr">public</span>: res.publicKey}) === res.address

</div></code></pre>
<p>Waves Keeper может так же подписывать транзакции, ордера для матчера, запросы для матчера (и сразу отправлять их в сеть, если необходимо) и случайный набор байт. Для подписания транзакции без отправки используется фунция <code>sign</code>:</p>
<pre class="hljs"><code><div>WavesKeeper.sign({
  <span class="hljs-attr">type</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">// 4 - transfer transaction</span>
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">amount</span>: {
      <span class="hljs-attr">assetId</span>: <span class="hljs-string">'WAVES'</span>,
      <span class="hljs-attr">tokens</span>: <span class="hljs-string">"0.00100000"</span>
    },
    <span class="hljs-attr">fee</span>: {
      <span class="hljs-attr">assetId</span>: <span class="hljs-string">'WAVES'</span>,
      <span class="hljs-attr">tokens</span>: <span class="hljs-string">"0.00100000"</span>
    },
    <span class="hljs-attr">recipient</span>: <span class="hljs-string">'3P9E5QeGSF4As6kNtBi8j476gsM8mqnX12f'</span>
  }
})
.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>{
  <span class="hljs-comment">// в переменной res будет содерджаться: </span>
  <span class="hljs-comment">//{</span>
  <span class="hljs-comment">//  "type" : 4,</span>
  <span class="hljs-comment">//  "id" : "2p8zC1riEZpC19PHuqndyaBnr9ndS6jGvFKyTbX2Qpyq",</span>
  <span class="hljs-comment">//  "sender" : "3PGiGn5K5zRgU7o3EfvqFeTR91shNAPyFaa",</span>
  <span class="hljs-comment">//  "senderPublicKey" : "DoQ87i3F9yAX21LrMijEszqMKAHuR867ZFfeXN7UCLe3",</span>
  <span class="hljs-comment">//  "fee" : 100000,</span>
  <span class="hljs-comment">//  "timestamp" : 1543228114324,</span>
  <span class="hljs-comment">//  "proofs" : [ "58U8fr9hUKir9WJkJtHV3eUNV7giCnFX42uDHwtdWW6Rq34P9BMXWEWuVLct1qgp1jhwvAJnvmPqGYZYknSQfW1o" ],</span>
  <span class="hljs-comment">//  "version" : 2,</span>
  <span class="hljs-comment">//  "recipient" : "3P9E5QeGSF4As6kNtBi8j476gsM8mqnX12f",</span>
  <span class="hljs-comment">//  "assetId" : null,</span>
  <span class="hljs-comment">//  "feeAssetId" : null,</span>
  <span class="hljs-comment">//  "feeAsset" : null,</span>
  <span class="hljs-comment">//  "amount" : 100000,</span>
  <span class="hljs-comment">//  "attachment" : ""</span>
  <span class="hljs-comment">//}</span>
})
.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>{
    <span class="hljs-built_in">console</span>.log(err);
});

</div></code></pre>
<p>Обратите внимание, что Waves Keeper принимает не такой же объект, как <code>waves-transactions</code>. Подробнее информацию об API Waves Keeper можете найти в документации на странице <a href="https://github.com/wavesplatform/waveskeeper">Github репозитория проекта</a>.</p>
<h2 id="waves-signer">Waves Signer</h2>
<p>Пользовательский опыт - одна из самых сложных частей разработки dApps. На мой взгляд, одной из ключевых причин отсутствия внедрения технологии является довольно большое количество барьеров. Порой очень сложно начать использовать блокчейн. Waves Keeper хоть и является крайне безопасным инструментов, но так же является барьером, который требует скачивания расширения. Waves Signer призван решить эту проблему.</p>
<p>Waves Signer является объерткой над разными провайдерами, которые непосредственно хранят ключи и подписывают транзакции. Сейчас доступен один провайдер для Waves Signer - провайдер Waves.Exchange, но в будущем будут доступны провайдеры для Waves Keeper, криптокошелька Ledger и десктопного клиента Waves.Exchange.</p>
<p><img src="../../assets/8-1-1-signer.png" alt="Waves Signer scheme" title="Waves Signer scheme"></p>
<p>Существующий провайдер от Waves.Exchange предлагает совершенно новый пользовательский опыт. В отличие от Waves Keeper, где ключи хранятся в расширении, провайдер Waves.Exchange хранит зашифрованные ключи в <code>localStorage</code> сайта <code>https://waves.exchange</code> и предоставляет пользователю интерфейс в виде <code>ifаme</code> окна, где он может согласиться подписать транзакцию или отклонить ее.</p>
<p><img src="../../assets/8-1-2-signer-example.png" alt="Waves Signer example" title="Waves Signer example"></p>
<p>Такой вариант подписи является менее безопасным, так как:</p>
<ul>
<li>Пользователь доверяет свои ключи странице <code>https://waves.exchange</code>. Важно понимать, что страница никуда ее не отправляет и хранит локально на устройстве пользователя, но в теории, в любой момент в будущем может начать отправлять на сервер</li>
<li>В момент подтвеждения подписи транзакции, другие вредоносные скрипты могут перекрыть окно провайдера и дать пользователю подписать другие данные, не те, которые он видит на экране</li>
</ul>
<p>Но данные риски являются компромиссными, чтобы не заставлять пользователей скачивать браузерное расширение.</p>
<p>Давайте рассмотрим, как интегрировать Waves Signer с провайдером от Waves.Exchange на вашу страницу. Для начала создадим кнопки, в которым мы привяжем действия пользователя и подключим скрипт, где будем описывать логику:</p>
<pre class="hljs"><code><div>&lt;main&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"js-login"</span>&gt;</span>Authorization<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>&lt;br&gt;&lt;br&gt;
    &lt;button class="js-invoke"&gt;Invoke Script&lt;/button&gt;&lt;br&gt;
&lt;/main&gt;
&lt;script src="../dist/example.js"&gt;&lt;/script&gt;
</div></code></pre>
<p>В файле <code>example.js</code> подключим сам Signer и провайдер для Waves.exchange:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> Waves <span class="hljs-keyword">from</span> <span class="hljs-string">"@waves/signer"</span>;
<span class="hljs-keyword">import</span> Provider <span class="hljs-keyword">from</span> <span class="hljs-string">"@waves.exchange/provider-web"</span>;

<span class="hljs-comment">// настройки для testnet</span>
<span class="hljs-keyword">const</span> waves = <span class="hljs-keyword">new</span> Waves({<span class="hljs-attr">NODE_URL</span>: <span class="hljs-string">'https://pool.testnet.wavesnodes.com'</span>});
<span class="hljs-comment">// Настройки для провайдера Waves.exchange</span>
<span class="hljs-keyword">const</span> provider = <span class="hljs-keyword">new</span> Provider(<span class="hljs-string">'https://testnet.waves.exchange/signer/'</span>);
waves.setProvider(provider);

</div></code></pre>
<p>Для того, чтобы в момент нажатия на кнопку появлялось окно Waves Signer привяжем callback на событие нажатия:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".js-login"</span>).addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">const</span> userData = <span class="hljs-keyword">await</span> waves.login();  <span class="hljs-comment">// Вызываем Waves Signer </span>
        event.target.classList.add(<span class="hljs-string">"clicked"</span>);
        event.target.innerHTML = <span class="hljs-string">`
            authorized as &lt;br&gt;
            <span class="hljs-subst">${userData.address}</span>`</span>;              <span class="hljs-comment">// Получаем адрес пользователя</span>
    } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'login rejected'</span>)        <span class="hljs-comment">// пользователь отклонил запрос авторизации</span>
    }
});
</div></code></pre>
<p>После нажатия кнопки и разрешения авторизации, адрес пользователя появится на самой кнопке.</p>
<p>Давайте рассмотрим пример создания и отправки транзакции по нажатию на кнопку:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".js-invoke"</span>).addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    waves.invoke({
        <span class="hljs-attr">dApp</span>: <span class="hljs-string">"3MuN7D8r19zdvSpAd1L91Gs88bcgwUFy2mn"</span>,
        <span class="hljs-attr">call</span>: {
            <span class="hljs-attr">function</span>: <span class="hljs-string">"faucet"</span>
        }
    }).broadcast().then(<span class="hljs-built_in">console</span>.log)
});
</div></code></pre>
<p>API для формирования транзакций совпадает с тем, что передается в <code>waves-transaction</code>, что может быть крайне удобно во время разработки.</p>
<p>Более подробную информацию о Waves Signer и пример интеграции вы сможете найти в статье <a href="https://medium.com/@izhur27/getting-started-with-waves-signer-893017c9b7ae">Владимира Журавлева на medium</a>.</p>
<h1 id="5-%D0%B2%D0%B5%D1%89%D0%B5%D0%B9-%D0%BE-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D1%85-%D1%8F-%D1%85%D0%BE%D1%82%D0%B5%D0%BB-%D0%B1%D1%8B-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C-%D0%B4%D0%BE-%D1%82%D0%BE%D0%B3%D0%BE-%D0%BA%D0%B0%D0%BA-%D0%BD%D0%B0%D1%87%D0%B0%D0%BB-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%B0%D1%82%D1%8B%D0%B2%D0%B0%D1%82%D1%8C-%D0%B4%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">5 вещей, о которых я хотел бы знать до того, как начал разрабатывать децентрализованные приложения</h1>
<h2 id="%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD%D1%8B-%D0%B2%D1%81%D0%B5-%D0%B5%D1%89%D0%B5-%D0%BA%D0%B0%D0%BA-spectrum">Блокчейны все еще как Spectrum</h2>
<p>Многие из разработчиков слышали про проблемы масштабирования блокчейнов, про то, что это не про highload ни разу, но когда я только начал увлекаться блокчейном, я не до конца осознавал, что меня ожидает. Саша Иванов как-то в своей статье <a href="https://medium.com/wavesprotocol/you-cant-calculate-on-the-blockchain-906f9b110829">&quot;You can't calculate on the blockchain&quot;</a> написал, что блокчейн сейчас это как 8-битные компьютеры Sinclair ZX Spectrum в прошлом. Эти компьютеры сыграли очень важную роль в эволюции технологий, но по сравнению с современными персональными компьютерами и телефонами они были как программируемый калькулятор. Блокчейн сейчас во многом похож на ZX Spectrum по вычислительным мощностям для каждого отдельного приложения. И это правильно, потому что блокчейн не для скорости вычислений, а для удаления посредников.</p>
<p>Все ограничения блокчейна влияют не только на сложность программ (например, очень мало децентрализованных приложений с сотнями тысяч строк кода), но и на то, <strong>как</strong> мы думаем как разработчики. Картинка ниже во многом объясняет отличия, потому что разработчики децентрализованных приложений как разработчики игр в 1996.</p>
<p><img src="https://media.discordapp.net/attachments/694073260509233212/714476772615520336/d391f9ea-2091-8043-a54c-a844862373a0.png" alt="img"></p>
<p>Разработчики обычных приложений могут не думать о проблемах, которые знакомы разработчикам децентрализованных приложений:</p>
<ul>
<li>Необходимость бороться за каждый байт и каждую вычислительную операцию</li>
<li>Отсутствие возможности легко обновить свое приложение и доставить клиентам (в этом плане блокчейн Waves выгодно отличается от конкурентов и предоставляет такие возможности)</li>
<li>Высокая цена ошибки</li>
</ul>
<p>Конечно, у всех этих ограничений есть и плюсы. Например, невозможность писать все, что захочется, уменьшает поле проблем с безопасностью. О некоторых других преимуществах я говорил во время конференции San Francisco Blockchain Week 2019 - https://www.youtube.com/watch?v=gMcif_ADWak</p>
<h2 id="%D0%B4%D1%80%D1%83%D0%B3%D0%BE%D0%B9-%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D0%BA%D0%B8%D0%B9-%D0%BE%D0%BF%D1%8B%D1%82">Другой пользовательский опыт</h2>
<p>Когда я только начал интересоваться разработкой приложений для блокчейн (в далеком 2014 году), я не до конца осознавал, что вместе с изменением принципов описания бизнес-логики приложений меняется и пользовательский опыт. Например, пользователь привык к тому, что авторизуется с помощью логина и пароля в приложении, однако в случае с блокчейном ему необходимо использовать свой приватный ключ для подписи. Чаще всего принято приватный ключ хранить в браузерном расширении (смотри Waves Keeper), что является дополнительным барьером для пользователей на ПК и большой головной болью для пользователей на мобильных. Также добавляется дополнительный шаг для каждой создаваемой транзакции, что может полностью уничтожить user experience и осложнить вам бизнес многократно.</p>
<p>В последнее время начали появляться продукты, которые пытаются предлагать привычные шаблоны пользователям, при этом не принося в жертву децентрализацию и безопасность, например, Waves Signer (https://github.com/wavesplatform/signer). Однако, мы только в начале этого пути и еще предстоит много этапов развития.</p>
<p>В таких условиях крайне важно становится доносить до пользователя зачем нужен блокчейн в вашем приложении, какие он дает преимущества и почему стоит мириться с возможным ухудшением пользовательского опыта. И это следующая вещь, которую я хотелл бы знать в начале своего пути.</p>
<h2 id="%D0%B4%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D1%8D%D1%82%D0%BE-%D0%BD%D0%B5-%D1%86%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E">Децентрализация это не ценность по умолчанию</h2>
<p>Многие разработчики dApps в начале своего пути думают, что любой продукт можно сделать лучше, просто добавив туда блокчейн и децентрализацию. На самом деле это не так, потому что блокчейн кроме децентрализации ведет и к изменению пользовательского опыта (user-experience), чаще всего в худшую сторону. Понимание, зачем вам нужен блокчейн, может сэкономить вам месяцы и годы разработки продукта, который с блокчейном стал только хуже. Как пишет известный инвестор и бизнесмен Питер Тиль, ваш продукт должен быть в 10 раз лучше конкурентов, чтобы завоевать клиентов и рынок. И блокчейн продукты не исключение. Децентрализация - это очень круто, но добавление такой характеристики в какой-то процесс должно повышать ценность в глаза пользователя минимум в несколько раз. Вы же не говорите что-то вроде &quot;Наш продукт сделан на СУБД Postgres, поэтому он лучше конкруентов&quot;, так и с блокчейном.</p>
<p>Универстальной формулы как определить добавляет ли ценности блокчейн не существует, но вопрос с которого стоит начать – &quot;Какие стороны участвуют в процессе, который я пытаюсь улучшить и почему они друг другу не доверяют?&quot;. Если сторона только одна или проблемы доверия нет, то с большой степенью вероятности вам еще надо подумать, нужен ли блокчейн.</p>
<h2 id="%D0%BC%D0%BE%D1%89%D1%8C-%D0%B2-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B0%D0%B1%D0%B8%D0%BB%D0%B8%D1%82%D0%B8">Мощь в композиции (композабилити)</h2>
<p>Для многих стартапов и компаний нормальной является наличие синдрома <strong>NIH</strong> (Not invented here) (https://en.wikipedia.org/wiki/Not_invented_here). Жажда &quot;сделать все самим&quot; в блокчейн сфере может привести к совсем нежелательным последствиям. Важная ценность блокчейна заключена в том, что он представляет из себя унифицированный интерфейс общения разных децентрализованных приложений. Если вы знакомы с понятием &quot;шина данных&quot; (https://en.wikipedia.org/wiki/Enterprise_service_bus), то блокчейн очень близок к этому. Представьте, что у вас есть доступ к данным большого количества других приложений прямо в вашей среде выполнения кода.</p>
<p>Другая аналогия, которая поможет понять, что такое композиция - кубики лего, которые вы легко можете использовать, чтобы собрать что-то уникальное.</p>
<p>Например, в протоколе Waves используется алгоритм консенсуса LPoS, который позволяет получать доход с лизинга (стейкинга). Приложение Neutrino от команды Ventruay Lab использует это в своем стейбкоине, чтобы давать пользователь возможность стейкать свои токены. Любое другое может принимать стейблкоины Neutrino как средство платежа. Это и есть композиция, когда одни приложения опираются на другие, используют их и дополняют.</p>
<p>В обычном Web2 мире у многих сервисов есть свои API, которые тоже позволяют интегрироваться с ними, однако есть несколько важных отличий:</p>
<ul>
<li>Web2 приложения часто требуют регистрироваться, получать специальные API ключи, которые дают доступ к данным и могут быть отозваны провайдерами в любое время. В случае с блокчейн приложениями вам не нужны ключи доступа, чтобы получать данные или вызывать методы приложений, так как все приложения выполняются в общем пространстве</li>
<li>В мире классических Web2 приложений огромное количество различных протоколов работы API (авторизация, data encoding, etc). В мире приложений для блокчейна, таких проблем попросту нет. Вам достаточно знать только какие аргументы принимают какие функции. И это вы можете сами посмотреть в блокчейне, даже если у приложения отсутствует документация.</li>
</ul>
<h2 id="%D0%B2%D1%81%D0%B5-%D1%82%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE-%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D0%B5%D1%82%D1%81%D1%8F">Все только начинается</h2>
<p>Битокину уже исполнилось больше 10 лет и может показаться, что все приложения уже сделаны, все &quot;свежие&quot; идеи уже реализованы и эра интересных стартапов в блокчейн мире закончилась. Это далеко не так, ведь каждые несколько лет в блокчейн мире появляются новые возможности, технологии, тренды. Можно сказать, что рынок предоставляет новым игрокам шансы каждые несколько лет или даже чаще.</p>
<p>Можно с уверенностью сказать, что самые интересные проекты ждут нас впереди.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B3%D0%BB%D0%B0%D0%B2%D0%B0-9-%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B8%D0%BC-%D0%B2-%D0%B1%D1%83%D0%B4%D1%83%D1%89%D0%B5%D0%B5">Глава 9. Смотрим в будущее</h1>
<p>Протокол Waves постоянно развивается, регулярно появляются новые проекты, новые пользователи и способы применения блокчейна. Давайте поговорим о том, что сейчас находится &quot;на волне хайпа&quot; и чего ожидать в будущем.</p>
<p>Кроме этого, стоит ответить на вопрос &quot;когда нужен&quot; блокчейн, и не абстрактно и в теории, а максимально конкретно и примерами. Блокчейн является всего лишь технологией, которая требует применения, и без применения и пользователей ничего не стоит.</p>
<h2 id="%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-%D0%B1%D0%BB%D0%BE%D0%BA%D1%87%D0%B5%D0%B9%D0%BD">Когда нужен блокчейн?</h2>
<p>Существует 4 основных принципа, которые необходимо иметь в виду при попытке использовать блокчейн:</p>
<ul>
<li><strong>Блокчейн - решение для общих проблем</strong>. Блокчейн подходит лучше всего в ситуациях, когда существут несколько сторон, разделяющих одну проблему, не объязательно с одной стороны.</li>
<li><strong>Блокчейн является технологией для создания экосистем.</strong> Открытые или замкнутные экосистемы идеально подходят для блокчейна. В случае с открытыми экосистемами, возможность быстро присоединиться к общему протоколу обмена данными и совершения операций является ключевой характеристикой, тогда как в случае с закрытыми важнее всего отсутствие необходимости передачи контроля одной стороне.</li>
<li><strong>Токены являются способом организации и упорядочивания отношений</strong>. Если токены создают новые виды взаимоотношений или приводят в больший порядок существующие коммуникации, то применение токена имеет смысл.</li>
</ul>
<p>В данный момент существует 2 направления, в которых новые Web3 децентрализованные приложения имеют максимальные перспективы - децентрализованные финансы и корпоративные приложения.</p>
<h2 id="%D0%B4%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D1%84%D0%B8%D0%BD%D0%B0%D0%BD%D1%81%D1%8B">Децентрализованные финансы</h2>
<p>Блокчейн и финансовые сервисы неотделимы друг от друга, но если раньше блокчейн выполнял функцию сохранения богатств или был спекулятивным активом, то сейчас активно развивается в сторону построения полноценной финансовой сервисов на токенах. Рынок децентрализованных финансовых сервисов чаще всего называют DeFi.</p>
<p>Децентрализованные платформы и приложения предлагают в данный момент сервисы торговли и обмена токенами, сервисы кредитования, алгоритмический стейблкоины, деривативы, платежные системы и опционы. Практически все сервисы основаны на принципе залогового обеспечения криптовалютами, и в данный момент объем залогов на смарт-контрактах в основных блокчейнах (Ethereum, Waves, Bitcoin и т.д.) составляет более $770 млн по данным <a href="https://defipulse.com/">https://defipulse.com</a>. В феврале 2020 года это значение превышало $1,29 млрд и снижение вызвано скорее снижением стоимости основных криптовалют по отношению к доллару.</p>
<p><img src="../../assets/9-0-1.png" alt="DeFi pulse" title="Billy dashboard"></p>
<p>В экосистеме Waves давно существует децентрализованная биржа waves.exchange, которая была и является пионером децентрализованных финансовых сервисов на блокчейне. Сейчас waves.exchange предоставляет доступ к следующим финансовым инструментам:</p>
<ol>
<li>https://waves.exchange - гибридная биржа, в сердце которого работает matcher. Объем сделок на биржи составляет порядка $500 000 в день.</li>
<li>https://lombardini.io - крипто-ломбард, который может выдать токены Waves в обмен на Bitcoin в залог (и обратно). За пользование токенами сервис возьмет небольшой процент.</li>
<li>https://waveflow.xyz - децентрализованное приложение с константной ликвидностью. Приложение хранит различные токены, выпущенные на Waves, и позволяет обмениваться ими. Цена вычисляется в зависимости от количества того или иного токена на балансе приложения. Чем меньше токенов осталось на аккаунте, тем дороже они будут и наоборот.</li>
<li>https://neutrino.at - алгоритмический стейблкоин, привызянный к доллару США. Каждый токен Neutrino равен $1, так как в обеспечении токена лежит соответствующее количество токенов Waves. Код Neutrino учитывает рыночную цену токена Waves на централизованных биржах и балансирует обеспечение с помощью бондов. Схема работы Neutrino описана в <a href="https://neutrino.at/whitepaper">white paper</a>, а исходные коды <a href="https://github.com/ventuary-lab/neutrino-contract">выложены на Github</a>.</li>
</ol>
<p>Neutrino является наиболее успешным DeFi приложением в экосистеме Waves, так как на контракте заблокировано более 4,6 млн Waves и выпущено более $9 млн.</p>
<p>Особенностью DeFi приложений является <em>композируемость</em>. Под ней понимается возможность связывать приложения друг с другом, использовать возможности одного приложения в другом. Например, вы можете сделать DeFi приложение, которое использует токены Neutrino или данные из контракта Neutrino и WaveFlow одновременно. Для этого не нужны специальные API или разрешения, так как протоколом является блокчейн, в котором все данные и параметры функций открыты, а ваше децентрализованное приложение может читать данные из key-value хранилища любого другого DeFi приложение.</p>
<h2 id="%D0%BA%D0%BE%D1%80%D0%BF%D0%BE%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">Корпоративные приложения</h2>
<p>Все преимущества блокчейна раскрываются в условиях, когда существует несколько сторон, которые друг другу не доверяют или не хотят доверять. Такие условия часто встречаются в корпоративной среде, когда несколько компаний или подразделений в одной организации хотят обмениваться данными, но не готовы отдавать контроль над ними кому-либо из участников процесса.</p>
<p>Примером удачного применения блокчейна в корпоративной среде является токен <a href="https://iambilly.app">Billy</a>, который решает общую проблему сотрудников компании и руководства, используя токены как способ организации процесса поощрения сотрудников. Например, компания A использует Billy для более справедливого распределения льгот и персонализации преимуществ.</p>
<p>В компании выделяется ежегодный бюджет на поощрения сотрудников с помощью путевок, дополнительных отпусков и услуг (расширенные программы медицинского страхования, сувенирная продукция и т.д.). Используя токен &quot;спасибо&quot;, компания А выбирает наиболее ценных сотрудников. Благодаря открытости блокчейна все сотрудники видят свою результативность и могут оценить объективность выбора людей для поощрения. Такая прозрачность дополнительно мотивирует персонал.</p>
<p>Токены создают целую экосистему, когда сотрудники могут мотивировать своих коллег помогать им, благодаря их токенами.</p>
<p><img src="../../assets/9-0-0.png" alt="Billy dashboard" title="Billy dashboard"></p>
<p>Для руководства компании появляется дополнительная возможность для анализа эффективности сотрудников не только качественно (регулярные прозрачные процессы оценки коллегами, с которыми больше всего взаимодейтсвий), но и количественно (составление общего рейтинга сотрудников и подразделений).</p>
<h1 id="gravity-hub">Gravity Hub</h1>
<p>В конце 2019 в Берлине Александр Иванов, основатель протокола Waves анонсировал создание Gravity Hub, нового продукта команды, которая призвана сразу несколько проблем.</p>
<p>Мы сейчас наблюдаем бурное развитие развитие многообразия блокчейн-протоколов, платформ и экспериментальных разработок, почти такой же бурный рост Интернета мы наблюдали 20 лет назад. Разнообразие технологий порождает прогресс, в то же самое время оно приводит к ослаблению принятия технологий массами (mass adoption). Разработчики продуктов и организации сейчас вынуждены выбирать конкретную технологию или протокол, на базе которого они будут строить свои приложения. В свою очередь, пользователи и аудитория других протоколов теряют доступ к таким приложениям. Все это делает экосистему в целом очень разобщенной и экономически неэффективной.</p>
<p>Каждая децентрализованная система с внутренней экономикой токена является замкнутой с точки зрения обмена информацией, как с другими сетями,  так и с внешним миром. Для передачи данных из внешнего мира в блокчейн сеть, а также коммуникации между различными блокчейн сетями необходимо доверять, так называемым, оракулам. Возникает парадокс необходимости доверия отдельным элементам в системах, предназначенных убрать элементы доверия. Поиск и разработка решений, создающих условия повышенной надежности и безопасности использования  блокчейн сетей с оракулами, а также коммуникации между сетями является ключевой задачей в индустрии на данный момент.</p>
<p>Наконец, эффективное решение задачи кросс-блокчейн коммуникации и оракулов данных открывает возможности для горизонтального масштабирования продуктов, которые построены над блокчейн протоколами, через механизм, так называемых, сайдчейнов.</p>
<p>На сегодняшний день уже существуют проекты, решающие описанные выше проблемы: Chainlink, CosmosHub, Polkadot и другие. Однако, большинство существующих решений обладают тремя общими недостатками:</p>
<ul>
<li>Ориентированы на развитие своего собственного, дополнительного блокчейна, вместо того, чтобы действительно быть блокчейн-агностик решением.</li>
<li>Вносят в систему новый уровень сложности в виде токена, с особыми экономическими свойствами и плавающим, сильно волатильным курсом.</li>
<li>Не являются в реальности комплексной блокчейн агностик системой оракулов, поддерживающей коммуникацию блокчейн сетей с внешним миром, кросс-блокчейн коммуникацию и переводы средвств, а также сайдчейны в рамках одной целостной структуры.</li>
</ul>
<p>Gravity Hub призван решить обозначенные проблемы и представляет собой решение следующих задач, отсортированных в порядке приоритета:</p>
<ul>
<li>Блокчейн агностик децентрализованная кросс-блокчейн коммуникация: децентрализованные приложения в разных блокчейнах должны иметь возможность обмениваться данными или ценностями. Например владелец аккаунта на Waves должен иметь возможность работать с приложением Uniswap в сети Ethereum, без необходимости создания аккаунта в Ethereum и покупки токенов Eth. Или, любой владелец аккаунта в сети Ethereum будет иметь возможность пользования приложением Neutrino dApp и заниматься стейкингом без необходимости создания аккаунта в Waves и покупки Waves на биржах. Все это будет автоматически обеспечиваться системой Gravity Hub.</li>
<li>Экономическая мотиваця агентов предоставлять данные из реального мира и других блокчейнов: Gravity Hub предоставляет провайдерам данных возможность монетизировать свои услуги, выражаемые в нативных токенах поддерживаемых Gravity Hub блокчейн платформ.</li>
<li>Наличие возможности получать данные из реального мира и из других блокчейнов без необходимости доверия кому-либо открывает возможности для масштабирования сетей с использованием сайдчейнов.</li>
<li>Предоставление разработчикам технического разнообрания, чтобы они могли выбирать наиболее подходящие инструменты: виртуальные машины или не Тьюринг-полные языки программирования; фиксированные или изменяющиеся комиссии; алгоритмы консенсуса (Proof of Work, Proof of Stake, Leased Proof Of Stake, BFT и т.д.).</li>
</ul>
<blockquote>
<p>Проще говоря, Gravity Hub решает 2 проблемы:</p>
<ol>
<li>проблему оракулов - через их децентрализацию (мы рассматривали проблемы в главе 7 на примере Oraculus)</li>
<li>проблему несовместимости протоколов блокчейнов - через возможность пересылать данные и средства из одного блокчейна в другой</li>
</ol>
</blockquote>
<p><strong>В отличие от других похожих платформ, Gravity Hub не использует свой токен, чем выгодно отличается от конкурентов.</strong></p>
<p>Схема работы GravityHub представлена на схеме ниже:</p>
<p><img src="../../assets/9-1-0.png" alt="Gravity Hub" title="Gravity Hub"></p>
<p>Разработка Gravity Hub сейчас находится в активной фазе, ведется исследовательская работа и идут обсуждения лучшей архитектуры решения, поэтому, если вам интересно принять участие, вы можете это сделать в Github Gravity Hub.</p>
<div style="page-break-after: always; visibility: hidden">
\pagebreak
</div>
<h1 id="%D0%B7%D0%B0%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5">Заключение</h1>
<p>Мир Web3 приложений, блокчейнов и децентрализованных систем активно развивается, все больше новых интересных решений и идей возникает в сообществе, поэтому покрыть все особенности Web3  приложений или платформы Waves не представляется возможным в рамках одной книги (или даже трех). В то же время, полученные в этой книге знания помогут вам начать разработку приложений на протоколе Waves максимально быстро, правильно спроектировать архитектуру и найти правильные ресурсы для дальнейшего погружения.</p>
<p>Я желаю вам наслаждаться созданием вашего первого (или может быть уже далеко не первого) работающего децентрализованного приложения на Waves. Блокчейн платформам не хватает приложений, которые смогли бы привлечь большое количество пользователей, поэтому я желаю, чтобы ваше приложение стало именно таким и смогло поменять пользовательские привычки.</p>
<p>Если вы хотите продолжить изучение протокола Waves или даже хотите принять непосредственное участие в его развитии, я приглашаю вас посетить страницу Github <a href="https://github.com/wavesplatform">Waves Protocol</a> и пройти курс <a href="">Mastering Web3 With Waves на Coursera</a>.</p>
<p>Если вы хотите пообщаться с такими же разработчиками как вы или задать вопрос автору книги, то присоединяйтесь к группе в Telegram - https://t.me/waves_ride_dapps_dev</p>

</body>
</html>
